<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《南京大学操作系统笔记》</title>
    <link href="/2023/11/05/%E3%80%8A%E5%8D%97%E5%A4%A7OS%E7%AC%94%E8%AE%B0%E3%80%8B/"/>
    <url>/2023/11/05/%E3%80%8A%E5%8D%97%E5%A4%A7OS%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>课程来源：NJU-OS(22 spring)</p><p>课程主页：<a href="https://github.com/qlhhahaha/CS61C-SU20">操作系统：设计与实现 (2022 春季学期)</a></p><p>课程视频：<a href="https://space.bilibili.com/202224425/channel/collectiondetail?sid=192498">https://space.bilibili.com/202224425/channel/collectiondetail?sid=192498</a></p>          </div><h1>《南大OS笔记》@qlhhahaha</h1><h2 id="Lecture0、基础知识补充">Lecture0、基础知识补充</h2><ol><li><p><strong>ECF（Exceptional Control Flow，异常控制流）</strong></p> <img src="https://s2.loli.net/2023/11/05/HoTh3f4UIMEAOV8.jpg" style="zoom: 50%;" /></li></ol><p>​<img src="https://s2.loli.net/2023/11/05/U2RelQGcsMA4EVh.png" style="zoom: 67%;" /></p><div class="note note-warning">            <p>💡 PS. 中断是异常的一种，除它外还有故障中止、系统调用等异常类型</p>          </div><ol start="2"><li><strong>bootloader</strong></li></ol><p>也是一个独立的程序，体量小，是系统上电后执行的第一段代码，在完成CPU和相关硬件的初始化之后，再将操作系统映像装载到内存中，然后跳转到操作系统所在的空间，启动操作系统执行</p><ol start="3"><li><p><strong>操作系统内核启动过程</strong></p><ul><li><strong>CPU Reset</strong>：CPU执行复位向量的指令，通常指向0xFFFF0（32位）或者0xFFFFFFF0（64位），这个地址是主板ROM上的BIOS/UEFI入口</li><li><strong>firmware（主板ROM装的BIOS/UEFI）</strong>：bios查询可以用来启动操作系统的存储设备</li><li>**bootloader：**加载并引导操作系统内核</li><li>**Kernel_start()：**执行操作系统内核以及启动各种服务</li></ul></li></ol><h2 id="Lecture1、概述">Lecture1、概述</h2><ol><li><p><strong>操作系统是什么？</strong></p><ul><li><p>设计\应用视角：操作系统=对象+API（对应课程的Mini Lab，使用OS API实现黑科技代码）</p></li><li><p>实现\硬件视角：操作系统=C程序（对应OS Lab，自己动手实现一个真正的操作系统）</p></li></ul></li><li><p><strong>程序=状态机</strong></p><p>C程序也是一个状态机模型，其中状态即堆+栈，执行一条语句即实现状态的迁移</p></li></ol><p>​<img src="https://s2.loli.net/2023/11/05/x7apfZhNHC9ques.png" style="zoom:50%;" /></p><ol start="3"><li><p><strong>如何在程序的两个视角之间切换？</strong></p><p>通过编译器完成</p></li></ol><p>​<img src="https://s2.loli.net/2023/11/05/C67UHzRwhpOea5c.png" style="zoom:50%;" /></p><p>​编译（优化）的正确性（soundness）：</p><p>​<strong>S与C的可观测行为严格一致，即C代码状态机上所有不可优化的barrier都被正确地翻译到汇编上</strong></p><p>​<img src="https://s2.loli.net/2023/11/05/5G9tMFhkjnwBOpE.png" style="zoom:67%;" /></p><p>​</p><h2 id="Lecture2、多处理器编程-并发程序执行">Lecture2、多处理器编程 &amp;&amp; 并发程序执行</h2><ol><li><strong>并发（concurrency）和并行（parallel）</strong><ul><li>并发：一个处理器处理多个任务，实际上先后执行，看起来同时发生</li><li>并行：多个处理器（或单处理器的多核）同时处理多个不同任务，物理上真正同时</li></ul></li></ol><p>​</p><ol start="2"><li><strong>并发的基本单位：线程</strong></li></ol><p>各个线程有自己的PC、寄存器、栈空间，但全局的静态空间是共享的</p><p><img src="https://s2.loli.net/2023/11/05/eOM5gRbPGw1WSup.png" alt=""></p><ol start="3"><li><p><strong>并发牺牲了什么？</strong></p><ul><li><p><strong>原子性</strong></p><p>案例：山寨多线程支付宝</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> balance = <span class="hljs-number">100</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Alipay_withdraw</span><span class="hljs-params">(<span class="hljs-type">int</span> amt)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (balance &gt;= amt) &#123;<br>    <span class="hljs-built_in">usleep</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// unexpected delays</span><br>    balance -= amt;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Talipay</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>  <span class="hljs-built_in">Alipay_withdraw</span>(<span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">create</span>(Talipay);<br>  <span class="hljs-built_in">create</span>(Talipay);<br>  <span class="hljs-built_in">join</span>();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;balance = %lu\n&quot;</span>, balance);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://s2.loli.net/2023/11/05/Tq8DOc1tKJRNdgr.png" alt=""></p><p>解释：</p><p>“程序由独占处理器执行”的基本假设在现代多处理器系统上不再成立。对于单处理器多线程来说，线程在运行时可能被中断，切换到另一个线程；对于多处理器多线程来说，线程根本就是并行执行的</p><p>解决方法：</p><p>线程池</p></li><li><p><strong>顺序</strong></p>  <img src="https://s2.loli.net/2023/11/05/IKrbYvFkix4OlGJ.png" style="zoom:50%;" /></li><li><p><strong>可见性</strong></p><p>简单地说，现代处理器也是一个动态的编译器，单个处理器会把汇编代码“编译”更小的微op，每个微op都有Fetch、Issue、Execute、Commit四个阶段</p>  <img src="https://s2.loli.net/2023/11/05/xGykX2wqzlApn75.png" style="zoom:67%;" /></li></ul></li></ol><p>​这样的“乱序”导致了可见性的丧失</p><p>​解决方法：</p><p>​<img src="https://s2.loli.net/2023/11/05/mLeaRVvpNj7ikJ4.png" style="zoom:67%;" /></p><ol start="4"><li><p><strong>关于互斥算法的一个失败尝试</strong></p><p>能否通过下面这种方式来实现互斥算法捏？</p><p>具体来说，比如通过加锁来实现互斥</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> locked = UNLOCK;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">critical_section</span><span class="hljs-params">()</span> </span>&#123;<br>retry:<br>  <span class="hljs-keyword">if</span> (locked != UNLOCK) &#123;<br>    <span class="hljs-keyword">goto</span> retry;<br>  &#125;<br>  locked = LOCK;<br><br>  <span class="hljs-comment">// critical section</span><br><br>  locked = UNLOCK;<br>&#125;<br></code></pre></td></tr></table></figure><p>答案是不行，比如，可能两个线程几乎同时绕过 if 检测，然后上两次锁，并都执行critical section</p></li><li><p><strong>另一个成功的尝试：Peterson算法</strong></p> <img src="https://s2.loli.net/2023/11/05/yn4P9Vzvehp6WS1.png" style="zoom: 67%;" /></li></ol><p>​为什么可以实现互斥呢？我们可以通过分类讨论来定性理解一下：</p><ul><li>假如A想上厕所但B不想：此时A举旗，发现B没举，OK，那他直接去上就行</li><li>假如A、B同时想上厕所：同时举旗，然后同时往厕所门上贴标签，<strong>谁手速快最后门上就是谁的名字</strong>（因为贴的是对方的名字，所以先贴的那个会被后贴的那个覆盖掉——看起来互相谦让，其实最后还是自私拼手速）。假设A手速更快，那么最后标签就是“A正在使用”，则A进、B等待</li></ul><div class="note note-warning">            <p>💡 PS.  “互相贴对方名字”（谦让turn）这个设定其实很有趣，因为如果只举旗而不贴标签的话，那么同时举旗后没办法保证谁进谁不进——这正是上面第4点算法的失败之处</p>          </div><h2 id="Lecture3、互斥与同步">Lecture3、互斥与同步</h2><ol><li><p><strong>提出锁机制的motivation</strong></p><p>在共享内存上实现互斥的根本困难：<strong>不能同时读/写内存。</strong></p><p>怎么说？想象物理世界中，大家都想上厕所，所以同时去拿厕所钥匙。谁拿到钥匙，就同时触发了“我get了钥匙”和“对其他人来说，钥匙无法被get”两件事 —— 言下之意，物理世界中的读写操作是原子性的！读和写可以在一瞬间被同时完成！</p><p>那在计算机世界中是这样吗？显然不是，线程A读出这把钥匙后，还要花时间再去改写钥匙状态（哪怕耗时很少）；那么在这段时间里，线程B可能也会读出这把钥匙，最终导致互斥失败。</p><p>顺着上面的思路，我们很容易想到：欸，那如果我们找到一种<strong>原子性的读写方式</strong>，是不是就可以和物理世界一样，解决这个问题了捏？</p></li><li><p><strong>自旋锁（Spin Lock）</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//实现互斥：自旋锁</span><br><br><span class="hljs-type">int</span> key = YES; <span class="hljs-comment">//值为YES表示钥匙可用</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>retry:<br>  <span class="hljs-type">int</span> got = <span class="hljs-built_in">xchg</span>(&amp;key, NOPE);<br>  <span class="hljs-keyword">if</span> (got == NOPE)<br>    <span class="hljs-keyword">goto</span> retry;<br>  <span class="hljs-built_in">assert</span>(got == YES);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">xchg</span>(&amp;key, YES)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 got = xchg(&amp;table, NOPE) 即是一条原子性的交换指令，它表示<strong>同时</strong>完成”取出table的值给到got“和”把NOPE写入table“两个操作</p><p>想想，为啥有了这个操作，就能实现互斥？</p><p>假设线程A第一个拿到钥匙，也就是用 xchg 取出钥匙并写入NOPE（这个操作过程是原子的，所以其它线程干扰不了），那么它会跳过下面那个 if ，直接进入critical section（临界区）；而对于其它后来的线程，再试图用 xchg(&amp;table, NOPE)取钥匙时，会发现里面的值已经是NOPE了，那么就会在下面的 if 判断里空转（所谓**”自旋“**就是这个意思）。直到线程A执行unlock()，钥匙里的值重新变为YES，其它线程才有机会进入临界区。</p><p>上述代码也可以简写为下列形式（更常见）：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>; <span class="hljs-comment">//0表示钥匙可用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">xchg</span>(&amp;locked, <span class="hljs-number">1</span>)) ; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">xchg</span>(&amp;locked, <span class="hljs-number">0</span>); &#125;<br></code></pre></td></tr></table></figure> <div class="note note-warning">            <p>💡 PS. 用python实现自旋锁时，会发现只需要用一行 x, y = y, x 就可以实现原子性的交换 —— 再次映证人生苦短我用py的真理。。</p>          </div></li><li><p><strong>自旋锁的缺陷和应用场景</strong></p></li></ol><p>由自旋锁的实现机制，可以自然而然地想到它有以下缺陷：</p><ul><li><p>自旋（共享变量）会触发处理器间的<strong>缓存同步</strong>，延迟增加：一旦一个线程改变了共享变量，就要在各个cpu的缓存之间同步，而缓存一致性本身会增加开销</p></li><li><p>除了进入临界区的线程，其它处理器上的线程都在**空转，**且争抢锁的处理器越多，利用率越低</p></li><li><p>获得自旋锁的线程可能<strong>被操作系统切换出去</strong>，从而造成100%的资源浪费</p><p>我们可用下列代码进行性能测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread-sync.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10000000</span><br><span class="hljs-type">spinlock_t</span> lock = <span class="hljs-built_in">SPIN_INIT</span>();<br><br><span class="hljs-type">long</span> n, sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//自旋锁</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tsum</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-built_in">spin_lock</span>(&amp;lock);<br>    sum++;<br>    <span class="hljs-built_in">spin_unlock</span>(&amp;lock);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(argc == <span class="hljs-number">2</span>);<br>  <span class="hljs-type">int</span> nthread = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-comment">//把一个求和任务分给nthread个线程做</span><br>  n = N / nthread;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>    <span class="hljs-built_in">create</span>(Tsum);<br>  &#125;<br>  <span class="hljs-built_in">join</span>();<br>  <span class="hljs-built_in">assert</span>(sum == n * nthread);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>​当线程数分别为1、2、4、32时：</p><p>​<img src="https://s2.loli.net/2023/11/05/8fJLWCQcyqnUzFV.png" alt=""></p><p>​奇怪的事情发生了！随着线程数增加，耗时不增反减，这映证了上面分析的自旋锁的缺陷</p><p>​<img src="https://s2.loli.net/2023/11/05/S1rluGZy9jEvkHV.png" alt=""></p><p>​那么自旋锁应该应用在哪些场景呢：临界区短、几乎不拥堵；持有自旋锁时禁止执行流切换</p><p>​具体场景如：<strong>操作系统内核的并发数据结构（短临界区）</strong></p><p>​在这个场景下，操作系统可以关闭中断和抢占，保证锁的持有者在很短的时间内可以释放锁</p><ol start="4"><li><p><strong>互斥锁（Mutex Lock）</strong></p><p>分析完上面自旋锁的缺陷后，一个自然而然的思路就是：其它线程无法进入临界区时，能不能让它们去做其它事，而不是搁那儿自旋干等呢？</p><p>这就是互斥锁的思想：<strong>用系统调用实现锁操作</strong></p> <img src="https://s2.loli.net/2023/11/05/QsaT1UKbN2Zwh9d.png" style="zoom:67%;" /></li></ol><p>​互斥锁和自旋锁比较：</p><p>​<img src="https://s2.loli.net/2023/11/05/zWYVJtZi5n1GACS.png" style="zoom:67%;" /></p><p>​</p><ol start="5"><li><p><strong>Take-away message</strong></p><ul><li>自旋锁 —— 软件不够，硬件来凑</li><li>互斥锁 —— 用户不够，内核来凑</li></ul><p>可见，解决问题的一个常用思路是<strong>找到你所依赖的假设，并大胆地打破它</strong>（解决提出问题的人）</p></li><li><p><strong>生产者-消费者的同步</strong></p><p><strong>motivation</strong>：单纯实现互斥是不够的，比如要两个线程按序打印左括号和右括号，那必须还要在某种程度上实现<strong>同步</strong></p></li></ol><p>​<img src="https://s2.loli.net/2023/11/05/8l6eP43abOmS7KI.png" style="zoom:67%;" /></p><p>​一个自然而然的思路对两个线程分别设置条件，不满足的时候自旋等待，满足则执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAN_PRODUCE (count &lt; n)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAN_CONSUME (count &gt; 0)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tproduce</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>retry:<br>    <span class="hljs-built_in">mutex_lock</span>(&amp;lk);<br>    <span class="hljs-keyword">if</span> (!CAN_PRODUCE) &#123;<br>      <span class="hljs-built_in">mutex_unlock</span>(&amp;lk);<br>      <span class="hljs-keyword">goto</span> retry;<br>    &#125;<br>    count++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>);  <span class="hljs-comment">// Push an element into buffer</span><br>    <span class="hljs-built_in">mutex_unlock</span>(&amp;lk);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tconsume</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>retry:<br>    <span class="hljs-built_in">mutex_lock</span>(&amp;lk);<br>    <span class="hljs-keyword">if</span> (!CAN_CONSUME) &#123;<br>      <span class="hljs-built_in">mutex_unlock</span>(&amp;lk);<br>      <span class="hljs-keyword">goto</span> retry;<br>    &#125;<br>    count--;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);  <span class="hljs-comment">// Pop an element from buffer</span><br>    <span class="hljs-built_in">mutex_unlock</span>(&amp;lk);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>💡 PS. 上述代码的一个细节是，条件不满足时我们必须释放锁 —— 如果不释放锁，其它生产者/消费者就无法继续工作，造成死锁</p>          </div><p>​</p><p>​这样确实能得到正确结果，但最大的问题就是一个线程执行时其它线程<strong>不断goto、retry，空耗cpu资源</strong></p><ol start="7"><li><p><strong>条件变量</strong></p><p>为了解决上述问题，我们理想中的同步API应该长这样：一个线程满足条件时执行，<strong>不满足则等待（线程wait不消耗cpu资源）</strong></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">wait_until</span>(CAN_PRODUCE) &#123;<br>  count++;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">wait_until</span>(CAN_CONSUME) &#123;<br>  count--;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​具体实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, count = <span class="hljs-number">0</span>;<br><span class="hljs-type">mutex_t</span> lk = <span class="hljs-built_in">MUTEX_INIT</span>();<br><span class="hljs-type">cond_t</span> cv = <span class="hljs-built_in">COND_INIT</span>();<br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAN_PRODUCE (count &lt; n)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAN_CONSUME (count &gt; 0)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tproduce</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">mutex_lock</span>(&amp;lk);<br>    <span class="hljs-keyword">while</span> (!CAN_PRODUCE) &#123;<br>      <span class="hljs-built_in">cond_wait</span>(&amp;cv, &amp;lk);<br>    &#125;<br>    <span class="hljs-built_in">assert</span>(CAN_PRODUCE);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>); count++;<br>    <span class="hljs-built_in">cond_broadcast</span>(&amp;cv);<br>    <span class="hljs-built_in">mutex_unlock</span>(&amp;lk);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tconsume</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">mutex_lock</span>(&amp;lk);<br>    <span class="hljs-keyword">while</span> (!CAN_CONSUME) &#123;<br>      <span class="hljs-built_in">cond_wait</span>(&amp;cv, &amp;lk);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>); count--;<br>    <span class="hljs-built_in">cond_broadcast</span>(&amp;cv);<br>    <span class="hljs-built_in">mutex_unlock</span>(&amp;lk);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​分析：</p><ul><li>执行Tproduce()时首先上锁，然后检验条件发现成立，于是执行临界区，结束后用broadcast唤醒所有睡眠中的线程，并释放锁；与此同时对于Tconsumer()来说，若不满足条件则进入睡眠等待状态，直至被其它线程唤醒</li><li>条件判断中使用 <strong>while(!CAN_PRODUCE)</strong> 而不是 if(!CAN_PRODUCE)，因为如果用 if 的话，被从睡眠中唤醒后直接进入后面的临界区，但事实上此时并不一定满足条件！从而造成”假唤醒“，括号打印错误</li><li>在调用 wait(cv, mutex) 之前必须保证已经获得mutex。wait会释放mutex并睡眠，被唤醒时wait又会重新试图获得互斥，直到获得互斥锁后才能返回</li></ul><p>​我们可以通过上述代码总结出用条件变量进行同步的通用模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">mutex_lock</span>(&amp;mutex);<br><span class="hljs-keyword">while</span> (!COND) &#123;<br>  <span class="hljs-built_in">wait</span>(&amp;cv, &amp;mutex);<br>&#125;<br><span class="hljs-built_in">assert</span>(cond);  <span class="hljs-comment">// 互斥锁保证条件成立</span><br><span class="hljs-comment">// critical_section</span><br><span class="hljs-built_in">broadcast</span>(&amp;cv);<br><span class="hljs-built_in">mutex_unlock</span>(&amp;mutex);<br></code></pre></td></tr></table></figure><ol start="8"><li><p><strong>信号量（semaphore）</strong></p><p>P —— 从袋子里取出一个球</p><p>V —— 放入一个球</p><p>球 —— 一个单位的资源</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">sem_t</span> fill, empty;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tproduce</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">P</span>(&amp;empty);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>);<br>    <span class="hljs-built_in">V</span>(&amp;fill);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tconsume</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">P</span>(&amp;fill);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);<br>    <span class="hljs-built_in">V</span>(&amp;empty);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(argc == <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">SEM_INIT</span>(&amp;fill, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">SEM_INIT</span>(&amp;empty, <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>    <span class="hljs-built_in">create</span>(Tproduce);<br>    <span class="hljs-built_in">create</span>(Tconsume);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="9"><li><p><strong>防御性编程</strong></p><p>狂加assert，不断检查、检查、检查</p></li></ol><h2 id="Lecture4、操作系统上的进程">Lecture4、操作系统上的进程</h2><ol><li><p><strong>fork()：做一份状态机完整的复制（内存、寄存器现场）</strong></p> <img src="https://s2.loli.net/2023/11/05/udMojUgswG3ZCX1.png" style="zoom:67%;" /></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">pid_t</span> pid1 = fork();<br>  <span class="hljs-type">pid_t</span> pid2 = fork();<br>  <span class="hljs-type">pid_t</span> pid3 = fork();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World from (%d, %d, %d)\n&quot;</span>, pid1, pid2, pid3);<br>&#125;<br></code></pre></td></tr></table></figure><p>​输出结果：</p><p>​<img src="https://s2.loli.net/2023/11/05/IhiZvNnyeSAgOks.png" alt=""></p><p>​理解：一生二，二生四，四生八</p><ol start="2"><li><strong>一段魔法代码</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>;i++)&#123;<br>fork();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​直接将结果输出到终端的时候，有6个hello</p><p>​<img src="https://s2.loli.net/2023/11/05/h34kPjpTFN72una.png" alt=""></p><p>​</p><p>​但输出到管道或者文件时，神奇的事情发生了，有8个hello</p><p>​<img src="https://s2.loli.net/2023/11/05/XcorbaZmEflyDwe.png" alt=""></p><p>​<strong>解释</strong>：</p><p>​“直接写到终端”与“写到管道或文件”两种情况下的<strong>缓冲策略是不一样的</strong>，前者遇见换行符就刷新，后者则会等缓冲区满才会刷新。 对于直接写到终端，fork之后有两个进程，printf输出两个hello到终端，再fork一次得4个进程，输出4个hello到终端； 而对于写到管道，fork之后有两个进程，printf在进程的buffer中各写入一个hello，再fork一次得4个进程（注意，这4个进程的buffer中都存了一个hello！），各进程再printf一次，则四个进程的buffer中都有两个hello，于是最后输出8</p><ol start="3"><li><p><strong>execve()：将当前运行的状态机重置为另一个程序的初始状态</strong></p> <img src="https://s2.loli.net/2023/11/05/2cUAxvhHIzCe3fE.png" style="zoom:67%;" /></li></ol><p>​</p><ol start="4"><li><p><strong>_exit()：立刻摧毁状态机</strong></p> <img src="https://s2.loli.net/2023/11/05/PCnf5Sjl7xATdRz.png" style="zoom:67%;" /></li></ol><h2 id="Lecture5、进程的地址空间">Lecture5、进程的地址空间</h2><ol><li><strong>定义</strong></li></ol><p>​<img src="https://s2.loli.net/2023/11/05/OG6tpPNZrFdEm7Y.png" style="zoom:67%;" /></p><ul><li>合法的地址<ul><li>代码 (main, %rip 会从此处取出待执行的指令)，只读</li><li>数据 (static int x)，读写</li><li>堆栈（int y），读写</li><li>运行时分配的内存（？？？），读写</li><li>动态链接库（？？？）</li></ul></li><li>非法的地址<ul><li>NULL，导致segmentation fault</li></ul></li></ul><ol start="2"><li><p><strong>查看进程的地址空间</strong></p><p>pmap：report memory of a process</p><p>用gdb查看当前执行的进程的进程号，再用pmap查看进程的地址空间</p><p><img src="https://s2.loli.net/2023/11/05/dKPwflzYX1BqoOL.png" alt=""></p></li></ol><p>​<img src="https://s2.loli.net/2023/11/05/L8nlSUbDyzViOK7.png" alt=""></p><p>​可见进程的地址空间是若干连续的”段“，”段“的内存可以访问，不在段内/违反权限的内存访问会触发SIGSEGV</p><ol start="3"><li><p><strong>vdso：virtual system calls</strong></p><p>linux中系统调用十分消耗CPU资源，因为syscall的本质是一种异常，当调用一个syscall时会触发 CPU 异常，CPU 进入异常处理流程。CPU 在异常处理流程中可以识别到本次异常是由于syscall引起的，从而进入syscall的异常处理流程中。</p><p>但如果一个syscall是只读的，那么它或许不必陷入内核执行</p><p>如linux中的gettimeofday()</p><p>大致实现原理：在每个进程的地址空间都映射一个vitural var的页面，这个页面是所有进程都共享的，下列都是无需进入内核就得获取的syscall</p></li></ol><p>​<img src="https://s2.loli.net/2023/11/05/kRstXP9Zzx2Yv6L.png" alt=""></p><ol start="4"><li><p><strong>管理进程地址空间的系统调用</strong></p> <img src="https://s2.loli.net/2023/11/05/Vr94ZQGeDzYptWl.png" style="zoom:67%;" /></li></ol><p>​一般来说，修改一个文件的内容需要如下3个步骤：</p><ul><li>把文件内容读入到内存中</li><li>修改内存中的内容。</li><li>把内存的数据写入到文件中</li></ul><p>​<img src="https://s2.loli.net/2023/11/05/ACMolNFirtJYLk6.png" alt=""></p><p>​可以看出，<strong>页缓存(page cache)</strong> 是读写文件时的中间层，内核使用页缓存与文件的数据块关联起来，所以应用程序读写文件时，实际操作的是页缓存。<br>​而mmap就是直接在用户空间读写，使用mmap系统调用可以将用户空间的虚拟内存地址与文件进行映射（绑定），对映射后的虚拟内存地址进行读写操作就如同对文件进行读写操作一样</p><p>​<img src="https://s2.loli.net/2023/11/05/xbsf1RqTUk56YQF.png" alt=""></p><ol start="5"><li><strong>地址空间的隔离</strong></li></ol><p>​<img src="https://s2.loli.net/2023/11/05/LNSsjBE1fqyPHWV.png" style="zoom:67%;" /></p><p>​进程的地址空间之间一般是相互隔离的，但有些应用也可以跨进程访问（如gdb，不然就没办法调试了，因为gdb自己就是个进程嘛）<br>​但也有一些hack方法可以修改进程的内存，如游戏外挂、代码注入（hooking）</p><h2 id="Lecture6、-系统调用和shell">Lecture6、 系统调用和shell</h2><ol><li><p><strong>motivation</strong>：用户不能够直接使用syscall，所以我们需要一个<strong>能把操作系统API封装起来</strong>的程序来帮助人类创建/管理进程、文件。。用户去和这个程序交互。</p><p>这个程序就是shell（内核kernel提供系统调用，shell提供用户接口）</p></li><li><p><strong>shell</strong></p><p>shell是一门**”把用户指令翻译为syscall“**的编程语言，可以把它理解为包裹kernel的一层外壳</p><ul><li>重定向：ls &gt; a.txt，将标准输出重定向到文件中</li><li>后台执行：ls &amp;，让程序或脚本切换到后台执行</li><li>逻辑执行：gcc test.c &amp;&amp; ./a.out ，当前一个命令成立时</li></ul></li><li><p><strong>gcc -static</strong></p><p>gcc 编译, 有个选项是-static, 其作用是决定 编译-链接时, 使用的库是静态库还是动态库</p><ul><li><p><strong>静态库（常以a为结尾, 例如libxx.a）</strong></p><p>在链接时**将需要的二进制代码都“拷贝”**到可执行文件中(注意, 只拷贝需要的,不会全部拷贝) 优点: 编译成功的可执行文件可以独立运行，而不再需要向外部要求读取函数库的内容； 缺点: 维护难, 每次更新, 都需要依赖方重新编译。另外, 依赖方因为拷贝了库的内容, 所以编译后的文件会比较大。</p></li><li><p><em><strong>*动态库(常以so为结尾, <a href="http://xn--libxx-4d3hh90d.so">例如libxx.so</a>):*</strong></em></p><p>链接时<strong>仅仅“拷贝”一些重定位和符号表信息</strong>，这些信息可以在程序运行时完成真正的链接过程。 优点: 维护容易, 只要对外接口不变, 则库可以不停的更新, 依赖方不需要再次编译; 缺点: 依赖方运行时需要所有依赖的so库都存在。</p></li></ul><p>综上：所以两者的本质区别是，该库是否被编译进目标（程序）内部</p></li></ol><h2 id="Lecture7、-C标准库的实现">Lecture7、 C标准库的实现</h2><ol><li><p><strong>零依赖（freestanding）环境</strong></p><ul><li><p>freestanding implementation：不能包含c标准库，只能包含基本的头文件</p>  <img src="https://s2.loli.net/2023/11/05/pyJ5sm7bltr1dcx.png" style="zoom:67%;" /></li><li><p>hosted implementation：能包含所有的c标准库</p></li><li><p>freestanding environment：在这种环境下编译的程序，不能包含完整的c标准库，甚至连main入口都没有，如kernal开发，c标准库开发</p></li><li><p>hosted environment：这种环境就是我们通常的编译环境，main作为入口，可以包含完整的c标准库</p></li></ul></li><li><p><strong>motivation</strong></p><p>c标准库是对系统调用的封装</p></li><li><p><strong>封装（1）：纯粹的计算</strong></p><ul><li><p>字符串/数组操作：string.h</p></li><li><p>排序和查找：</p>  <img src="https://s2.loli.net/2023/11/05/ldr8LEMzohPBN4q.png" style="zoom:67%;" /></li><li><p>math.h、stdlib.h、setjmp.h。。。</p></li></ul></li><li><p><strong>封装（2）：文件描述符</strong></p><p>linux中一切皆文件，当进程打开现有文件或者创建新文件时，kernel向进程返回一个<strong>文件描述符</strong>(file descriptor，fd)，它是一个非负整数值，指向被打开的文件，所有执行IO操作的syscall都会通过该fd</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// 以只读模式打开 demo.txt 文件</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;demo.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open demo.txt error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br>    <span class="hljs-comment">// 打印获取到的文件描述符</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;demo.txt fd = %d \n&quot;</span>, fd);<br>    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>​<img src="https://s2.loli.net/2023/11/05/1hgKdJORWnpyVvS.png" alt=""></p><p>​为什么是3呢？因为0 1 2 被占用了</p><p>​在UNIX系统中，系统创建的每个进程默认都会打开3个文件：标准输入（0）、标准输出（1）、标准错误（2）</p><p>​而这些整数的本质是什么呢 —— <strong>文件指针数组files的index</strong></p><p>​一般来说，一个进程会从files[0]中读取输入，将输出写入files[1]，将错误信息写入files[2]。比如printf向命令行打印字符，从进程的角度来看，就是向files[1]中写入数据；同理，scanf就是进程试图从files[0]这个文件中读取数据</p><p>​<img src="https://s2.loli.net/2023/11/05/BnRJODCh9UjMZbt.png" alt=""></p><p>​明白了上述原理后，输出输入重定向就很好理解了：输入重定向就是把files[0]指向一个文件，则程序会从这个文件中读取数据而不是键盘；输出重定向则是把files[1]指向一个文件，那么程序的输出就不会写到显示器而是写入这个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">command</span> &lt; file.txt</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">command</span> &gt; file.txt</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmd1 | cmd2 | cmd3</span><br></code></pre></td></tr></table></figure><p>​另外，管道符也可由此解释：把一个进程的输出流和另一个进程的输入流连接起来形成一条“管道”</p><p>​<img src="https://s2.loli.net/2023/11/05/3jEyXOZPMx5UIuA.png" alt=""></p><p>​到这里也可以看出「Linux 中一切皆文件」设计思路的高明了，不管是设备、另一个进程、socket套接字还是真正的文件，全部都可以读写，统一装进一个简单的<strong>files数组</strong>，进程通过简单的文件描述符访问相应资源，具体细节交给操作系统，有效解耦，优美高效。</p><div class="note note-warning">            <p>💡 PS. 每个进程维护一个struct_task结构体，里面有一个files数组，数组大小（或者说fd的最大值问题可参考<a href="https://senlinzhan.github.io/2017/07/01/linux-tuning/">这篇文章</a>）</p>          </div><ol start="5"><li><p><strong>封装（3）：地址空间</strong></p><p>malloc和free</p></li></ol><h2 id="Lecture8、可执行文件">Lecture8、可执行文件</h2><ol><li><p><strong>理解</strong></p><p>可执行文件的本质：<strong>一个描述了状态机的初始状态 + 迁移的数据结构</strong></p> <img src="https://s2.loli.net/2023/11/05/zfwv85SBgLR3EiG.png" style="zoom: 50%;" /></li></ol><p>​可执行文件是被execve()给调用的，把状态机重置为可执行文件的初始状态</p><p>​<img src="https://s2.loli.net/2023/11/05/naxRsQlX6BiJzKj.png" alt=""></p><ol start="2"><li><p><strong>chmod</strong></p><p>chmod +rwx file：给file的所有用户增加读写执行的权限</p></li><li><p><strong>编译链接</strong></p> <img src="https://s2.loli.net/2023/11/05/xpwnKZUXzgf3HPS.png" style="zoom: 50%;" /></li><li><p><strong>静态ELF加载器</strong></p><p>将磁盘上静态链接的可执行文件按照ELF program header，正确地搬运到内存中执行</p><p>操作系统在execve时完成：</p><ul><li>操作系统在内核态调用mmap<ul><li>进程还未准备好时，由内核直接执行 ”系统调用“</li><li>映射好 a.out 的代码、数据、堆区、堆栈、vvar、vdso、vsyscall</li></ul></li><li>更简单的实现：直接读入进程的地址空间</li></ul><p>加载完成之后，静态链接的程序就开始从ELF entry开始执行，之后就变成我们熟悉的状态机，唯一的行为就是取指执行</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">readelf -h a.out<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/05/kFcy8ALaUopSJgl.png" alt=""></p></li></ol><p>​我们这里看到，程序的入口地址是：<strong>Entry point address: 0x401be0</strong>。我们接着用gdb来调试：</p><p>​<img src="https://s2.loli.net/2023/11/05/pElB3V2yFunt9ZH.png" alt=""></p><p>​<img src="https://s2.loli.net/2023/11/05/pqjeC6RKyTPnYvB.png" alt=""></p><p>​我们用starti来使得程序在第一条指令就停下，可以看到：</p><ul><li>程序确实是从0x400180开始的，与我们上面查到的入口地址一致</li><li>而我们用cat /proc/[PID]/maps 来查看这个程序中内存的内容，看到我们之前提到的代码、数据、堆区、堆栈、vvar、vdso、vsyscall都已经被映射进了内存中。</li></ul><p>​调试的结果符合我们对静态程序加载时操作系统的行为的预期</p><h2 id="Lecture9、xv6简介、上下文切换">Lecture9、xv6简介、上下文切换</h2><ol><li><p>xv6简介：</p><ul><li><p>MIT6.S081课中的实验操作系统内核，posix标准，纯c，可运行在riscv上</p></li><li><p>接近完整的unix shell体验，具备基本工具集（wc、echo、cat。。）</p></li><li><p>命令执行、管道、重定向</p>  <img src="https://s2.loli.net/2023/11/05/YQ7MacIrKWCytxA.png" style="zoom:67%;" /></li></ul></li><li><p><strong>处理器的虚拟化</strong></p><p>一个问题：为什么死循环不能使计算机被彻底卡死？即使在执行一个永远while(1)的程序，也可以另开一个终端进行操作、也还能发送kill信号终止程序？</p> <img src="https://s2.loli.net/2023/11/05/9UCJBD4EqboluKk.png" style="zoom:50%;" /></li></ol><p>​<img src="https://s2.loli.net/2023/11/05/6KRHiQfXbPVUlej.png" style="zoom: 50%;" /></p><img src="https://s2.loli.net/2023/11/05/I7dorgOqaWUh2xl.png" style="zoom:50%;" /><ol start="3"><li><p><strong>上下文切换</strong></p><p>CPU总是能够支持远大于CPU数量的任务的经行，操作系统会“轮流”分配CPU供任务使用，这就要求CPU知道从哪里去加载任务以及从哪里开始或继续去加载任务，而这些信息都被保留在CPU的<strong>寄存器</strong>中，其中即将执行的下一条指令的地址被保存在<strong>程序计数器（PC）这一特殊的寄存器</strong>中，我们将寄存器的这些信息称为<strong>CPU的上下文</strong>，也称<strong>硬件上下文</strong></p><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li><p>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</p></li><li><p>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源</p><p><img src="https://s2.loli.net/2023/11/05/aZr2Gz5tR6IKydc.png" alt=""></p></li></ul></li></ol><p>​进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态</p><ol start="4"><li><p><strong>上下文切换与系统调用的关系</strong></p><p>从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成。</p><p>一次系统调用中的过程：</p><ul><li>保存 CPU 寄存器里原来用户态的指令位</li><li>为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置</li><li>跳转到内核态运行内核任务</li><li>当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程</li></ul><p>所以<strong>一次系统调用中发生了两次CPU上下文切换</strong>（用户态-内核态-用户态）</p></li></ol><h2 id="Lecture10、处理器调度">Lecture10、处理器调度</h2><ol><li><p><strong>motivation</strong>：上下文切换机制是在中断\系统调用时执行操作系统代码，操作系统实现所有状态机（进程）一视同仁的“封存”，从而可以恢复任意一个状态机（进程）的执行。而具体选择哪个进程执行，就是处理器调度策略问题。</p></li><li><p><strong>一些常见调度算法</strong></p><ul><li><p><strong>先来先服务算法(FCFS: First Come, First Served)</strong></p><p>​FCFS依据进程进入就绪状态的先后顺序排列，它简单、易于实现</p><p><img src="https://s2.loli.net/2023/11/05/J2R7IExVAhHcC8G.png" alt=""></p><p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统</p></li><li><p><strong>最短作业优先（Shortest Job First, SJF）</strong></p><p>会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量</p><p>​<img src="https://s2.loli.net/2023/11/05/SzIyVdDilM1396C.png" style="zoom:80%;" /></p><p>​这显然对长作业不利，很容易造成长作业等待过久的极端现象</p></li></ul></li><li><p><strong>时间片轮转算法（Round-Robin，RR）</strong></p><p><img src="https://s2.loli.net/2023/11/05/dbPD2hwGzBpvilj.png" alt=""></p></li></ol><p>​<strong>每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。</strong></p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li><li>·如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul><p>​另外，时间片的长度就是一个很关键的点：</p><ul><li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li><li>如果设得太长又可能引起对短作业进程的响应时间变长</li></ul><p>​通常时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值</p><p>​针对Round-Robin的一个改进策略：<strong>引入优先级（Linux中的nice）</strong></p><p>​用top查看进程优先级（NI那一列），为-19到20的整数，-19优先级最高，20最低（越坏、niceness越低，就越要去抢资源；越老好人就越会把资源让给别人）</p><p>​<img src="https://s2.loli.net/2023/11/05/mvWGJz8B4FxrSnA.png" alt=""></p><p>​完全基于优先级的调度策略在实时操作系统RTOS中应用较多，即容易把整个cpu资源给高优先级任务</p><p>​linux：nice相差10，cpu资源获取率相差10倍</p><p>​<img src="https://s2.loli.net/2023/11/05/gtfEmQxRusMO6aP.png" alt=""></p><p>​</p><p>​<strong>Round-Robin的一个问题</strong>：资源分配不均。如系统中有两个进程，一个是交互式的vim，单线程；另一个是32线程的计算进程，那么就会出现</p><ul><li>vim花0.1ms处理完输入就又等输入，马上主动让出cpu</li><li>计算进程使vim在有输入可以处理时被延迟，多线程长达数百ms的延迟导致卡顿</li></ul><ol start="4"><li><p><strong>策略：动态优先级，多级反馈队列(MLFQ: Multi Level Feedback Queues)</strong></p><p>顾名思义：</p><ul><li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li><li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列</li></ul></li></ol><p>​<img src="https://s2.loli.net/2023/11/05/W4Jr1Y6GZdQhzjH.png" style="zoom:80%;" /></p><p>​来看看，它是如何工作的：</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li><li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li></ul><p>​可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p><ol start="5"><li><p><strong>完全公平调度算法（CFS，Completely Fair Scheduler）</strong></p><p><strong>idea</strong>：取消时间片的概念，采用分配cpu使用时间的比例的方法。即两个优先级相同的进程在一个cpu上运行，则每个进程都将分配50%的cpu运行时间。而优先级不同时，优先级越高分配的权重就越多，占用cpu时长就越长</p><p><strong>分配给进程的时间 = 总的cpu时间 * 进程的权重/就绪队列（runqueue）所有进程权重之和</strong></p><p>CFS调度器中，nice值和权重之间可以互相转换，内核提供了一个array转换nice值和权重</p> <img src="https://s2.loli.net/2023/11/05/okdLWE3n2DsBSZg.png" style="zoom:67%;" /></li></ol><p>​如进程A的nice为-1，B的nice为0，则：<br>$$<br>CPU\ usage\ of\ A=CPU\ time * \frac{1277}{1277+1024}=0.55*CPU\ time<br>$$</p><p>$$<br>CPU\ usage\ of\ B=CPU\ time * \frac{1024}{1277+1024}=0.45*CPU\ time<br>$$</p><div class="note note-warning">            <p>💡 PS. 这也就是为啥说nice升高1，资源利用率大概差10%</p>          </div><p>​接下来，更重要的是引入<strong>虚拟时间</strong>（virtual time）的概念，其核心思想是：虽然每个进程实际分配到的cpu使用时间不一样，但我们可以将其转化为数值一样的虚拟时间，从而让操作系统觉得，“oh，酱紫是公平的，每个人的需求我都满足啦”<br>$$<br>virtual_runtime=real_time*\frac{1024}{weight}<br>$$<br>​假如调度周期为10ms</p><p>​则A的虚拟时间为$10ms*\frac{1277}{1277+1024}*\frac{1024}{1277}=4.45ms$</p><p>​B的虚拟时间为$10ms*\frac{1024}{1277+1024}*\frac{1024}{1024}=4.45ms$</p><p>​可见，通过简单的权重转换，就可以把所有进程的虚拟时间调成一致（尽管其实际运行时间不一样），在选择下一个即将运行的进程的时候，只需要找到虚拟时间最小的进程即可。</p><div class="note note-warning">            <p>💡 PS. CFS有一点“公平不是平分”的味道了，它既能做到按需分配（权重不同则cpu usage不同），又能通过虚拟时间做到表面上的“completely fair”，以便OS去尽量公正平均地去选择下一个执行的进程，很聪明的想法</p>          </div><ol start="6"><li><p><strong>优先级反转</strong></p><p>校长、系主任和jyy三人，校长想先sleep再拿锁，系主任一直死循环，jyy直接拿锁</p> <img src="https://s2.loli.net/2023/11/05/yi7ApogkNIh6enP.png" style="zoom:67%;" /></li></ol><p>​等校长休息好想拿锁的时候，诶，问题出现了，jyy在持有互斥锁的时候被赶出了处理器，中等优先级的系主任一直在占用cpu，jyy无法释放锁 —— 那么，此时校长由于拿不到锁，只能等待jyy，jyy又在等系主任，所以实际造成了高优先级的校长无法中断中优先级的系主任，即优先级反转</p><div class="note note-warning">            <p>💡 PS. 校长因为拿不到锁而等待jyy这件事是没问题的，因为这是OS层面的语义，优先级再高被抢占时都只能等待</p>          </div><h2 id="Lecture11、设备驱动原理与文件系统API">Lecture11、设备驱动原理与文件系统API</h2><ol><li><p><strong>I/O设备的抽象</strong></p><p>I/O设备的主要功能：<strong>输入和输出</strong></p><p>常见的设备（打印机、终端、硬盘）都满足这个模型</p><p>所以操作系统提供的三个最基本的syscal</p><ul><li>read - 从设备某个指定的位置读出数据</li><li>write - 向设备某个指定位置写入数据</li><li>ioctl - 读取/设置设备的状态</li></ul></li><li><p><strong>设备驱动程序</strong></p><p>把系统调用 (read/write/ioctl/…) “翻译” 成与设备寄存器的交互</p></li></ol><p>​<img src="https://s2.loli.net/2023/11/05/wxZBm8ADe2pIla6.png" style="zoom:80%;" /></p><p>​</p><ol start="3"><li><p><strong>文件系统介绍</strong></p><p><strong>motivation</strong>：设备在应用程序之间是需要共享的（多个进程并行打印，如何保证不混乱；每个CUDA应用程序都是一系列CUDA API的调用）；另外，像磁盘这样的设备需要支持数据的持久化，如果让所有应用共享磁盘的话，一个程序bug操作系统就没了，所以我们需要设计一个文件系统以满足：</p><ul><li>提供合理的API使多个应用程序能共享数据</li><li>提供一定的隔离，使bug的伤害不能任意扩大</li></ul></li></ol><p>​<strong>文件系统：虚拟磁盘</strong></p><ul><li>磁盘（I/O设备）=一个可以读写的字节序列</li><li>虚拟磁盘（文件）=一个可以读写的动态字节序列</li></ul><ol start="4"><li><p><strong>虚拟磁盘：命名管理</strong></p><p>为了找到想要的虚拟磁盘，最直接的一个思路就是利用信息的局部性，讲虚拟磁盘组织成层次结构</p></li></ol><p>​<img src="https://s2.loli.net/2023/11/05/kLZSEo5JsxOVnI2.png" alt="Untitled"></p><p>​</p><p>​文件系统的根：</p><ul><li>window：每个设备（驱动器）是一棵树</li></ul><p>​<img src="https://s2.loli.net/2023/11/05/XSchPK7egFGJnZW.png" style="zoom:67%;" /></p><ul><li>UNIX：只有一个根</li></ul><ol start="5"><li><p><strong>目录API（系统调用）</strong></p> <img src="https://s2.loli.net/2023/11/05/FUm43JsQMo9AO2z.png" style="zoom:67%;" /></li></ol>]]></content>
    
    
    <categories>
      
      <category>核心科技看美帝</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>X86</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于CPU SIMD和winograd的卷积计算加速技术</title>
    <link href="/2023/09/15/winograd%E5%8D%B7%E7%A7%AF%E5%8A%A0%E9%80%9F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/09/15/winograd%E5%8D%B7%E7%A7%AF%E5%8A%A0%E9%80%9F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><strong>参考：</strong></p><p><a href="https://no5-aaron-wu.github.io/2021/11/16/AI-Algorithm-4-Winograd/">AI算法基础：Winograd算法原理</a></p><p><a href="https://www.cnblogs.com/shine-lee/p/10906535.html">卷积神经网络中的Winograd快速卷积算法</a></p><h1></h1><h3 id="一、introduction">一、<strong>introduction</strong></h3><ol><li><p><strong>motivation</strong></p><p>网络训练耗时过大，卷积层是CNN前向推理计算的主要计算瓶颈。在广泛使用的CNN模型中，卷积层的运算量可占到95%以上。</p><p>​<img src="https://s2.loli.net/2023/09/18/STyFurcMlhY1Q84.png" alt=""></p></li><li><p><strong>直接卷积算法</strong></p></li></ol><p>​</p><p><img src="https://s2.loli.net/2023/09/18/4bX8cHxhOtZuDkQ.png" alt=""></p><p><img src="https://s2.loli.net/2023/09/18/WbAez5gHyElVTOu.png" alt=""></p><p>​为啥直接卷积算法容易拖慢性能呢？</p><ul><li>最内层的乘加语句（伪代码的第9行）无法向量化，因为无法在卷积核上连续读入一个向量寄存器长度的数据</li><li>会重复读数据，类似于递归计算斐波那契数列，缺乏记忆化过程</li></ul><h3 id="二、卷积加速算法">二、卷积加速算法</h3><ol><li><p><strong>介绍</strong></p><p>Winograd算法起源于1980年，作者Shmuel Winograd 在文章<a href="https://epubs.siam.org/doi/abs/10.1137/0209021">《On multiplication of polynomials modulo a polynomial》</a>中提出的减少FIR滤波器计算量的一个算法。他指出，对于输出个数为m，参数个数为r的FIR滤波器，不需要m×r次乘法计算，而只需要u(F(m,r))=m+r−1次乘法计算即可。<br>后来，有人发现此算法可以用来优化加速CNN网络的卷积计算<a href="https://arxiv.org/pdf/1509.09308.pdf">《Fast Algorithms for Convolutional Neural Networks》</a>，从此Winograd算法被广泛应用于各推理框架中。</p></li><li><p><strong>1D winograd算法</strong></p><p>以1维卷积$F(2, 3)$为例，输入信号$d=[d_0,d_1,d_2,d_3]^T$，卷积核$g=[g_0,g_1,g_2]^T$，那么卷积可以写成下列矩阵乘法形式：<br>$$<br>F(2,3)=\begin{bmatrix}d_0&amp;d_1&amp;d_2\\d_1&amp;d_2&amp;d_3\end{bmatrix}\begin{bmatrix}g_0\\g_1\\g_2\end{bmatrix}=\begin{bmatrix}r_0\\r_1\end{bmatrix}<br>$$<br>如果这个计算过程使用普通的矩阵乘法，一共需要 <strong>6 次乘法 + 4次加法</strong>：<br>$$<br>r_0=d_0<em>g_0+d_1</em>g_1+d_2*g_2<br>$$<br>但是，我们仔细观察一下，卷积运算中输入信号转换得到的矩阵不是任意矩阵，其有规律的分布着大量的重复元素，例如$d_1$和$d_2$。Winograd做了如下变换：</p><p>$$<br>F(2,3)=\begin{bmatrix}d_0&amp;d_1&amp;d_2\d_1&amp;d_2&amp;d_3\end{bmatrix}\begin{bmatrix}g_0\g_1\g_2\end{bmatrix}=\begin{bmatrix}m_1+m_2+m_3\m_2-m_3-m_4\end{bmatrix}<br>$$<br>其中，</p></li></ol><p>$$<br>m_1=(d_0-d_2)g_0,\quad m_2=(d_1+d_2)\frac{g_0+g_1+g_2}{2},\quad m_3=(d_2-d_1)\frac{g_0-g_1+g_2}{2},\quad m_4=(d_1-d_3)g_2<br>$$</p><p>​在CNN的推理阶段，卷积核上的元素是固定的，所以上式中和 g 相关的式子可以提前在模型初始化阶段算好，整个推理阶段只用计算一次，因此可以忽略。所以这里一共需要 <strong>4次乘法 + 8次加法</strong>。</p><p>​上面其实就是1D的Winograd算法，我们将上面的计算过程写成矩阵的形式如下：<br>$$<br>Y=A^T[(Gg)\odot(B^Td)]<br>$$<br>​其中，</p><ul><li><p>$\odot$表示element-wise multiplication（Hadamard product），即对应位置相乘操作；</p></li><li><p>$g$ 表示卷积核；</p></li><li><p>$d$ 表示输入特征图；</p></li><li><p>$G$ 表示卷积核变换矩阵，尺寸为$(u+k−1) × k$；</p></li><li><p>$B^T$ 表示输入变换矩阵，尺寸为$(u+k−1) × k$；</p></li><li><p>$A^T$ 表示输出变换矩阵，尺寸为$(u+k−1) × u$；</p></li><li><p>$u$ 表示输出尺寸，$k$表示卷积核尺寸，$su=(u+k−1)$表示输入尺寸</p><p>各矩阵具体值如下：</p></li></ul><p>$$<br>B^T=\begin{bmatrix}1&amp;0&amp;-1&amp;0\0&amp;1&amp;1&amp;0\0&amp;-1&amp;1&amp;0\0&amp;1&amp;0&amp;-1\end{bmatrix}<br>$$</p><p>$$<br>G=\begin{bmatrix}1&amp;0&amp;0\\frac12&amp;\frac12&amp;\frac12\\frac12&amp;-\frac12&amp;\frac12\0&amp;0&amp;1\end{bmatrix}<br>$$</p><p>$$<br>g=\begin{bmatrix}{g_{0}}&amp;{g_{1}}&amp;{g_{2}}\end{bmatrix}^{T}<br>$$</p><p>$$<br>d=\begin{bmatrix}d_0&amp;&amp;d_1&amp;&amp;d_2&amp;&amp;d_3\end{bmatrix}^T<br>$$</p><p>​$G, B^T, A^T$三个变换矩阵的推导原理及过程可以通过github工具<a href="https://github.com/andravin/wincnn">wincnn</a>计算：</p><p><img src="https://s2.loli.net/2023/09/18/AeutOlUp2kZTqQg.png" alt="计算F(2,3)的变换矩阵"></p><p><img src="https://s2.loli.net/2023/09/18/hPkeuWsfGYZUr4t.png" alt="计算F(4,3)的变换矩阵"></p><ol start="3"><li><p><strong>2D winograd算法</strong></p><p>将$F(2,3)$扩展到$F(2×2,3×3)$:</p> <img src="https://s2.ax1x.com/2019/05/22/VpBFc6.png" style="zoom:67%;" /></li></ol><p>​我们可以看到上面切分的每一块其实际就是1D的卷积操作，写成矩阵块形式：</p><img src="https://s2.ax1x.com/2019/05/22/VpDxY9.png" style="zoom:67%;" /><img src="https://s2.loli.net/2023/09/18/WgXk63bvhR1Mquy.png" style="zoom: 80%;" /><p>​上图中最后得到$M0…M3$的操作为4次矩阵加法以及4次矩阵乘法，由$M0…M3$得到$[R0,R1]^T$为4次矩阵加法，同样$W$矩阵的转换的计算量忽略不计。</p><ul><li>$K_{0…3}$之间的4次矩阵加法， 每次实际为4次加法（注意不要被上面扩展后的$K$矩阵划分的小方块中6个元素所迷惑，其中有重复的元素），共4×4=16次加法；</li><li>4次矩阵乘法可以转换为4次 <strong>1D Winograd</strong> 来计算，每次 <strong>1D Winograd</strong> 计算中有4次乘法，8次加法，共4×4=16次乘法，4×8=32次加法；</li><li>最后$M_0…M_3$之间的4次矩阵加法，由于$M$矩阵的尺寸为2×1，所以共4×2=8次加法；综上，$F(2×2,3×3)$的Winograd算法共 <strong>16次乘法和56次加法</strong>，如果使用常规卷积运算，则需要 <strong>36次乘法和32次加法</strong></li></ul><p>​上面的计算过程写成矩阵的形式如下:<br>$$<br>Y=A^T[[GgG^T]\odot[B^TdB]]A<br>$$</p><ol start="4"><li><p><strong>1D到2D的公式推导</strong></p> <div class="note note-warning">            <p>约定：大写字母或小写字母加上箭头均代表矩阵或向量，$K_0$与$\overrightarrow{d_0}$均表示输入矩阵的第一行，$W_0$与$\overrightarrow{k_0}$均表示卷积核的第一行</p><p>这里沿用2D Winograd推导中的字母表示，最后会转为1D Winograd推导中的字母表示</p>          </div></li></ol><p>​首先对上述公式进行重排，输出为2×2矩阵：<br>$$<br>[R_0,R_1]=[M_0+M_1+M2,M_1-M_2-M3]\=[M_0,M_1,M_2,M_3]\begin{bmatrix}1&amp;0\1&amp;1\1&amp;-1\0&amp;-1\end{bmatrix}=[M_0,M_1,M_2,M_3]A<br>$$<br>​结合上面计算代入$M_n$得下式：<br>$$<br>\begin{aligned}<br>&amp;[R_0,R_1]= \<br>&amp;\left[A^{T}[(GW_{0})\odot(B^{T}(K_{0}-K_{2}))],A^{T}[(G\frac{W_{0}+W_{1}+W_{2}}{2})\odot(B^{T}(K_{1}+K_{2}))],\right. \<br>&amp;A^{T}[(G\frac{W_{0}-W_{1}+W_{2}}{2})\odot(B^{T}(K_{2}-K_{1}))],A^{T}[(GW_{2})\odot(B^{T}(K_{1}-K_{3}))]\Biggr]A \<br>&amp;=A^T\bigg[[(GW_0)\odot(B^T(K_0-K_2))],[(G\frac{W_0+W_1+W_2}{2})\odot(B^T(K_1+K_2))], \<br>&amp;[(G\frac{W_0-W_1+W_2}2)\odot(B^T(K_2-K_1))],[(GW_2)\odot(B^T(K_1-K_3))]\Biggr]A<br>\end{aligned}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SIMD</tag>
      
      <tag>体系结构</tag>
      
      <tag>AI边缘计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于CPU SIMD和winograd的卷积计算加速技术</title>
    <link href="/2023/09/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%98%E5%8C%96%E7%BB%BC%E8%BF%B0/"/>
    <url>/2023/09/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%98%E5%8C%96%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>参考：</strong></p><p><a href="https://no5-aaron-wu.github.io/2021/11/16/AI-Algorithm-4-Winograd/">AI算法基础：Winograd算法原理</a></p><p><a href="https://www.cnblogs.com/shine-lee/p/10906535.html">卷积神经网络中的Winograd快速卷积算法</a></p><p><a href="https://www.cnblogs.com/nanmi/p/13607515.html">从TensorRT看INT8量化原理</a></p><p><a href="https://juejin.cn/post/7112354784622936077">MegEngine Inference 卷积优化之 Im2col 和 winograd 优化</a></p><h1></h1><h3 id="一、introduction">一、<strong>introduction</strong></h3><ol><li><p><strong>motivation</strong></p><p>网络训练耗时过大，卷积层是CNN前向推理计算的主要计算瓶颈。在广泛使用的CNN模型中，卷积层的运算量可占到95%以上。</p><p>​<img src="https://s2.loli.net/2023/09/18/STyFurcMlhY1Q84.png" alt=""></p></li><li><p><strong>直接卷积算法</strong></p></li></ol><p><img src="https://s2.loli.net/2023/09/18/4bX8cHxhOtZuDkQ.png" alt=""></p><p><img src="https://s2.loli.net/2023/09/18/WbAez5gHyElVTOu.png" alt=""></p><p>​为啥直接卷积算法容易拖慢性能呢？</p><ul><li>最内层的乘加语句（伪代码的第9行）无法向量化，因为无法在卷积核上连续读入一个向量寄存器长度的数据</li><li>会重复读数据，类似于递归计算斐波那契数列，缺乏记忆化过程</li></ul><h3 id="二、卷积加速算法">二、卷积加速算法</h3><ol><li><p><strong>介绍</strong></p><p>Winograd算法起源于1980年，作者Shmuel Winograd 在文章<a href="https://epubs.siam.org/doi/abs/10.1137/0209021">《On multiplication of polynomials modulo a polynomial》</a>中提出的减少FIR滤波器计算量的一个算法。他指出，对于输出个数为m，参数个数为r的FIR滤波器，不需要m×r次乘法计算，而只需要u(F(m,r))=m+r−1次乘法计算即可。<br>后来，有人发现此算法可以用来优化加速CNN网络的卷积计算<a href="https://arxiv.org/pdf/1509.09308.pdf">《Fast Algorithms for Convolutional Neural Networks》</a>，从此Winograd算法被广泛应用于各推理框架中。</p></li><li><p><strong>1D winograd算法</strong></p><p>以1维卷积$F(2, 3)$为例，输入信号$d=[d_0,d_1,d_2,d_3]^T$，卷积核$g=[g_0,g_1,g_2]^T$，那么卷积可以写成下列矩阵乘法形式：<br>$$<br>F(2,3)=\begin{bmatrix}d_0&amp;d_1&amp;d_2\d_1&amp;d_2&amp;d_3\end{bmatrix} \begin{bmatrix}g_0\g_1\g_2\end{bmatrix}=\begin{bmatrix}r_0\r_1\end{bmatrix}<br>$$<br>如果这个计算过程使用普通的矩阵乘法，一共需要 <strong>6 次乘法 + 4次加法</strong>：<br>$$<br>r_0=d_0<em>g_0+d_1</em>g_1+d_2*g_2<br>$$<br>但是，我们仔细观察一下，卷积运算中输入信号转换得到的矩阵不是任意矩阵，其有规律的分布着大量的重复元素，例如$d_1$和$d_2$。Winograd做了如下变换：</p><p>$$<br>F(2,3)=\begin{bmatrix}d_0&amp;d_1&amp;d_2\d_1&amp;d_2&amp;d_3\end{bmatrix}\begin{bmatrix}g_0\g_1\g_2\end{bmatrix}=\begin{bmatrix}m_1+m_2+m_3\m_2-m_3-m_4\end{bmatrix}<br>$$<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>其中，</p></li></ol><h1>$$<br>\begin{aligned}m_1&amp;=(d_0-d_2)g_0&amp;m_2=(d_1+d_2)\frac{g_0+g_1+g_2}{2}\m_4&amp;=(d_1-d_3)g_2&amp;m_3=(d_2-d_1)\frac{g_0-g_1+g_2}{2}\end{aligned}</h1><pre><code class="hljs">$$\alpha\left(k\right)\leq\alpha\left(s\right)\mathrm&#123;~for~all~&#125;k&gt;s\geq0.$$DGD算法本质上是将优化过程分成了两部分：一部分是consensus,即利用Weight matrix将连通节点的信息做一个沟通；另一部分就是传统的梯度下降，这里的梯度下降是针对每一个local节点。而DGD有一个显著的缺点：如果DGD当中的步长选择常数的话，那么会得到inexact convergence；而如果选择逐渐趋于零的步长(diminishing step size)，那么虽然可以得到exact convergence, 但是会造成较慢的收敛速度，这在实际应用当中是一个棘手的问题。<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% DGD仿真</span><br><br>num_nodes = <span class="hljs-number">5</span>;  <span class="hljs-comment">% 节点数量</span><br><br><span class="hljs-comment">% 有向图</span><br>adjacency_matrix_dir = [ <span class="hljs-number">1</span>  <span class="hljs-number">0</span> <span class="hljs-number">-1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>;<br>                        <span class="hljs-number">-1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">-1</span>;<br>                        <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>;<br>                         <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">-1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">0</span>;<br>                         <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">-1</span>  <span class="hljs-number">1</span>];  <br><br><span class="hljs-comment">% 无向图</span><br>adjacency_matrix_undir = [ <span class="hljs-number">2</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>;<br>                          <span class="hljs-number">-1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">-1</span>;<br>                          <span class="hljs-number">-1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">2</span> <span class="hljs-number">-1</span>  <span class="hljs-number">0</span>;<br>                           <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">-1</span>  <span class="hljs-number">2</span> <span class="hljs-number">-1</span>;<br>                           <span class="hljs-number">0</span> <span class="hljs-number">-1</span>  <span class="hljs-number">0</span> <span class="hljs-number">-1</span>  <span class="hljs-number">2</span>];  <br><br><br><span class="hljs-comment">% 初始化节点参数和本地梯度</span><br><span class="hljs-comment">%node_params = rand(num_nodes, 1);  % 初始参数</span><br>node_params = [<span class="hljs-number">0.1</span> <span class="hljs-number">0.2</span> <span class="hljs-number">0.3</span> <span class="hljs-number">0.4</span> <span class="hljs-number">0.5</span>]&#x27;;<br>local_gradients = <span class="hljs-built_in">zeros</span>(num_nodes, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">% 设置全局目标函数（示例中为简单的平方和）</span><br>global_objective = @(x) sum(x.^<span class="hljs-number">2</span>);<br><br>num_iterations = <span class="hljs-number">1000</span>;<br>learning_rate = <span class="hljs-number">0.01</span>;<br><br><span class="hljs-comment">% 创建用于存储可视化数据的数组</span><br>param_history = <span class="hljs-built_in">zeros</span>(num_iterations, num_nodes);<br><br><br><span class="hljs-keyword">for</span> iteration = <span class="hljs-number">1</span>:num_iterations<br>    <span class="hljs-keyword">for</span> node = <span class="hljs-number">1</span>:num_nodes<br>        local_gradients(node) = <span class="hljs-number">2</span> * node_params(node);<br>        <br>        <span class="hljs-comment">% 与邻居节点共享梯度信息并更新参数</span><br>        <span class="hljs-keyword">for</span> neighbor = <span class="hljs-number">1</span>:num_nodes<br>            <span class="hljs-keyword">if</span> adjacency_matrix_dir(node, neighbor) == <span class="hljs-number">-1</span><br>                node_params(node) = node_params(node) - learning_rate * (node_params(node) - node_params(neighbor));<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>        <br>        <span class="hljs-comment">% 存储参数历史</span><br>        param_history(iteration, :) = node_params;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">% 输出最终的全局最优解</span><br>global_minimizer = node_params;<br>global_minimum = global_objective(global_minimizer);<br>fprintf(<span class="hljs-string">&#x27;全局最优解：&#x27;</span>);<br><span class="hljs-built_in">disp</span>(global_minimizer);<br>fprintf(<span class="hljs-string">&#x27;全局最小值：%f\n&#x27;</span>, global_minimum);<br><br><span class="hljs-comment">% 可视化节点参数随时间的变化</span><br><span class="hljs-built_in">figure</span>;<br><span class="hljs-built_in">hold</span> on;<br><span class="hljs-keyword">for</span> node = <span class="hljs-number">1</span>:num_nodes<br>    <span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:num_iterations, param_history(:, node), <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;DisplayName&#x27;</span>, sprintf(<span class="hljs-string">&#x27;节点 %d&#x27;</span>, node));<br><span class="hljs-keyword">end</span><br>xlabel(<span class="hljs-string">&#x27;迭代次数&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;节点参数&#x27;</span>);<br>title(<span class="hljs-string">&#x27;节点参数随时间的变化&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;Location&#x27;</span>, <span class="hljs-string">&#x27;Best&#x27;</span>);<br>grid on;<br><span class="hljs-built_in">hold</span> off;<br><br></code></pre></td></tr></table></figure>仿真结果：![无向图](https://s2.loli.net/2023/09/11/unY1li45ovgDGUR.png)</code></pre><p>​无需太多解释，为无向图完全连通时，最终各节点值趋于平均值，即经典的consensus</p><p>​<img src="https://s2.loli.net/2023/09/11/ST9zrA3w4no6muy.png" alt="有向图"></p><p>​为有向图时，因为不是各节点之间都还能“均匀地”通信，所以结果也不再是全局平均</p><div class="note note-warning">            <p>💡 PS. 只要能够收敛，各节点最终的收敛值就与目标函数无关哈（跟全局和局部目标函数都无关，全局只是局部之和而已），只与通信拓扑有关。因为从迭代过程中就可以发现，只有梯度和目标函数有关，但梯度只影响迭代速率（或者说顶多导致震荡，无法收敛到精确值），不影响收敛终值</p>          </div><ol start="2"><li><strong>固定步长（fixed step-sizes）</strong></li></ol><p>​<strong>EXTRA: Exact first-order algorithm</strong></p><p>​第一步：<br>$$<br>x_i(1)=\sum_{j=1}^Nw_{ij}x_j(0)-\alpha\nabla f_i(x_i(0)),<br>$$<br>​其中$$\alpha&gt;0$$是固定步长</p><p>​第二步：<br>$$<br>\begin{aligned}x_i(k+2)&amp;=x_i(k+1)+\sum_{j=1}^Nw_{ij}x_j(k+1)-\sum_{j=1}^N\tilde{w}_{ij}x_j(k)-\alpha\left(\nabla f_i(x_i(k+1))-\nabla f_i(x_i(k))\right),\mathrm{~}k=0,\mathrm{~}1,\ldots,\end{aligned}<br>$$<br>​相较于DGD算法，EXTRA用到了前两步的梯度信息，文献表明，<strong>EXTRA可以看作是具有误差校正项的DGD</strong></p><p>​<strong>DIGing： distributed inexact gradient method and the gradient tracking</strong><br>$$<br>x_i(k+1) =\sum_{j=1}^Nw_{ij}x_j(k)-\alpha y_i(k),<br>$$</p><p>$$<br>y_{i}(k+1) =\sum_{i=1}^Nw_{ij}y_j(k)+\nabla f_i(x_i(k+1))-\nabla f_i(x_i(k)),</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>parent of 3a82f4f (Update <a href="http://xn--4oq34emxav33akibfx0i91ya.md">分布式优化综述.md</a>)<br>$$</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>​在CNN的推理阶段，卷积核上的元素是固定的，所以上式中和 g 相关的式子可以提前在模型初始化阶段算好，整个推理阶段只用计算一次，因此可以忽略。所以这里一共需要 <strong>4次乘法 + 8次加法</strong>。</p><h1>​上面其实就是1D的Winograd算法，我们将上面的计算过程写成矩阵的形式：<br>$$<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>Y=A^T[(Gg)\odot(B^Td)]</h1><p>x_i(k+1) =x_i(k)-v_i(k)-\alpha\nabla f_i(x_i(k))-\beta\sum_{j\in\mathcal{N}<em>i}a</em>{ij}(x_i(k)-x_j(k)),</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>parent of 3a82f4f (Update <a href="http://xn--4oq34emxav33akibfx0i91ya.md">分布式优化综述.md</a>)<br>$$<br>​其中，</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p><ul><li>$\odot$表示element-wise multiplication（Hadamard product），即对应位置相乘操作；<br>=======<br>$$<br>\nu_i(k+1) =v_i(k)+\alpha\beta\sum_{j\in\mathcal{N}<em>i}a</em>{ij}(x_i(k)-x_j(k)),<br>$$</li></ul><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>parent of 3a82f4f (Update <a href="http://xn--4oq34emxav33akibfx0i91ya.md">分布式优化综述.md</a>)</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><ul><li><p>$g$ 表示卷积核；</p></li><li><p>$d$ 表示输入特征图；</p></li><li><p>$G$ 表示卷积核变换矩阵，尺寸为$(u+k−1) × k$；</p></li><li><p>$B^T$ 表示输入变换矩阵，尺寸为$(u+k−1) × k$；</p></li></ul><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p><ul><li><p>$A^T$ 表示输出变换矩阵，尺寸为$(u+k−1) × u$；</p></li><li><p>$u$ 表示输出尺寸，$k$表示卷积核尺寸，$su=(u+k−1)$表示输入尺寸</p></li></ul><p>=======<br>​<strong>Distributed PI algorithm</strong><br>$$<br>\dot{x}<em>i(t) =\sum</em>{j=1}^Na_{ij}(x_j(t)-x_i(t))+\sum_{j=1}^Na_{ij}(\nu_j(t)-\nu_i(t))-\nabla f_i(x_i(t)),<br>$$</p><p>$$<br>\dot{\nu}<em>i(t) =\sum</em>{j=1}^Na_{ij}(x_i(t)-x_j(t)),<br>$$</p><ol start="2"><li><p><strong>二阶梯度算法</strong></p><p><strong>Zero-Gradient-Sum Algorithm</strong><br>$$<br>\dot{x}<em>i(t)=\gamma\left(\nabla^2f_i(x_i(t))\right)^{-1}\sum</em>{j\in\mathcal{N}<em>i}a</em>{ij}(x_j(t)-x_i(t)),<br>$$</p></li></ol><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>parent of 3a82f4f (Update <a href="http://xn--4oq34emxav33akibfx0i91ya.md">分布式优化综述.md</a>)</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre><code class="hljs"> 各矩阵具体值如下：</code></pre><p>$$<br>B^T=\begin{bmatrix}1&amp;0&amp;-1&amp;0\0&amp;1&amp;1&amp;0\0&amp;-1&amp;1&amp;0\0&amp;1&amp;0&amp;-1\end{bmatrix}<br>$$</p><p>$$<br>G=\begin{bmatrix}1&amp;0&amp;0\\frac12&amp;\frac12&amp;\frac12\\frac12&amp;-\frac12&amp;\frac12\0&amp;0&amp;1\end{bmatrix}<br>$$</p><p>$$<br>g=\begin{bmatrix}{g_{0}}&amp;{g_{1}}&amp;{g_{2}}\end{bmatrix}^{T}<br>$$</p><p>$$<br>d=\begin{bmatrix}d_0&amp;&amp;d_1&amp;&amp;d_2&amp;&amp;d_3\end{bmatrix}^T<br>$$</p><p>​$G, B^T, A^T$三个变换矩阵的推导原理及过程可以通过github工具<a href="https://github.com/andravin/wincnn">wincnn</a>计算：</p><p><img src="https://s2.loli.net/2023/09/18/AeutOlUp2kZTqQg.png" alt="计算F(2,3)的变换矩阵"></p><p><img src="https://s2.loli.net/2023/09/18/hPkeuWsfGYZUr4t.png" alt="计算F(4,3)的变换矩阵"></p><ol start="3"><li><p><strong>关于乘法和加法的计算量讨论</strong></p><p>为啥从经典卷积的6次乘法 + 4次加法，到winograd的4次乘法 + 8次加法就认为是耗时更少捏？</p><p>下面是一个经典的二进制全加器，输入A和B以及进位Cin，输出Sum和进位输出Co</p><p><img src="https://s2.loli.net/2023/09/19/rbI1T2WBDkCsE5O.png" alt="二进制全加器"></p><p>而实现乘法常用的方法是类似于手工计算乘法的方式：</p></li></ol><p>​<img src="https://s2.loli.net/2023/09/19/FpZUAQt4Wm6kJKh.png" alt=""></p><p>​对应的硬件结构就是阵列乘法器，计算思路是生成部分积，累加部分积和最终相加</p><p>​<img src="https://s2.loli.net/2023/09/19/JAehzRkBIYyFKCq.png" alt="阵列乘法器"></p><p>​可见乘法器无论是元件面积还是计算耗时都大于加法器</p><p>​<strong>但是，上述经典理解适用于现代代码优化吗？</strong></p><p>​对于下面这样一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sum;<br>    sum = <span class="hljs-number">10</span>;<br>    sum *= <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>​使用gcc -S -masm=intel得到汇编语句：</p><p>​<img src="https://s2.loli.net/2023/09/19/Q4O2SejG36Bwv79.png" alt=""></p><p>​可以看到，sum*=3被拆成了1条mov和两条add，没有用乘法</p><p>​如果是sum*=2的话，则为：</p><p>​<img src="https://s2.loli.net/2023/09/19/QH3tJEMeopzyZ8B.png" alt=""></p><p>​这下连add都省了，直接sal算术左移一位，即sum&lt;&lt;=1</p><p>​上述情况还都只是-O0编译优化，如果我们开到-O3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>        sum += <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/19/OQZjfstRBLKE2uS.png" alt=""></p><p>非常有意思，循环直接被优化掉了</p><p>另外，在现代cpu的分支预测、SIMD向量运算的作用下，数值计算的耗时绝不仅仅是“乘法比加法慢”这么简单，这给我们的启发是，<strong>只要写出可读性足够好的代码就行，不要自作聪明地去人为优化，编译器会帮你做好这件事的，premature optimization is the root of evil</strong></p><ol start="4"><li><strong>2D winograd算法</strong></li></ol><p>将$F(2,3)$扩展到$F(2×2,3×3)$:</p>  <img src="https://s2.ax1x.com/2019/05/22/VpBFc6.png" style="zoom:67%;" /><p>​我们可以看到上面切分的每一块其实际就是1D的卷积操作，写成矩阵块形式：</p><img src="https://s2.ax1x.com/2019/05/22/VpDxY9.png" style="zoom:67%;" /><img src="https://s2.loli.net/2023/09/18/WgXk63bvhR1Mquy.png" style="zoom: 80%;" /><p>​上图中最后得到$M_0…M_3$的操作为4次矩阵加法以及4次矩阵乘法，由$M_0…M_3$得到$[R0,R1]^T$为4次矩阵加法，同样$W$矩阵的转换的计算量忽略不计。</p><ul><li>$K_{0…3}$之间的4次矩阵加法， 每次实际为4次加法（注意不要被上面扩展后的$K$矩阵划分的小方块中6个元素所迷惑，其中有重复的元素），共4×4=16次加法；</li><li>4次矩阵乘法可以转换为4次 <strong>1D Winograd</strong> 来计算，每次 <strong>1D Winograd</strong> 计算中有4次乘法，8次加法，共4×4=16次乘法，4×8=32次加法；</li><li>最后$M_0…M_3$之间的4次矩阵加法，由于$M$矩阵的尺寸为2×1，所以共4×2=8次加法；综上，$F(2×2,3×3)$的Winograd算法共 <strong>16次乘法和56次加法</strong>，如果使用常规卷积运算，则需要 <strong>36次乘法和32次加法</strong></li></ul><p>​上面的计算过程写成矩阵的形式如下:<br>$$<br>Y=A^T[[GgG^T]\odot[B^TdB]]A<br>$$</p><ol start="5"><li><p><strong>1D到2D的公式推导</strong></p> <div class="note note-warning">            <p>约定：大写字母或小写字母加上箭头均代表矩阵或向量，$K_0$与$\overrightarrow{d_0}$均表示输入矩阵的第一行，$W_0$与$\overrightarrow{k_0}$均表示卷积核的第一行</p><p>这里沿用2D Winograd推导中的字母表示，最后会转为1D Winograd推导中的字母表示</p>          </div></li></ol><p>​首先对上述公式进行重排，输出为2×2矩阵：<br>$$<br>[R_0,R_1]=[M_0+M_1+M_2,M_1-M_2-M_3]\=[M_0,M_1,M_2,M_3]\begin{bmatrix}1&amp;0\1&amp;1\1&amp;-1\0&amp;-1\end{bmatrix}=[M_0,M_1,M_2,M_3]A<br>$$<br>​结合上面计算代入$M_n$得下式：<br>$$<br>\begin{aligned}<br>&amp;[R_0,R_1]= \<br>&amp;\left[A^{T}[(GW_{0})\odot(B^{T}(K_{0}-K_{2}))],A^{T}[(G\frac{W_{0}+W_{1}+W_{2}}{2})\odot(B^{T}(K_{1}+K_{2}))],\right. \<br>&amp;A^{T}[(G\frac{W_{0}-W_{1}+W_{2}}{2})\odot(B^{T}(K_{2}-K_{1}))],A^{T}[(GW_{2})\odot(B^{T}(K_{1}-K_{3}))]\Biggr]A \<br>&amp;=A^T\bigg[[(GW_0)\odot(B^T(K_0-K_2))],[(G\frac{W_0+W_1+W_2}{2})\odot(B^T(K_1+K_2))], \<br>&amp;[(G\frac{W_0-W_1+W_2}2)\odot(B^T(K_2-K_1))],[(GW_2)\odot(B^T(K_1-K_3))]\Biggr]A<br>\end{aligned}<br>$$<br>​由于hadamard product（$\odot$）和concat（,）操作可以交换而不影响结果，因此：<br>$$<br>\begin{aligned}<br>&amp;[R_0,R_1]= \<br>&amp;A^T\bigg[(G[W_0,\frac{W_0+W_1+W_2}{2},\frac{W_0-W_1+W_2}{2},W_2])\odot\big(B^T[K_0-K_2,K_1+K_2,K_2-K_1,K_1-K_3]\big)\bigg]A \<br>&amp;=A^T\bigg[(G[W_0,W_1,W_2]\begin{bmatrix}1&amp;\frac{1}{2}&amp;\frac{1}{2}&amp;0\0&amp;\frac{1}{2}&amp;-\frac{1}{2}&amp;0\0&amp;\frac{1}{2}&amp;\frac{1}{2}&amp;1\end{bmatrix})\odot(B^T[K_0,K_1,K_2,K_3]\begin{bmatrix}1&amp;0&amp;0&amp;0\0&amp;1&amp;-1&amp;1\-1&amp;1&amp;1&amp;0\0&amp;0&amp;0&amp;-1\end{bmatrix})\bigg]A \<br>&amp;=A^T\bigg[(G[\overrightarrow{k_0},\overrightarrow{k_1},\overrightarrow{k_2}]G^T)\odot(B^T[\overrightarrow{d_0},\overrightarrow{d_1},\overrightarrow{d_2},\overrightarrow{d_3}]B)\bigg]A \<br>&amp;=A^T[(GKG^T)\odot(B^TDB)]A<br>\end{aligned}<br>$$</p><ol start="6"><li><p><strong>总结</strong></p><p>Winograd算法可以分为4个步骤：</p></li></ol><ul><li><ol><li>初始化期间完成卷积核的变换<code>weightTransform</code>，即：$GKG^T$</li></ol></li><li><ol start="2"><li>运行期间完成输入数据的变换<code>sourceTransform</code>，即：$B^TDB$</li></ol></li><li><ol start="3"><li>运行期间完成输入数据与权重的<code>MatMul</code>，即：$(GKG^T)\odot(B^TDB)$</li></ol></li><li><ol start="4"><li>运行期间完成输出数据的变换<code>dstTransform</code>，即：$A^T[(GKG^T)\odot(B^TDB)]A$</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SIMD</tag>
      
      <tag>体系结构</tag>
      
      <tag>AI边缘计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>港澳深小记</title>
    <link href="/2023/08/11/%E6%B8%AF%E6%BE%B3%E6%B7%B1%E5%B0%8F%E8%AE%B0/"/>
    <url>/2023/08/11/%E6%B8%AF%E6%BE%B3%E6%B7%B1%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>DAY -1（8.4，8.5）：个人原因先去了趟珠海和广州</h1><p><strong>珠海</strong>： 长隆海洋王国，门票巨贵（成人普票450，哥们这辈子见过的最贵的国内游乐场），人巨多（没有一个游乐项目排队低于1h的），项目较无聊（普通游乐场项目 + 海洋生物馆），唯一略值票价的就是晚上八点半的烟花秀+无人机表演，今生不可能再去第二次，不过幸好妹妹玩得很开心，那也行叭。</p><p><img src="https://s2.loli.net/2023/08/19/INDUbPTQw5xCKtE.jpg" alt="开心的妹妹和蛋仔派对小黑蛋~"></p><p>另外印象深刻的是小姨夫和他的资深钓鱼友自制的豪华生鱼片刺身，虽然山猪吃不来细糠，味道不敢恭维，但确实符合我对老广深夜大排档的想象。</p><p><img src="https://s2.loli.net/2023/08/19/TF46A2L9w8oJRmv.jpg" alt=""></p><p><strong>广州：</strong> 去了前微信园区总部（一个非常不起眼的工业园区，现已搬迁至琶洲新大楼）和广州塔，乏善可陈，中规中矩，晚饭粤菜馆子的白斩鸡不错</p><p><strong>珠海广州整体评价</strong>： ⭐⭐⭐</p><h1>DAY0（8.6）：深圳落脚</h1><p>第一站是深圳大学城 —— 同时汇聚清华深圳研究院、北大深圳研究院、哈工深三所名校，阵容豪华，但更豪华的是校园环境：蓝得透彻得如动漫一般的天空、偶有椰树矗立在路边、风格现代化的精致教学大楼，道路宽敞、校园整洁、无一家华科绝望坡路边小店之类的商家，像极了youtube里见到的美国大学景象。平心而论，来这儿之前，我井底之蛙地认为全大陆的高校都和华科武大之流大差不差，从未设想国内校园也能有如此精致优雅之景。</p><p><img src="https://s2.loli.net/2023/08/19/8FACdUKZRfwemoP.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/ZKUDzVB4pRIvA68.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/zWHuGy9Mwn4Ooms.jpg" alt="北大汇丰商学院"></p><p><img src="https://s2.loli.net/2023/08/19/mpECJqxtPMKQh4s.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/lTi9c2woW1eg8ma.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/nboUWrmgdtBGYIw.jpg" alt=""></p><p>这是汇丰商学院的教师墙，还有鸣人教授和柯南教授hh，放在华科自动化绝对是大逆不道行为，可能这和北大的、深圳的、广东的自由包容而发达的气息是相通的吧，我爱北大。</p><p>整体评价：⭐⭐⭐⭐⭐</p><h1>DAY1（8.7）：hk中心老街区 + 维多利亚港</h1><p>早上8点经深圳福田口岸过关，40min地铁到达第一站：旺角华星冰室。</p><p>上来便是一记下马威，40来岁的中年老板娘约莫是接待过无数大陆游客了，在第一句“你哋食乜啊？”而我们毫无反应后，瞬间由热情招待状态切换为例行公事状态，三下五除二<strong>抢着</strong>帮我们点了销量最高的、40$一份的“公仔面套餐”，呈上来一行五人直接傻眼，来hk就给哥们吃方便面是吧😡😡</p><p><img src="https://s2.loli.net/2023/08/19/faSwFpkQNBUxq7C.png" alt="如上图，当然，没有鸡翅"></p><p>接下来几天，我们便以“一面”作为价格计量单位，譬如711一瓶矿泉水是1/4面，在潮汕吃了人均2.5面的牛肉。</p><p>后续一路经典路线扫街，亚皆老街 – 钵兰街（才知道这个古惑仔圣地是Portland street的音译）-- 油麻地 – 尖沙咀</p><p><img src="https://s2.loli.net/2023/08/19/S9emHv7xycCPMiN.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/vlLqJHtVrWpF276.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/wTiupgIJmhx1oPF.jpg" alt="夹个私货，bang bang bang！"></p><p>中途印象较深之事是小红书推荐的“澳洲牛奶公司”顾客爆满，于是另寻旁边一家糖水铺，老板娘同样是四五十来岁的不会普通话的hk大妈一枚鸭~，比冰室老板娘更离谱的是她似乎真的完全不会普通话（甚至听不懂），索性放弃，直接英语交流，幸好人家“pay the bill”还是听得懂。</p><p>下午坐天星小轮过海去了香港南，和北部经典街区真的天差地别两种景象：铺天盖地的摩天大厦、光滑反光的大楼落地外窗、面积堪比学校食堂的dior、gucci奢侈品独立专卖店、数不清的金融证券公司、来来往往的清一色衬衫西裤皮鞋金融男和半裙平底单鞋金融女，上一次见到这样的景象还是朋友圈发的洛杉矶西海岸大都市，hk这番国际大都市景象真的在国内其它任何一个地方都见不着，繁荣、干净、现代、蓝天，又充满压迫、焦虑、精英和消费，北京上海深圳都没这番感觉。</p><p><img src="https://s2.loli.net/2023/08/19/YRmVJTdfneMyxoL.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/SyoZvdMX3J9Uctz.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/hERTU6Yf9qBD85l.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/CkrtziGwmExBXen.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/EjnoSuYgQO3fV1y.jpg" alt=""></p><p>晚上经典维多利亚港 + 星光大道，这倒是中规中矩的夜晚海岸城市景象，并没有比武汉江滩更好看；反而给我印象更深的是K11商场里众多问所未闻的轻奢重奢店和来来往往的西装金融男女，非常之international哈</p><p><img src="https://s2.loli.net/2023/08/19/L5Bym4XFjzuMbro.jpg" alt=""></p><h1>DAY2（8.8）：中环上环CBD + 香港大学</h1><p>上午西九文化区+中环上环金融区CBD —— 清一色的证券银行贸易写字大楼，以及价值两面的一碗吉野家盖饭</p><p><img src="D:/files-qlh/photography_qlh/hk%E6%97%85%E8%A1%8C/jpg/IMG_20230807_153424.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/9KMi5yZxJ6ThPEA.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/am5odq64MD39uYA.jpg" alt=""></p><p>下午的港大之行倒是印象深刻 —— 首先，港大地铁站直通教学楼二楼，出门就是人家的实验室这件事就令我难以置信，好的大学真没有围墙，也不知道某些武汉珞喻路高校围成个监狱图啥，怕游客把你实验室那点b技术偷了去拿诺奖是吧😪另外，港大建筑风格也和某校方方正正的平头房大为迥乎 —— 古老、优雅、紧致而又静谧，来生要做港大人😭</p><p><img src="https://s2.loli.net/2023/08/19/S6iQeHjg3Mhw42V.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/eOos8wEu2pH1YqM.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/yRb3mJ8Ks6YGxVo.jpg" alt=""></p><p>原计划的太平山顶倒是没去，人太多，于是在一旁的香港公园里转了转，真美啊，再多看一眼吧。</p><p><img src="https://s2.loli.net/2023/08/19/ZrG7xjl9RsmTcW3.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/rNj8cUB1WxAmZ2E.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/InjPzaMHcCWYrbs.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/pYinoWBr18TZuE4.jpg" alt="好像GTA5里的圣莫妮卡海滩啊"></p><p>hk整体评价：⭐⭐⭐⭐⭐</p><h1>DAY3（8.9）：澳门一日游</h1><p>早上深圳机场码头 —— 珠海横琴码头，横琴口岸过关，11点到澳门</p><p>澳门相对来说没那么夸张，和真正的metropolitan hk比起来，更像是一个风格相当独特的国内旅行度假村：普通话更普及、对游客更热情友好、景点资源更丰富；当然，也还是有诸多大陆见不到的景象，赌场菠菜业、均价3000一晚的酒店、内陆不敢想象的福利待遇。。</p><p><img src="https://s2.loli.net/2023/08/19/OcHVinJUa3jQFXo.jpg" alt="巴黎人仿制巴黎铁塔"></p><p><img src="https://s2.loli.net/2023/08/19/LuxtOQ6mnHSaCXI.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/PtiErDU3LTyoHRW.jpg" alt="著名官也街"></p><p><img src="https://s2.loli.net/2023/08/19/jzuQ3J4TxhCvPcr.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/08/19/DVHly9K6YBL1qcw.jpg" alt="永利皇宫"></p><p>最有意思当然是新葡京啦！非常颠覆我对赌场的刻板印象，什么美女荷官在线发牌根本见不着（当然也可能只是我见不着）！事实上澳门的菠菜业非常之正规，每层楼足球场大小的场地上，摆了无数张环形赌桌，荷官坐在中间当庄家，客人围着他与之对赌，什么游戏都有，21点、幸运6、摇骰子。。荷官清一色正式工作服，大多50左右大叔大妈，带个口罩，面无表情，就是个无情的发牌机器。似乎荷官只是上班下班拿死工资的打工人，输赢跟他们没任何关系。</p><p>此外各类细节与大陆所不能见之有趣景象非常多，读者诸君有机会务必亲身体会。</p><p>澳门评价：⭐⭐⭐⭐</p><h1>DAY4（8.10）：潮汕半日游</h1><p>目的十分单纯，体验传说中正宗的潮汕牛肉。</p><p>牛肉吃了，各类肥牛雪花匙仁黄喉三宝吃到撑人均才2.5面，较之泛悦城动辄上千的潮汕牛肉火锅应当说性价比非常高。</p><p>但是，和牛肉相比，潮汕给我印象最深的还是当日刚出酒店，就狂风大作，暴雨骤起，雷鸣闪电，天翻地覆。潮汕的暴雨和武汉的暴雨是不一样的，武汉的雨再凶猛都是在直上直下的方向加大水流量，是有迹可循、有办法防得住的，大概就像一个知书达理的导师对你的垃圾论文输出，虽然是骂，但也是有逻辑、讲章法地骂；而潮汕的雨是不讲任何规律的，瓢盆大雨在狂乱大风的加持下，忽左忽右，前后夹击，一把雨伞不可能防得住，一分钟之内必湿身诱惑，这大概就像我妈发脾气，你要是想试图从逻辑层面找出漏洞然后反击那是不可能的 —— 只要处处是漏洞，那就没有漏洞。不过话说回来，体验一场武汉从未见过的大雨、哪怕浑身被淋透也是有意思的事，想来这就是旅行的意义吧。</p><p><img src="https://s2.loli.net/2023/08/19/xwCPT82uorFV5Q9.png" alt=""></p><p>潮汕评价：⭐⭐⭐</p>]]></content>
    
    
    <categories>
      
      <category>偶尔也得摸摸鱼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>香港</tag>
      
      <tag>澳门</tag>
      
      <tag>旅游</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>event-triggered系列论文学习</title>
    <link href="/2023/07/20/event_triggered/"/>
    <url>/2023/07/20/event_triggered/</url>
    
    <content type="html"><![CDATA[<h1>Paper 1：Event-Triggered Real-Time Scheduling of Stabilizing Control Tasks, 2007, TAC</h1><h3 id="一、motivation">一、motivation</h3><p>​传统的固定时间周期的采样方式缺乏严格量化证明（时间周期为多少合适？少了不准确，多了浪费资源），而在微型处理器上又希望能尽可能节约计算资源，所以考虑将周期采样转换为非周期采样，<strong>采样时间由某个“事件”来触发</strong>。</p><h3 id="二、预备知识">二、预备知识</h3><ol><li><strong>$k$类函数、$k_\infty$类函数</strong></li></ol><p>​如果连续函数$\alpha:[0,a) \rightarrow [0,\infty)$严格递增，且$\alpha(0)=0$，则$\alpha$属于$k$类函数；更进一步地，如果$a=\infty$，当$r\rightarrow \infty$时，$\alpha®\rightarrow\infty$，那么$\alpha$属于$k_\infty$类函数</p><ol start="2"><li><p><strong>问题描述</strong></p><p>控制系统：$\dot x=f(x,u)$</p><p>反馈控制：$u=k(x)$</p><p>恒定控制：$t\in[t_i+\Delta,t_{i+1}+\Delta]\Longrightarrow u(t)=u(t_i+\Delta)$（Δ是现实中的额外耗时，IO读取、计算耗时之类的）</p><p>测量误差：$t\in[t_i+\Delta,t_{i+1}+\Delta]\Longrightarrow e(t)=x(t_i)-x(t)$</p></li><li><p><strong>ISS Lyapunov函数</strong></p><p><img src="https://s2.loli.net/2023/07/20/S6gNBRb1uwmIx2j.png" alt=""></p><p>其中$\underline\alpha,\alpha,\overline\alpha,\gamma$都是$k_\infty$类函数</p></li></ol><h3 id="三、event-triggered-机制">三、event-triggered 机制</h3><ol><li><p>如果我们设置有关误差的约束条件为：<br>$$<br>\gamma(|e|)\leq\sigma\alpha(|x|),\quad\sigma&gt;0\quad\quad(8)<br>$$<br>将其代入公式 (5) 可得：<br>$$<br>\frac{\partial V}{\partial x}f(x,k(x+e))\leq(\sigma-1)\alpha(|x|)<br>$$<br>那么此时我们只需要让$\sigma&lt;1$就可保证Lyapunov函数 V 是递减的。因此，<strong>我们可以将事件触发规则设置为下式：</strong><br>$$<br>\gamma(|e|)=\sigma\alpha(|x|)\quad\quad(9)<br>$$</p></li><li><p>在设置好触发规则之后，一个相应的问题是：触发时间由 (9) 隐式定义，那如何保证两次触发时间不会无限接近，从而造成芝诺行为呢？</p><p>原文通过Lipschitz条件证明了只要时延Δ足够小，则最小执行间隔时间存在，<strong>也就保证了$t_i-t_{i+1}$的下界，即$t_i-t_{i+1}\ge\tau,\tau\in\mathbb{R}^{+}$</strong></p><p>具体证明过程略</p><p><img src="https://s2.loli.net/2023/07/20/5dLwEYT3qFBMvit.png" alt=""></p></li><li><p><strong>仿真代码</strong><br>$$<br>\left[\begin{matrix}\dot{x}_1\\<br>\dot{x}_2\end{matrix}\right]=\left[\begin{matrix}0&amp;1\\<br>-2&amp;3\end{matrix}\right]\left[\begin{matrix}x_1\\<br>x_2\end{matrix}\right]+\left[\begin{matrix}0\\<br>1\end{matrix}\right]u<br>$$</p><p>$$<br>V=x^TPx<br>$$</p><p>$$<br>\begin{aligned}\partial V/\partial x(Ax+BKx)=-x^{T}Qx\end{aligned}<br>$$</p><p>$$<br>P=\left[\begin{array}{cc}1&amp;\frac{1}{4}\\<br>\frac{1}{4}&amp;1\end{array}\right],\quad Q=\left[\begin{array}{cc}\frac{1}{2}&amp;\frac{1}{4}\\<br>\frac{1}{4}&amp;\frac{3}{2}\end{array}\right]<br>$$</p><p>把测量误差带入表达式，我们有：<br>$$<br>\frac{\partial V}{\partial x}\Big(Ax+BKx+BKe\Big)\leq-a|x|^2+b|e|x|<br>$$<br>其中<br>$$<br>a=\lambda_m(Q)&gt;0.44\quad b=|K^TB^TP+PBK|=8<br>$$<br>$\lambda_m(Q)$表示 Q 的最小特征值，$\sigma b$应比0.44更小，算出来$\sigma$的上界约为0.05，我们可以取$\sigma’=0.03$</p> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% Tabuada, P. (2007). </span><br><span class="hljs-comment">% Event-triggered real-time scheduling of stabilizing control tasks.</span><br><span class="hljs-comment">% IEEE Transactions on Automatic Control,52(9), 1680-1685.</span><br><br><br>clc;        <br>clear;      <br>close all;<br><br><span class="hljs-comment">%% system define</span><br>A = [<span class="hljs-number">0</span> <span class="hljs-number">1</span>; <span class="hljs-number">-2</span> <span class="hljs-number">3</span>];<br>B = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];<br>K = [<span class="hljs-number">1</span> <span class="hljs-number">-4</span>];<br>P = [<span class="hljs-number">1</span> <span class="hljs-number">0.25</span>; <span class="hljs-number">0.25</span> <span class="hljs-number">1</span> ];<br>Q = [<span class="hljs-number">0.5</span> <span class="hljs-number">0.25</span>; <span class="hljs-number">0.25</span> <span class="hljs-number">1.5</span>];<br>x0 = [<span class="hljs-number">0.5</span> <span class="hljs-number">0.5</span>]&#x27;;<br>dt = <span class="hljs-number">0.001</span>;<br>trigger_count = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">% sigma是上界，sigma_prime应小于sigma</span><br><span class="hljs-comment">% 原论文中有解释</span><br>sigma_prime = <span class="hljs-number">0.03</span>;<br>sigma = <span class="hljs-number">0.05</span>;<br><br><span class="hljs-comment">%% simulation</span><br>x_buffer = [];<br>u_buffer = [];<br>error_buffer = [];<br>error_trigger = [];<br>error_upper_bound = [];<br><br>x = x0;         <br>u = K*x0;    <br>syms s<br><br><span class="hljs-comment">% 定常连续系统方程的离散化</span><br><span class="hljs-comment">% 具体计算原理可参考https://zhuanlan.zhihu.com/p/556915351的2.2节</span><br>Ad = expm(A*dt);<br>Bd = int(expm(A*s),<span class="hljs-number">0</span>,dt)*B;<br>Bd = eval(Bd);<br><br><br><span class="hljs-keyword">for</span> step = <span class="hljs-number">1</span>:<span class="hljs-number">15000</span><br>    error = x - x0;<br>    <span class="hljs-comment">% 欧几里得范数也是一种k类函数</span><br>    <span class="hljs-keyword">if</span> norm(error) &gt;= sigma_prime * norm(x)<br>        x0 = x;<br>        u = K*x0;<br>        trigger_count = trigger_count + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br>    x = Ad*x + Bd*u;<br>    <br>    E = norm(error);<br>    ET = sigma_prime * norm(x);<br>    EUB = sigma * norm(x);<br><br>    error_buffer = [error_buffer E];<br>    error_trigger = [error_trigger ET];<br>    error_upper_bound = [error_upper_bound EUB];<br>    x_buffer = [x_buffer x];<br>    u_buffer = [u_buffer u];<br>    <br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">%% plot</span><br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">hold</span> on<br><span class="hljs-built_in">plot</span>(x_buffer&#x27;, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>);<br><span class="hljs-built_in">plot</span>(u_buffer, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;x1&#x27;</span>, <span class="hljs-string">&#x27;x2&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">hold</span> on<br><span class="hljs-built_in">plot</span>(error_buffer, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(error_trigger, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>, <span class="hljs-string">&#x27;Color&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-built_in">plot</span>(error_upper_bound, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Color&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;error trigger&#x27;</span>, <span class="hljs-string">&#x27;error upper bound&#x27;</span>);<br><br>fprintf(<span class="hljs-string">&#x27;the system has been triggered %d times in all\n&#x27;</span>, trigger_count);<br><br></code></pre></td></tr></table></figure><p>仿真结果：</p><p><img src="https://s2.loli.net/2023/07/20/6xms4BwDbjktp5T.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/20/q5raNL71SfctwA2.png" alt=""></p></li></ol><p>​可见最后的实际误差确实在由事件触发规则限制的误差之下，系统也达到了收敛状态</p><h1>Paper 2：Distributed Event-Triggered Control for Multi-Agent Systems, 2012, TAC</h1><h3 id="一、motivation：">一、motivation：</h3><ol><li>上一篇文献没提”多智能体“，讲的只是一个普通的控制系统的事件触发；而这篇文章讲的MAS中的事件触发</li><li>分为集中式（各个节点都知道全局信息，如拉普拉斯矩阵）和分布式（各节点只知道自己的邻居信息）</li><li>给出了自触发公式：算出两次触发时间之间的上限，只要间隔不超过这个上限最后就能稳定</li></ol><h3 id="二、集中式事件触发">二、集中式事件触发</h3><p>模型：单积分器 $\dot{x_i}=u_i$</p><p>控制器：$u=-Lx$</p><p>拓扑关系：无向连通图</p><img src="https://s2.loli.net/2023/08/29/ymxOnwAiJQBofkR.png" style="zoom:67%;" /><img src="https://s2.loli.net/2023/08/29/s7liCN6L3qSYx2Q.png" style="zoom:67%;" /><p>由上述推导可知，事件触发条件为：<br>$$<br>||e||=\sigma\frac{||Lx||}{||L||}<br>$$</p><h3 id="二、分布式事件触发">二、分布式事件触发</h3><p>基本思路是每个智能体都只能获取邻居信息，无法得知全局信息（Laplace矩阵）；哐哐一通推导后得到每个智能体的事件触发条件：<br>$$<br>e_i^2=\frac{\sigma_ia(1-a|N_i|)}{N_i}z_i^2<br>$$</p><h3 id="三、自触发">三、自触发</h3><p>idea：推导出两次触发时间的间隔上界，即只要时间间隔别超过这个上界就能稳定；在自触发中，“事件”不再由误差e决定，而是取决于间隔时间<br>$$<br>\begin{aligned}\Delta&amp;=4\sigma^4\left|(Lx(t_i))^TLLx(t_i)\right|^2\&amp;+4\sigma^2\left|L^2x(t_i)\right|^2\cdot\left(|Lx(t_i)|^2|L|^2-\sigma^2\left|L^2x(t_i)\right|^2\right)&gt;0.\end{aligned}<br>$$</p><p>$$<br>t_{i+1}-t_i\leq\frac{-2\sigma^2\left(Lx(t_i)\right)^TLLx(t_i)+\sqrt{\Delta}}{2\left(|Lx(t_i)|^2|L|^2-\sigma^2|L^2x(t_i)|^2\right)}<br>$$</p><h3 id="四、仿真">四、仿真</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% Distributed Event-Triggered Control for Multi-Agent Systems, 2012, TAC</span><br><br>clc;        <br>clear;      <br>close all;<br><br><span class="hljs-comment">%% system define</span><br>L = [<span class="hljs-number">1</span> <span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-number">-1</span> <span class="hljs-number">3</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-number">0</span> <span class="hljs-number">-1</span> <span class="hljs-number">2</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-number">0</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span> <span class="hljs-number">2</span>];<br><br>x0 = [<span class="hljs-number">0.1</span> <span class="hljs-number">0.2</span> <span class="hljs-number">0.3</span> <span class="hljs-number">0.4</span>]&#x27;;<br><br>sigma = <span class="hljs-number">0.65</span>;<br>sigma_1 = <span class="hljs-number">0.55</span>;<br>sigma_2 = <span class="hljs-number">0.55</span>;<br>sigma_3 = <span class="hljs-number">0.75</span>;<br>sigma_4 = <span class="hljs-number">0.75</span>;<br>alpha = <span class="hljs-number">0.2</span>;<br><br>dt = <span class="hljs-number">0.001</span>;<br>trigger_count_1 = <span class="hljs-number">0</span>;<br>trigger_count_2 = <span class="hljs-number">0</span>;<br>trigger_count_3 = <span class="hljs-number">0</span>;<br>trigger_count_4 = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-comment">%% 集中式-事件触发</span><br>x_buffer_1 = [];<br>u_buffer_1 = [];<br>error_buffer_1 = [];<br>error_upper_bound_1 = [];<br><br>x = x0;         <br>u = -L*x0;    <br><br>B = <span class="hljs-built_in">ones</span>(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>);<br>syms s;<br>Bd = int(expm(<span class="hljs-built_in">zeros</span>(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)*s),<span class="hljs-number">0</span>,dt)*B;<br>Bd = eval(Bd);<br><br><span class="hljs-keyword">for</span> step = <span class="hljs-number">1</span>:<span class="hljs-number">5000</span><br>    error = x - x0;<br>    E = norm(error);<br><br>    <span class="hljs-keyword">if</span> E &gt;= sigma * norm(L*x)/norm(L)<br>        x0 = x;<br>        u = -L*x0;<br>        trigger_count_1 = trigger_count_1 + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br>    x = x + Bd.*u;<br><br>    EUB = sigma * norm(L*x)/norm(L);<br><br>    error_buffer_1 = [error_buffer_1 E];<br>    error_upper_bound_1 = [error_upper_bound_1 EUB];<br>    x_buffer_1 = [x_buffer_1 x];<br>    u_buffer_1 = [u_buffer_1 u];<br>    <br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-comment">%% 集中式-自触发</span><br>x_buffer_2 = [];<br>u_buffer_2 = [];<br>error_buffer_2 = [];<br>error_upper_bound_2 = [];<br><br>x0 = [<span class="hljs-number">0.1</span> <span class="hljs-number">0.2</span> <span class="hljs-number">0.3</span> <span class="hljs-number">0.4</span>]&#x27;;<br>x = x0;         <br>u = -L*x0;  <br><br>t_now = <span class="hljs-number">0</span>;<br>time_upper_bound = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> step = <span class="hljs-number">1</span>:<span class="hljs-number">5000</span><br>    error = x - x0;<br>    E = norm(error);<br>    t_next = dt*step;<br><br>    <span class="hljs-keyword">if</span> t_next - t_now &gt;= time_upper_bound<br>        x0 = x;<br>        u = -L*x0;<br>        t_now = t_next;<br>        time_upper_bound = <span class="hljs-number">0.2</span>*calculate_fun(sigma, L, x0);<br>        trigger_count_2 = trigger_count_2 + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><br>    x = x + Bd.*u;<br><br>    EUB = sigma * norm(L*x)/norm(L);<br><br>    error_buffer_2 = [error_buffer_2 E];<br>    error_upper_bound_2 = [error_upper_bound_2 EUB];<br>    x_buffer_2 = [x_buffer_2 x];<br>    u_buffer_2 = [u_buffer_2 u];<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>)<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">hold</span> on<br><span class="hljs-built_in">plot</span>(x_buffer_1&#x27;, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>);<br><span class="hljs-built_in">plot</span>(u_buffer_1&#x27;, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;x1&#x27;</span>, <span class="hljs-string">&#x27;x2&#x27;</span>, <span class="hljs-string">&#x27;x3&#x27;</span>, <span class="hljs-string">&#x27;x4&#x27;</span>, <span class="hljs-string">&#x27;u1&#x27;</span>, <span class="hljs-string">&#x27;u2&#x27;</span>, <span class="hljs-string">&#x27;u3&#x27;</span>, <span class="hljs-string">&#x27;u4&#x27;</span>);<br>title(<span class="hljs-string">&quot;集中式-事件触发&quot;</span>);<br><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">hold</span> on<br><span class="hljs-built_in">plot</span>(error_buffer_1, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(error_upper_bound_1, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Color&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;error upper bound&#x27;</span>);<br>title(<span class="hljs-string">&quot;集中式-事件触发&quot;</span>);<br><br>fprintf(<span class="hljs-string">&#x27;1： triggered %d times in all\n&#x27;</span>, trigger_count_1);<br><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">hold</span> on<br><span class="hljs-built_in">plot</span>(x_buffer_2&#x27;, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>);<br><span class="hljs-built_in">plot</span>(u_buffer_2&#x27;, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;x1&#x27;</span>, <span class="hljs-string">&#x27;x2&#x27;</span>, <span class="hljs-string">&#x27;x3&#x27;</span>, <span class="hljs-string">&#x27;x4&#x27;</span>, <span class="hljs-string">&#x27;u1&#x27;</span>, <span class="hljs-string">&#x27;u2&#x27;</span>, <span class="hljs-string">&#x27;u3&#x27;</span>, <span class="hljs-string">&#x27;u4&#x27;</span>);<br>title(<span class="hljs-string">&quot;集中式-自触发&quot;</span>);<br><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br><span class="hljs-built_in">hold</span> on<br><span class="hljs-built_in">plot</span>(error_buffer_2, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(error_upper_bound_2, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Color&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;error upper bound&#x27;</span>);<br>title(<span class="hljs-string">&quot;集中式-自触发&quot;</span>);<br><br>fprintf(<span class="hljs-string">&#x27;2： triggered %d times in all\n&#x27;</span>, trigger_count_2);<br><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/29/gNkK4ruI9ZVX5FQ.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>科研只为把业毕</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协同控制</tag>
      
      <tag>事件触发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EE364A笔记</title>
    <link href="/2023/06/14/%E3%80%8AEE364A%E7%AC%94%E8%AE%B0%E3%80%8B/"/>
    <url>/2023/06/14/%E3%80%8AEE364A%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1>《EE364A笔记》</h1><h1>Lecture_1 Introduction</h1><ol><li><strong>最小二乘问题</strong></li></ol><p><img src="https://s2.loli.net/2023/06/14/6hporxeNmGwjKbC.png" alt=""></p><ul><li>有解析解：$x^*=(A^TA)^{-1}A^Tb$</li><li>现已有成熟方法和软件来解决最小二乘问题</li></ul><ol start="2"><li><strong>线性规划问题</strong></li></ol><p><img src="https://s2.loli.net/2023/06/14/Ty8cbCUN71uZdYv.png" alt=""></p><ul><li>没有解析解</li><li>现已有成熟方法和软件来解决线性规划问题</li></ul><ol start="3"><li><strong>凸优化问题</strong></li></ol><p><img src="https://s2.loli.net/2023/06/14/UzswpgkhnlICyQf.png" alt=""></p><p>​其中目标函数 f0 和约束函数 fi 都是凸的，即满足：</p><p><img src="https://s2.loli.net/2023/06/14/OWtH2KeDRAimNac.png" alt=""></p><h1>Lecture_2 Convex sets</h1><h3 id="一、凸包与凸集">一、凸包与凸集</h3><p>​见<a href="https://qlhhahaha.github.io/2023/04/13/%E3%80%8A%E6%9C%80%E4%BC%98%E5%8C%96%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E6%96%87%E5%86%8D%E6%96%87%EF%BC%89%E7%AC%94%E8%AE%B0%E3%80%8B/#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">《最优化计算方法（文再文）笔记》</a></p><h3 id="二、如何保证一个集合C的凸性">二、如何保证一个集合C的凸性</h3><ol><li><strong>使用定义</strong></li></ol><p><img src="https://s2.loli.net/2023/06/14/RGnYNVfLv2zU1Zh.png" alt=""></p><ol start="2"><li><strong>证明C是由简单凸集经过以下操作得到：</strong></li></ol><ul><li><p>​**相交：**任意个数的凸集相交仍为凸集</p><p><img src="https://s2.loli.net/2023/06/14/qIwAbr251N4MTV6.png" alt=""></p></li></ul><p>​为什么说S是凸集捏？<br>​首先cos是偶函数，所以 t 的范围简化为0到pi/3，我们假设 t 为该范围中的某个定值；<br>​定义子集$S_t={ x\in R^m  |   \left\vert p(t)\right\vert \le1 }$，即先固定 t ，<br>​则此时$\left\vert p(t)\right\vert \le1$是两个半平面的交集（因为 p(t)是[cos t, cos 2t]和[x1, x2]的内积，$p(t) \le1$是个半平面， $p(t) \ge -1$也是个半平面 ），所以 St 为凸集<br>​而$S=\cap S_t ,t\in(0,\pi/3)$，即为无数个凸集的交集，故 S 仍未凸集（见上右图）</p><ul><li>**仿射函数：**凸集经仿射变换（缩放、平移、投影）仍是凸集</li><li><strong>透视函数与线性分式函数</strong></li></ul><p>​透视函数P：$R^{n+1}\rightarrow R^n$</p><p><img src="https://s2.loli.net/2023/06/14/ZBbct6EWzUN5LQu.png" alt=""></p><p>​线性分式函数 f：$R^{n}\rightarrow R^m$</p><p>​<img src="https://s2.loli.net/2023/06/14/4tYHiAjksyeaL5D.png" alt=""></p><h3 id="三、支撑超平面定理">三、支撑超平面定理</h3><p>​如果C是凸集，那么在其每一个边界点上都存在至少一个支撑超平面（几何意义是切线、切面）</p><div class="note note-warning">            <p>​💡 PS. 支撑超平面不一定唯一，如矩形顶点处就有无数个超平面（因为边界突变）<br>​</p>          </div><h1>Lecture_3 Convex functions</h1><ol><li><p><strong>常见凸函数</strong></p><ul><li><p>指数函数</p></li><li><p>幂函数：$x^\alpha,\alpha \ge1,or ,\alpha\le0$</p></li><li><p>熵函数：$xlogx$</p></li><li><p>所有的范数</p></li></ul></li><li><p><strong>拓展函数</strong></p></li></ol><p><img src="https://s2.loli.net/2023/06/14/KOfqJhre8BkpQtL.png" alt=""></p><ol start="3"><li><strong>上境图（epigraph）</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/jqlZ5VfMLDPOIUc.png" alt=""></p><p>​f 为凸函数 $\iff$ 的上境图为凸集</p><ol start="4"><li><p><strong>共轭函数</strong></p> <img src="https://s2.loli.net/2023/06/14/ThjPmMAYB8sZWNk.png" style="zoom:80%;" /></li></ol><p>​$f^*$始终是凸函数（即使 f 不凸）</p><p>​举例：</p><p><img src="https://s2.loli.net/2023/06/14/pgZPLbSGxHqQcVW.png" alt=""></p><ol start="5"><li><strong>拟凸函数（quasiconvex function）</strong></li></ol><p>​定义：若 dom f 为凸集，且对任意的 α ，其下水平集<br>$$<br>S_\alpha={x\in domf | f(x) \le \alpha }<br>$$<br>​<img src="https://s2.loli.net/2023/06/14/FxYt8vHmyijQPbB.png" style="zoom:67%;" /></p><h1>Lecture_4 Convex optimization problems</h1><ol><li><strong>标准形式</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/xU72RaZtkAoOp6s.png" alt=""></p><ol start="2"><li><strong>凸优化问题</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/M6ZID7QrkEmhdbV.png" alt=""></p><p>​其中 fi(x) 都是凸的；等式约束是仿射的</p><p>​<div class="note note-warning">            <p>​💡 PS. 凸优化问题的任何局部最优解都是全局最优解<br>​</p>          </div></p><ol start="3"><li><p><strong>一些常见的转换技巧</strong></p><ul><li><strong>消除等式约束</strong></li></ul><p><img src="https://s2.loli.net/2023/06/14/GNf9QxmPc76VF4z.png" alt=""></p><p>​即先把 Ax=b 解出来，再带到不等式约束中</p><ul><li><strong>引入等式约束</strong></li></ul><p><img src="https://s2.loli.net/2023/06/14/gavAucWLDYkzfhp.png" alt=""></p><ul><li><strong>引入松弛变量</strong></li></ul></li><li><p><strong>线性规划问题（Linear Program, LP）</strong></p></li></ol><p><img src="https://s2.loli.net/2023/06/14/RhoVEv6rnT4g9W5.png" alt=""></p><p>​几何解释为，线性规划的可行域是多面体P，该最优问题就是要在P上求仿射函数$c^Tx+d$的极小值</p><p>​<strong>举例：</strong></p><p>​一份健康的饮食包含m种不同的营养，每种至少需要b1,…,bm。我们可以从n种食物中选择非负的量x1，… ，xn以构成一份食谱。单位第 j 种食品含有营养 i 的量为 aj，而价格为 cj。我们希望设计出一份最便宜的满足营养需求的食谱。这一问题可以描述为线性规划</p><p>​<img src="https://s2.loli.net/2023/06/14/dmYERS9ArT4ockG.png" alt=""></p><ol start="5"><li><strong>二次优化问题（Quadratic program，QP）</strong></li></ol><p>​目标函数是凸二次型且约束函数为仿射</p><p>​<img src="https://s2.loli.net/2023/06/14/zpdoy2Ww67TD5Or.png" alt=""></p><p>​几何解释：可行集是多面体P，虚线为凸二次目标函数的等位线</p><p>​<img src="https://s2.loli.net/2023/06/14/veWtf29I3QhjOD8.png" style="zoom:67%;" /></p><p>​线性规划是二次规划的特例（P取0时退化为线性规划）</p><ol start="6"><li><strong>二次约束二次规划问题（QCQP）</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/VnTWEzr49bo8uHa.png" alt=""></p><p>​在二次规划的基础上，若不等式约束条件也是凸二次型，则称之为QCQP</p><ol start="7"><li><strong>二阶锥规划（Second order cone programming，SOCP）</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/u3QPtmK7WOAqjrY.png" alt=""></p><p>​当 ci = 0时，退化为一个QCQP问题</p><h1>Lecture_5 Duality</h1><ol><li><strong>Lagrange对偶函数</strong></li></ol><p>​一个标准形式的问题（不要求是凸的）</p><p>​<img src="https://s2.loli.net/2023/06/14/yVwbc4Fizgvo6Hs.png" style="zoom:67%;" /></p><p>​把它写成</p><p>​<img src="https://s2.loli.net/2023/06/14/HVapvMDbdsgy8xm.png" style="zoom:67%;" /></p><p>​所谓的Lagrange对偶函数，就是去求它的下确界</p><p>​<img src="https://s2.loli.net/2023/06/14/XQI8zJFKjD4eNME.png" style="zoom:80%;" /></p><p>​对于可行域内所有的$\tilde{x}$，皆有$p^* \ge g(\lambda,v)$，即$g(\lambda,v)$是原问题最优值的下界</p><ol start="2"><li><strong>举例：线性方程组的最小二乘解</strong></li></ol><p>​考虑问题：</p><p>​<img src="https://s2.loli.net/2023/06/14/bfNtnDGL4EU3sd1.png" style="zoom:67%;" /></p><p>​其Lagrange函数为：</p><p>​<img src="https://s2.loli.net/2023/06/14/4L83i2favGyA9wQ.png" style="zoom:67%;" /></p><p>​为得最小值，求其导数：</p><p>​<img src="https://s2.loli.net/2023/06/14/lyd6zVUIMFagND9.png" style="zoom:67%;" /></p><img src="https://s2.loli.net/2023/06/14/GNsDmbSezfZXlxK.png" style="zoom:67%;" /><p>​所以可得原问题最优解的下界为：</p><p>​<img src="https://s2.loli.net/2023/06/14/3fhGcy8n92x6LBH.png" style="zoom:67%;" /></p><ol start="3"><li><strong>Lagrange对偶问题</strong></li></ol><p>​求Lagrange函数的最大值，也就是原问题的最好下界，这就是所谓的Lagrange对偶问题</p><p>​<img src="https://s2.loli.net/2023/06/14/D4RoZHMqxLeYQgh.png" style="zoom:67%;" /></p><p>​<strong>举例：</strong></p><p>​<img src="https://s2.loli.net/2023/06/14/NaHJB97GxjZh1u5.png" style="zoom: 80%;" /></p><p>​其Lagrange函数为：</p><p>​<img src="https://s2.loli.net/2023/06/14/WIP4YJpu8gRl2rH.png" style="zoom:80%;" /></p><p>​<div class="note note-warning">            <p>​💡 PS. 注意：此时 x 的定义域是R，也就是说不用再去考虑 (x-2)(x-4)为负这个约束条件，因为Lagrange函数本身就已经包含了这个条件<br>​</p>          </div></p><p>​那么显而易见，对于这个以 λ 为自变量的二次函数，$\lambda \le -1$时下确界为 -∞ ;$\lambda &gt; -1$时，在$\tilde{x}=3\lambda/(1+\lambda)$处取最小值，即</p><p>​<img src="https://s2.loli.net/2023/06/14/6bZegP2RjIQMhKB.png" alt=""></p><p>​此时我们得到了所谓的Lagrange对偶问题：</p><p>​<img src="https://s2.loli.net/2023/06/14/Ec1fbjwuSgXpRno.png" alt=""></p><p>​容易验证得到此时的最优点为 λ=2，最优值为5，和原问题一致（这是必然的，因为当 x 属于(2, 4)时不等式严格成立，即满足Slater条件，且原问题是凸问题，那么强对偶性成立）</p><p>​<div class="note note-warning">            <p>​💡 PS. 除了Slater条件之外，还有其它很多判断准则<br>​</p>          </div></p><ol start="4"><li><strong>强弱对偶性</strong></li></ol><p>​Lagrange对偶问题的最优值用$d^*$表示</p><ul><li>弱对偶性指$d^* \le p^*$，弱对偶性始终满足（即使原问题不是凸的）</li><li>强对偶性指$d^* = p^*$，原问题是凸的时候通常（但不总是）满足强对偶性</li></ul><ol start="5"><li><strong>Slater约束准则</strong></li></ol><p>​对于一个凸问题</p><p>​<img src="https://s2.loli.net/2023/06/14/HOyYXrIz5w9Bnba.png" alt=""></p><p>​如果存在一个点$x \in intD$（内点），使得$f_i(x)&lt;0, and,Ax=b$（即不等式约束严格成立），则称之为满足Slater约束，此时强对偶性成立</p><ol start="6"><li><strong>互补松弛性（Complementary slackness）</strong></li></ol><p>​假设强对偶性成立，$x^<em>$是原问题最优解，$(\lambda^</em>,\nu^*)$是对偶问题的最优解</p><p>​则有：</p><p>​<img src="https://s2.loli.net/2023/06/14/c13xleTfoOuFUPB.png" alt=""></p><p>​得到结论：</p><p>​<img src="https://s2.loli.net/2023/06/14/ibavpBdZtWIGM9U.png" alt=""></p><p>​该结论就是所谓的互补松弛性</p><ol start="7"><li><strong>KKT最优条件</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/icf9kDuy5ATP4v3.png" alt=""></p><p>​对于一个凸问题来说，若某组$(\tilde{x},\tilde{\lambda},\tilde{\nu})$满足KKT条件，那它们就是最优解</p><h1>Lecture_6 Approximation and fitting</h1><ol><li><strong>范数逼近</strong></li></ol><p>​典型的范数逼近问题是具有以下形式的无约束问题：</p><p>​<img src="https://s2.loli.net/2023/06/14/jSk2PFMpO6194Bc.png" alt=""></p><p>​从<strong>逼近</strong>的角度进行解释：</p><p>​通过将 Ax 表示为$Ax=x_1a_1+…+x_na_n$，其中 ai 为 A 的列，我们可以看出，范数逼近问题的目标是用 A 的列的线性组合，尽可能准确地逼近或拟合向量 b</p><ol start="2"><li><strong>最小二乘逼近</strong></li></ol><p>​取范数为2，则原问题转换为：<br>$$<br>min ||Ax-b||_2^2<br>$$<br>​将目标函数表示为凸二次函数：<br>$$<br>f(x)=x^TA^TAx-2b^TAx+b^Tb<br>$$<br>​求其导数有：<br>$$<br>\nabla f(x)=2A^TAx-2A^Tb=0<br>$$<br>​即 x 满足：<br>$$<br>A^TAx=A^Tb<br>$$<br>​可得其唯一解$x=(A^TA)^{-1}A^Tb$</p><ol start="3"><li><strong>罚函数逼近</strong></li></ol><p>​$l_p$范数逼近问题的目标函数为：<br>$$<br>(|r_1|^p+\cdots+|r_m|^p)^{1/p}<br>$$<br>​其中 ri = Ax - b ，称之为残差，所谓的范数逼近，就是要残差尽可能地小，那么我们可以把范数逼近问题转换为以下形式：</p><p>​<img src="https://s2.loli.net/2023/06/14/aLej2nqWCifJ9xI.png" alt=""></p><p>​其中 Φ 称之为罚函数，我们通常将Φ设为一个对称的、非负的凸函数，则上述问题是一个凸优化问题</p><p>​常见的罚函数：</p><ul><li><p>二次罚函数$\phi(u)=u^{2}$</p></li><li><p>带死区的罚函数$\phi(u)=\max{0,|u|-a}$</p></li><li><p>对数罚函数<br>$$<br>\phi(u)=\begin{cases}-a^2\log(1-(u/a)^2)&amp;|u|&lt;a\ \infty&amp;\text{otherwise}\end{cases}<br>$$</p></li></ul><img src="https://s2.loli.net/2023/06/14/weIWRO76KdrNubG.png" style="zoom:67%;" /><ol start="4"><li><strong>正则化逼近</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/u7foyTsC2RGOhxt.png" alt=""></p><p>​研究的是双目标优化问题，即同时让|Ax-b|和|x|尽可能地小，这在鲁棒逼近中可解释为：x 较小时Ax=b对误差的鲁棒性更好</p><ol start="5"><li><p><strong>信号重构问题</strong></p><p>假设信号被加性噪声 v 污染，即<br>$$<br>x_{cor}=x+v<br>$$<br>​所谓<strong>信号重构</strong>，就是在给定受污染信号 xcor 的情况下，构建对原始信号 x 的估计值 $\hat{x}$，也叫<strong>光滑化</strong></p></li></ol><p>​重构问题的一个简单形式是双准则问题</p><p>​<img src="https://s2.loli.net/2023/06/14/wWBtCq4ouKRQpf8.png" alt=""></p><p>​其中 Φ 是凸的，称为正则化函数或光滑目标。这个双准则问题，就是要寻求一个接近被污染信号并且光滑的信号</p><ul><li>​<strong>二次光滑</strong></li></ul><img src="https://s2.loli.net/2023/06/14/zpAnhSduUiymxsj.png" style="zoom: 50%;" /><ul><li>​<strong>总变差重构</strong></li></ul><img src="https://s2.loli.net/2023/06/14/Csn6IaPi37WBqUd.png" style="zoom:67%;" /><ol start="6"><li><strong>鲁棒逼近</strong></li></ol><p>​问题形式为，在 A 不确定的情况下，最可能地最小化$||Ax-b||$</p><p>​两种解决思路：</p><ul><li>随机：假设 A 是随机的，最小化$E||Ax-b||$</li><li>最坏情况：求$min,sup||Ax-b||$</li></ul><h1>Lecture_10 Unconstrained minimization</h1><ol><li><strong>定义</strong></li></ol><p>​字面意思，没有约束条件的优化问题，我们假设 f 是可微凸函数，那么无约束优化问题其实就是去求梯度为零的点</p><p>​<img src="https://s2.loli.net/2023/06/14/yhokBVYK4SmZ7tv.png" alt=""></p><ol start="2"><li><strong>下降方法</strong></li></ol><p>​即选择合适的搜索步长 t</p><ul><li>​<strong>精确直线搜索</strong></li></ul><p>​找到让函数值最小的那个步长 t，即<br>$$<br>t=argmin_{s \ge 0}, f(x+s\Delta x)<br>$$<br>​当目标函数形式简单，能求得解析解时可考虑使用这种方法</p><ul><li>​<strong>回溯直线搜索</strong></li></ul><p><img src="https://s2.loli.net/2023/06/14/9UpaeJWEyI3O5QF.png" alt=""></p><p>​基本思路是：先采用单位步长，若不满足条件，则不断缩小。</p><p>​满足条件时的几何意义：$f(x+t\Delta x)$落入两条虚线之间的范围</p><p>​<img src="https://s2.loli.net/2023/06/14/2cwMjJrspdaETqg.png" style="zoom:67%;" /></p><ol start="3"><li>其余内容参考<a href="https://qlhhahaha.github.io/2023/04/13/%E3%80%8A%E6%9C%80%E4%BC%98%E5%8C%96%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E6%96%87%E5%86%8D%E6%96%87%EF%BC%89%E7%AC%94%E8%AE%B0%E3%80%8B/#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E6%97%A0%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95">《最优化计算方法（文再文）笔记》</a></li></ol><h1>Lecture_11 Equality constrained minimization</h1><ol><li><strong>定义</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/jaecJsrBzb4qm2I.png" alt=""></p><p>​x* 为最优点的充要条件是：存在 v* 满足</p><p>​<img src="https://s2.loli.net/2023/06/14/noNjm1WsgJ9lSaF.png" alt=""></p><ol start="2"><li><p><strong>等式约束二次规划</strong></p><p><img src="https://s2.loli.net/2023/06/14/GCusPihe2NI9qVo.png" alt=""></p></li></ol><p>​那么此时最优性条件为：<br>$$<br>Ax^<em>=b, Px^</em>+q+A^Tv^*=0<br>$$<br>​写成矩阵形式为：</p><p>​<img src="https://s2.loli.net/2023/06/14/IyCaHxuVe9DgzlO.png" alt=""></p><p>​称之为等式约束优化问题的<strong>KKT条件</strong></p><p>​</p><ol start="3"><li><strong>等式约束的Newton方法</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/jaecJsrBzb4qm2I.png" alt=""></p><p>​**思路：**二阶taylor展开转换为</p><p>​<img src="https://s2.loli.net/2023/06/14/JtYwfujRWzypMXd.png" alt=""></p><p>​即KKT条件为</p><p>​<img src="https://s2.loli.net/2023/06/14/VjD9yaUTbcBxd2E.png" alt=""></p><p>​最后求解出来的那个$\Delta x_{nt}$就是newton方向，$x+\Delta x_{nt}$是对原问题真正的最优解 x* 的一个很好的估计</p><p>​</p><p>​另外，我们定义newton减量为：</p><p><img src="https://s2.loli.net/2023/06/14/phw6qliF8BzTAuO.png" alt=""></p><p>​整个算法流程为：</p><p>​<img src="https://s2.loli.net/2023/06/14/odX7Gv6bLif8Vm9.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>科研只为把业毕</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>凸优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《CS106L笔记》</title>
    <link href="/2023/04/14/%E3%80%8ACS106L%E7%AC%94%E8%AE%B0%E3%80%8B/"/>
    <url>/2023/04/14/%E3%80%8ACS106L%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>课程来源：Stanford-CS106L(22 fall)</p><p>课程介绍：<a href="https://github.com/qlhhahaha/HashMap_for_CS106L">HashMap_for_CS106L</a></p>          </div><h1>Lecture2、Types and Structs</h1><h2 id="一、Types">一、Types</h2><ul><li>**静态语言：**有名字的东西（变量/函数）要人为给类型</li><li>**动态语言：**运行时解释器根据current value自动给类型</li></ul><p><img src="https://s2.loli.net/2023/04/14/YX8tVdgN5bH6hiu.png" alt=""></p><p><img src="https://s2.loli.net/2023/04/14/kQbXxquftZjcAMz.png" alt=""></p><h1>Lecture3、Stream</h1><h2 id="一、cout">一、cout</h2><p>cout是std内嵌的输出流，它的类型是std::ostream，所以其实<strong>你也完全可以自己定义一个std::ostream类型的输出流</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writeToStream</span><span class="hljs-params">(std::ostream&amp; anyOutputStream, <span class="hljs-type">int</span> favouriteNumber)</span> </span>&#123;<br>    anyOutputStream &lt;&lt; <span class="hljs-string">&quot;Writing to stream: &quot;</span><br>        &lt;&lt; favouriteNumber &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Write an int to the user&#x27;s console.</span><br>    <span class="hljs-type">int</span> favouriteNumber = <span class="hljs-number">1729</span>;<br><br>    <span class="hljs-comment">// Write method to take any ostream</span><br>    <span class="hljs-function">std::ofstream <span class="hljs-title">fileOut</span><span class="hljs-params">(<span class="hljs-string">&quot;out.txt&quot;</span>)</span></span>;<br><br>    <span class="hljs-built_in">writeToStream</span>(cout, favouriteNumber);<br>    <span class="hljs-built_in">writeToStream</span>(fileOut, favouriteNumber + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码会在控制台上输出1729，在out.txt中写入1730</p><h2 id="二、cin">二、cin</h2><p>同理，可以自己创建一个std::istream类型的输入流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//read numbers from a file</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readNumbers</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Create our istream and make it open the file</span><br>    <span class="hljs-function">std::istream <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-string">&quot;res/numbers.txt&quot;</span>)</span></span>;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        input &gt;&gt; value;<br>        <span class="hljs-keyword">if</span>(input.<span class="hljs-built_in">fail</span>())<br>            <span class="hljs-keyword">break</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value read: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://s2.loli.net/2023/04/14/GxBvd9eRrohVJXI.png" alt=""></p><h1>Lecture4、Initialization and References</h1><h2 id="一、Initialization">一、Initialization</h2><ol><li>注意vector两种初始化的区别</li></ol><p><img src="https://s2.loli.net/2023/04/14/kPzA2belKB5qnNr.png" alt="Untitled"></p><div class="note note-warning">            <p>💡 PS. 其中大括号初始化被称为“统一初始化”，是C11引进的，对所有数据类型都适用，可以在declaration时立即初始化</p>          </div><ol start="2"><li><strong>结构化绑定（structured binding）</strong></li></ol><p>​idea：经典语法中，为了接收一个struct\pair，可能得用点号去一个个读取结构体里的值，这很麻烦；c17中引入结构化绑定，可以直接用<strong>auto+中括号</strong>去接收（话说这东西matlab里不是早有了吗。。）</p><p><img src="https://s2.loli.net/2023/04/14/suEOq9jPceZ7LD8.png" alt=""></p><h2 id="二、References">二、References</h2><p>一个经典的引用error：想给pair中的每个值加一</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shift</span><span class="hljs-params">(vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&amp; nums)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [num1, num2]: nums) <br>&#123;<span class="hljs-comment">//显然错了，因为num1、2是nums的副本，开辟了新空间</span><br>num1++;<br>num2++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>应该修改为 for (auto&amp; [num1, num2]: nums)</p><h1>Lecture5、Container</h1><ol><li>不要搞混vector的_size和_capacity属性</li></ol><p><img src="https://s2.loli.net/2023/04/14/Zv2KtfI5RH7MVgW.png" alt=""></p><h1>Lecture7、Classes</h1><ol><li>STL中所有的container都是class</li><li><strong>模板类（template class）</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//模板类语法</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span> Second&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">my_pair</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">First <span class="hljs-title">get_first</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Second <span class="hljs-title">get_second</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_first</span><span class="hljs-params">(First f)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_second</span><span class="hljs-params">(Second f)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>First first;<br>Second second;<br>&#125;;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*****************vector.h********************/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector.cpp&quot;</span>           <span class="hljs-comment">//ps2</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vector</span>&lt;T&gt;<br>&#123;<br><span class="hljs-function">T <span class="hljs-title">my_at</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>&#125;<br><br><span class="hljs-comment">/*****************vector.cpp********************/</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;       <span class="hljs-comment">//ps1</span><br><span class="hljs-type">void</span> vector&lt;T&gt;::<span class="hljs-built_in">my_at</span>(<span class="hljs-type">int</span> i)<br>&#123;<br><span class="hljs-comment">//oops</span><br>&#125;<br><br><span class="hljs-comment">/*****************main.cpp********************/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector.h&quot;</span></span><br>vector&lt;<span class="hljs-type">int</span>&gt; a;<br>a.<span class="hljs-built_in">my_at</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><div class="note note-warning">            <aside> 💡 PS.<ol><li>首先，注意必须在每个成员函数那儿去声明一遍它是template，也就是去掉ps1那一行会报错</li><li>ps2那一行，注意，vector.h头文件里要include “vector.cpp”，否则找不到my_at()函数的具体定义 （想了老半天也没想清楚为啥。。嗯记着吧）</li><li>一般不在头文件里include源文件，因为可能造成重复定义；但也有一些场景或许会用，比如vscode里懒得写cmake脚本，就可以用include&lt;.cpp&gt;这种trick。。</li></ol>          </div><p><img src="https://s2.loli.net/2023/04/14/oDHRjb3kGdw2ON8.jpg" alt=""></p><h1>Lecture9、Template Functions</h1><ol><li><p>**motivation：**一个功能通用性很强的函数，要因为接收参数数据类型不同而复制粘贴多个版本吗？当然，function overloading可以简化这个问题，但仍然得复制粘贴，能不能把这个函数给一般化，从根源上解决问题捏？</p><p><img src="https://s2.loli.net/2023/04/14/xJfgFth1wOmLb5I.png" alt=""></p></li><li><p><strong>模板函数（Template Functions）</strong></p><p><img src="https://s2.loli.net/2023/04/14/9zcsDjKper6XuOI.png" alt=""></p><p>其中typename可以设定默认参数，即写成template<typename Type=int></p><p>在实例化使用的时候，可以显式定义Type</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">myMin</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>当然，它还可以更聪明——我们隐式声明变量，让编译器自己推断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">smarterMyMin</span><span class="hljs-params">(T a, U b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &lt; b ? a : b;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-built_in">smarterMyMin</span>(<span class="hljs-number">3.2</span>, <span class="hljs-number">4</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>💡 PS. 注意：模板类和模板函数都是在使用（即实例化）之后才会编译！不用就不编译。 而不同的实例化编译出的结果也不一样，所以其实是编译器帮你完成了“复制粘贴多个版本”这一步。</p>          </div></li></ol><h1>Lecture10、Lambda Functions</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">abssort</span><span class="hljs-params">(<span class="hljs-type">float</span>* x, <span class="hljs-type">unsigned</span> n)</span> </span>&#123;<br>    std::<span class="hljs-built_in">sort</span>(x, x + n,<br>        <span class="hljs-comment">// Lambda expression begins</span><br>        [](<span class="hljs-type">float</span> a, <span class="hljs-type">float</span> b) &#123;<br>            <span class="hljs-built_in">return</span> (std::<span class="hljs-built_in">abs</span>(a) &lt; std::<span class="hljs-built_in">abs</span>(b));<br>        &#125; <span class="hljs-comment">// end of lambda expression</span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/N5Y3hbXFqJDOmaU.png" alt=""></p><p><strong>捕获列表的作用：</strong></p><ol><li>[ ]是lambda引出符，编译器根据该引出符判断接下来的代码是否是lambda函数</li><li>捕捉上下文中的变量供lambda使用</li></ol><p><strong>捕获列表使用：</strong></p><ul><li>[ ]表示不捕获任何变量</li><li>[var]、[&amp;var]分别表示以值传递和引用传递的方式捕捉变量var</li><li>[=]、[&amp;]分别表示以值传递和引用传递方式捕获所有<strong>父作用域</strong>的变量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">auto</span> function = ([]()<br>&#123;num = <span class="hljs-number">1000</span>;<br>index = <span class="hljs-number">2</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;index: &quot;</span>&lt;&lt; index &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> <br>            &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span>&lt;&lt; num &lt;&lt; std::endl; &#125;);<br><br><span class="hljs-built_in">function</span>();<br><span class="hljs-comment">//报错，因为没去捕获num和index就在使用它们</span><br><br><span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">auto</span> function = ([=]()<br>&#123;num = <span class="hljs-number">1000</span>;<br>index = <span class="hljs-number">2</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;index: &quot;</span>&lt;&lt; index &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> <br>            &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span>&lt;&lt; num &lt;&lt; std::endl; &#125;);<br><br><span class="hljs-built_in">function</span>();<br><span class="hljs-comment">//报错，因为lambda的值引用默认不能修改，要修改的话得加mutable关键字</span><br><br><span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">auto</span> function = ([=]()<span class="hljs-keyword">mutable</span><br>&#123;num = <span class="hljs-number">1000</span>;<br>index = <span class="hljs-number">2</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;index: &quot;</span>&lt;&lt; index &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> <br>            &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span>&lt;&lt; num &lt;&lt; std::endl; &#125;);<br><br><span class="hljs-built_in">function</span>();<br><span class="hljs-comment">//正确，因为加了mutable关键字，值传递变量可修改（但改的也是副本，不影响原值）</span><br><br><span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">auto</span> function = ([&amp;]()<br>&#123;num = <span class="hljs-number">1000</span>;<br>index = <span class="hljs-number">2</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;index: &quot;</span>&lt;&lt; index &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> <br>            &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span>&lt;&lt; num &lt;&lt; std::endl; &#125;);<br><br><span class="hljs-built_in">function</span>();<br><span class="hljs-comment">//正确，引用传递的值可以修改</span><br></code></pre></td></tr></table></figure><p>以上述代码为例，思考Lambda的意义（和普通函数相比）：</p><ol><li><p>省去定义一个完整函数、给函数命名的过程，对于这种<strong>不需要复用</strong>，且<strong>短小</strong>的函数，直接传递函数体可以增加代码的可读性。所以lambda函数又叫“匿名函数”。</p><div class="note note-warning">            <p>💡 PS. 不要小看“省略命名”这件事，表面上看它只是少了个名字，但实质是把它看作一个普通的“操作过程”而非“对象”。就像你会给一个变量、类、函数命名，但不会单独给“把a乘上c的3次方再加123再除321”这种纯过程去命个名（除非这个操作复用率足够高），因为它抽象程度太低，即用即扔。 <strong>而所有值得去命名的东西，都应该是会复用且抽象程度足够的。我认为这是编程中的一种哲学思想。</strong> 如：一个普通操作复用程度足够高时（比较int a、int b大小），就把它抽象为一个函数（max函数）；而这个函数复用率够高时，就进一步抽象为template function</p>          </div></li><li><p>允许函数作为一个对象进行<strong>传递</strong>：lambda也可以命名，然后将其进行传递。这种方式和传统的函数指针比起来更加简明。</p></li><li><p>引入<strong>闭包</strong>：闭包是指将当前作用域中的变量通过值或者引用的方式封装到lambda表达式当中，成为表达式的一部分，它使你的lambda表达式从一个普通的函数变成了一个带隐藏参数的函数。</p></li></ol><p>常见应用场景：</p><ol><li><p><strong>用于stl算法库</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// for_each应用实例</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">2</span>, <span class="hljs-number">33</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-built_in">sort</span>(a, a+<span class="hljs-number">4</span>, [=](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> x%<span class="hljs-number">10</span> &lt; y%<span class="hljs-number">10</span>; &#125; );<br>for_each(a, a+<span class="hljs-number">4</span>, [=](<span class="hljs-type">int</span> x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125; );<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>💡 PS. foreach()这个东西在#include<algorithm>里，是个template function，其前两个参数是begin和end指针</p>          </div></li><li><p><em><strong>*用于多线程场景*</strong></em></p></li><li><p><strong>作为函数的入参</strong></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> FuncCallback = std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">void</span>)&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DataCallback</span><span class="hljs-params">(FuncCallback callback)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Start FuncCallback!&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-built_in">callback</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;End FuncCallback!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">auto</span> callback_handler = [&amp;]()&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;This is callback_handler&quot;</span>;<br>&#125;;<br><br><span class="hljs-built_in">DataCallback</span>(callback_handler);<br></code></pre></td></tr></table></figure><h1>Lecture12、Specical Member Functions(6个)</h1><ol><li><p><strong>介绍：</strong></p><p>C++中类的特殊成员函数有6个，对于一个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123; m_data = data; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>编译器会自动帮我们生成这些特殊成员函数，所以类A的定义等价于如下，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;; <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; other) &#123; m_data = other.m_data; &#125; <span class="hljs-comment">// 拷贝构造函数</span><br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; other) &#123; m_data = other.m_data; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125; <span class="hljs-comment">// 拷贝赋值构造函数</span><br>    ~<span class="hljs-built_in">A</span>() &#123;&#125; <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-built_in">A</span>(A&amp;&amp; other) &#123; m_data = other.m_data; &#125; <span class="hljs-comment">// 移动构造函数</span><br>    A&amp; <span class="hljs-keyword">operator</span>=(A&amp;&amp; other) &#123; m_data = other.m_data; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125; <span class="hljs-comment">// 移动赋值构造函数</span><br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123; m_data = data; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_data;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>拷贝构造函数（copy constructor）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream &gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">double</span> real, imag;<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) &#123;<br>        real= r; imag = i;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">cl</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Complex <span class="hljs-title">c2</span> <span class="hljs-params">(cl)</span></span>;  <span class="hljs-comment">//用拷贝构造函数初始化c2</span><br>    cout&lt;&lt;c2.real&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;c2.imag;  <span class="hljs-comment">//输出 1,2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果用户自己编写了复制构造函数，则默认复制构造函数就不存在了</p></li><li><p><strong>拷贝赋值构造函数（copy assignment constructor）</strong></p><p>对“＝”进行重载，作用是让两个已经初始化完毕的类进行拷贝</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CPP">myclass A,B；<br>A = B；<br></code></pre></td></tr></table></figure></li></ol><div class="note note-warning">            <p>​💡 PS. 上述两个构造函数的应用其实都非常非常广泛 —— 别忘了，stl的容器全都是类！ vector<int>nums1 = nums2也用了拷贝赋值构造函数！</p>          </div><ol start="4"><li><strong>深拷贝与浅拷贝</strong></li></ol><ul><li><p>大部分正常情况下只需要浅拷贝（如基本数据类型、简单的类），int A = B，就是B所在内存中的数据按二进制位（bit）复制到A所在的内存</p></li><li><p>深拷贝用于什么情况捏？假设有某个类有两个实例A、B，类持有**动态分配的内存/指向其他数据的指针，**那此时就不能简单地A = B，否则A中的指针也会指向B中指针对应的内存，这样一来，一修改A，B也会随之被修改，没达到拷贝的效果。</p><p>正确做法是，去显式地定义一个拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，<strong>原有对象和新对象所持有的动态内存是相互独立的</strong>，更改一个对象的数据不会影响另外一个对象。</p></li></ul><div class="note note-warning">            <p>​💡 PS. 如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足矣。</p>          </div><ul><li><strong>深拷贝的开销往往比浅拷贝大</strong>（除非没有指向动态分配内存的属性），所以我们倾向于尽可能使用浅拷贝</li></ul><ol start="5"><li><p><strong>左值、右值</strong></p><ul><li><p>左值（lvalue）：表达式结束后依然存在的持久对象</p></li><li><p>右值（rvalue）：表达式结束后就不再存在的临时对象。字面量（字符字面量除外）、临时的表达式值、临时的函数返还值这些短暂存在的值都是右值。</p></li></ul><p>更直观的理解是：有变量名的对象都是左值，没有变量名的都是右值。（因为有无变量名意味着这个对象是否在下一行代码时依然存在）</p></li></ol><p>​<div class="note note-warning">            <p>​💡 PS. 值得注意的是，字符字面量是唯一不可算入右值的字面量，因为它实际存储在静态内存区，是持久存在的</p><p>​</p>          </div></p><ol start="6"><li><p><strong>右值引用</strong></p><p>右值引用类型 &amp;&amp;用于匹配右值，左值引用&amp;用于匹配左值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//左值引用形参=&gt;匹配左值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::Copy</span><span class="hljs-params">(Vector&amp; v)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;num = v.num;<br>    <span class="hljs-keyword">this</span>-&gt;a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[num];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;++i)&#123;a[i]=v.a[i]&#125;<br>&#125;<br><br><span class="hljs-comment">//右值引用形参=&gt;匹配右值</span><br><span class="hljs-type">void</span> Vector::<span class="hljs-built_in">Copy</span>(Vector&amp;&amp; temp)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;num = temp.num;<br>    <span class="hljs-keyword">this</span>-&gt;a = temp.a;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个对应关系：</p><p>左值 —— 左值引用 —— 深拷贝</p><p>右值 —— 右值引用 —— 浅拷贝</p><p>这和深浅拷贝的定义是相符的，因为右值临时存在，用完就丢，所以就不存在拷贝之后动态分配内存冲突的问题，那就只需要浅拷贝；左值反之</p></li><li><p><strong>强转右值std::move()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    Vector result;<br>    <span class="hljs-comment">//...DoSomething with result</span><br><br>    <span class="hljs-keyword">if</span>(xxx)&#123;ans = result;&#125;  <br><span class="hljs-comment">//现在我希望把结果提取到外部的变量ans上</span><br><br><span class="hljs-comment">//...Do other things without result</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>result赋值给ans后就不再被使用，因此我们期望它调用的是<strong>移动赋值构造函数</strong>。 但是result是一个有变量名的左值类型，因此ans = result 调用的是拷贝赋值构造函数而非移动赋值构造函数</p><p>解决办法：用c++11提供的move强转右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    Vector result;<br>    <span class="hljs-comment">//...DoSomething with result</span><br>   <br><span class="hljs-keyword">if</span>(xxx)&#123;ans = std::<span class="hljs-built_in">move</span>(result);&#125;   <br><span class="hljs-comment">//调用的是移动赋值构造函数</span><br><br><span class="hljs-comment">//...Do other things without result</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>右值引用类型和右值的关系</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; o)</span> </span>&#123;std::cout &lt;&lt; <span class="hljs-string">&quot;为左值。&quot;</span> &lt;&lt; std::endl;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; temp)</span> </span>&#123;std::cout &lt;&lt; <span class="hljs-string">&quot;为右值。&quot;</span> &lt;&lt; std::endl;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span>&amp;&amp; b = <span class="hljs-number">10</span>;<br>  <span class="hljs-comment">//请分别回答：a、std::move(a)、b 分别是左值还是右值？</span><br><span class="hljs-built_in">test</span>(a);<br><span class="hljs-built_in">test</span>(std::<span class="hljs-built_in">move</span>(a));<br><span class="hljs-built_in">test</span>(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>答：a是左值，std::move(a)是右值，但b却是左值。</p><p>在这里b虽然是 int&amp;&amp; 类型，但却因为有变量名（即可持久存在），被编译器认为是左值。</p><p><strong>结论：右值引用类型只是用于匹配右值，而并非表示一个右值。因此，尽量不要声明右值引用类型的变量，而只在函数形参使用它以匹配右值。</strong></p></li><li><p><strong>补充：构造函数之后的冒号</strong></p><p>c++的语法特性，冒号后面跟的是赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb):<span class="hljs-built_in">a</span>(aa), <span class="hljs-built_in">b</span>(bb) &#123;&#125;<br><br><span class="hljs-comment">//相当于</span><br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb)<br>&#123;<br>a=aa;<br>b=bb;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1>Lecture13、RAII and Smartpointer</h1><ol><li><p><strong>motivation</strong></p><p>手动申请动态内存+手动释放会有什么问题呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Person* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(id_number);<br><br><span class="hljs-comment">//do something</span><br><br><span class="hljs-keyword">delete</span> p;<br></code></pre></td></tr></table></figure><p>若在申请完内存之后，do something的过程中用抛出了异常（throw an exception），那就无法执行delete p，从而造成内存泄漏（leak memory）。 此问题还不止是指针，文件的open和close、线程的try_lock和unlock、套接字的socket和close，都是这样的“配套操作”，</p><p>为了解决这个问题，我们可以使用RAII（Resource Acquisition is Initalization）原则，其核心思想是：</p><ul><li><strong>All resources used by a class should be acquired in the constructor</strong></li><li><strong>All resources used by a class should be released in the destructor</strong></li></ul><p>即key idea是利用**“对象的析构是自动完成的”** —— 由于对象在go out of its own scope后，析构函数总是会被自动调用，那么只要遵循上面两点原则，就可以避免内存泄漏了</p></li><li><p><strong>实例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br> <br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000000</span>; i++)<br>&#123;<br><span class="hljs-type">int32_t</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int32_t</span>[<span class="hljs-number">3</span>];<br>ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>ptr[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>ptr[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br><span class="hljs-comment">//delete ptr;     //假设忘记了释放内存</span><br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可想而知会占据极大的内存空间</p><p>我们将其改进为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">auto_release_ptr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">auto_release_ptr</span>(T *t) :<span class="hljs-type">_t</span>(t)&#123;&#125;;<br>~<span class="hljs-built_in">auto_release_ptr</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> <span class="hljs-type">_t</span>;<br>&#125;;<br> <br><span class="hljs-function">T * <span class="hljs-title">getPtr</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">_t</span>;<br>&#125;<br> <br><span class="hljs-keyword">private</span>:<br>T *<span class="hljs-type">_t</span>;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000000</span>; i++)<br>&#123;<br><span class="hljs-keyword">auto</span> arp = <span class="hljs-built_in">auto_release_ptr</span>&lt;<span class="hljs-type">int32_t</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">int32_t</span>[<span class="hljs-number">3</span>]);<br><span class="hljs-type">int32_t</span> *ptr = arp.<span class="hljs-built_in">getPtr</span>();<br>ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>ptr[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>ptr[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>**思路：**将申请的int指针托管给模板类auto_release_ptr，再去声明一个普通int指针指向申请的内存空间（通过接收类成员函数的返回值实现），从而让ptr 与 auto_release_ptr 拥有了相同的生命周期，每次for循环自动析构释放，非常妙。</p></li><li><p><strong>智能指针</strong></p><p><strong>（1）std : : unique_ptr</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//普通指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">raw_ptr_fun</span><span class="hljs-params">()</span></span>&#123;<br>Node* n = <span class="hljs-keyword">new</span> Node;<br><span class="hljs-comment">//do things with n </span><br><span class="hljs-keyword">delete</span> n;<br>&#125;<br><br><span class="hljs-comment">//智能指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">smart_ptr_fun</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-function">std::unique_ptr&lt;Node&gt; <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-keyword">new</span> node)</span></span>;<br><span class="hljs-comment">//do things with n </span><br><span class="hljs-comment">//automatically freed!</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li>无法进行左值的赋值或赋值构造，但允许临时右值赋值构造和赋值（用move语义）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m Li Ming!&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m age 22.&quot;</span>))</span></span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//p1 = p2;// error！禁止左值赋值</span><br><span class="hljs-comment">//unique_ptr&lt;string&gt; p3(p2);// error！禁止左值赋值构造</span><br><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(std::move(p1))</span></span>;<br>p1 = std::<span class="hljs-built_in">move</span>(p2);<span class="hljs-comment">// 使用move把左值转成右值就可以赋值了</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1 = p2 赋值后：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/SjMudQh6KBbCa21.png" alt=""></p><div class="note note-warning">            <p>💡 PS. 在这里也可以看到，把p2 move成临时值之后，一赋值给p1，它就被释放掉了，内存地址为nullptr</p>          </div><ul><li>排它式资源享用：两个指针不能指向同一个资源</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unique_ptr&lt;string&gt; p1;<br>string *str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;智能指针的内存管理陷阱&quot;</span>);<br>p1.<span class="hljs-built_in">reset</span>(str);<span class="hljs-comment">// p1托管str指针</span><br>&#123;<br>unique_ptr&lt;string&gt; p2;<br>p2.<span class="hljs-built_in">reset</span>(str);<span class="hljs-comment">// p2接管str指针时，会先取消p1的托管，然后再对str的托管</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p2:&quot;</span> &lt;&lt;  *p2 &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 此时p1已经没有托管内容指针了，为NULL，在使用它就会内存报错！</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p1:&quot;</span> &lt;&lt; *p1 &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/R8OfldcxjaFIHEV.png" alt=""></p><p><strong>（2）std : : shared_ptr</strong></p><p><strong>idea:</strong> 记录引用特定内存对象的智能指针数量，当复制或拷贝时，<strong>引用计数加1</strong>，当智能指针析构时，<strong>引用计数减1</strong>，如果计数为零，代表已经没有指针指向这块内存，那么我们就释放它</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;构造函数 \\t &quot;</span> &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数 \\t &quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>shared_ptr&lt;Person&gt; sp1;<br><br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Person())</span></span>;<br><br><span class="hljs-comment">// 获取智能指针管控的共享指针的数量use_count()：引用计数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;sp1use_count() = &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2use_count() = &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl &lt;&lt; endl;<br><br><span class="hljs-comment">// 共享,即sp1和sp2共同托管同一个指针</span><br>sp1 = sp2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;sp1use_count() = &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2use_count() = &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl &lt;&lt; endl;<br><br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(sp1)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp1use_count() = &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2use_count() = &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2use_count() = &quot;</span> &lt;&lt; sp3.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/cK9a5qX7MnjQHlv.png" alt=""></p><p><strong>（3）std : : weak_ptr</strong></p><p>​TO-DO</p></li><li><p><strong>智能指针初始化方式</strong></p><p>常规初始化方式有两种：显式调用new、使用make_unique()函数</p></li></ol><p><img src="https://s2.loli.net/2023/04/14/dIVEwpKhf47G5aH.png" alt=""></p><p><strong>Q:</strong> Which is better？</p><p><strong>A:</strong> std : : make_unique和std : : make_shared更好，因为<strong>显式调用new会分配两次内存</strong>（一次给up，一次是new T）</p><hr><h1>Assignment：HashMap</h1><ol><li><p><strong>using关键字</strong></p><p>可用于设置别名，功能类似于typedef</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> value_type = std::pair&lt;<span class="hljs-type">const</span> K, M&gt;;<br></code></pre></td></tr></table></figure></li><li><p><strong>explicit关键字</strong></p><p>修饰class的constructor，令其只能显式声明，不能隐式转换or赋值初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bucket_count, <span class="hljs-type">const</span> H&amp; hash = H())</span></span>;<br> <br><span class="hljs-function">HashMap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">map</span><span class="hljs-params">(<span class="hljs-number">1.0</span>)</span></span>;  <span class="hljs-comment">// double -&gt; int conversion not allowed.</span><br>HashMap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map = <span class="hljs-number">1</span>;   <span class="hljs-comment">// copy-initialization, does not compile.</span><br></code></pre></td></tr></table></figure></li><li><p><strong>成员函数末尾加const —— 常成员函数</strong></p><p>const成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要目的还是保护数据。通常将 get类型的函数（get_value、get_size。。）设置为常成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><p>​</p><div class="note note-warning">            <p>💡 PS.</p><ol><li>需要强调的是，必须在成员函数的声明和定义处同时加上 const 关键字。<code>char *getname() const</code>和<code>char *getname()</code>是两个不同的函数原型，如果只在一个地方加 const 会导致声明和定义处的函数原型冲突。</li><li>区分一下 const 的位置：<ul><li>函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如<code>const char * getname()</code></li><li>函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如<code>char * getname() const</code></li></ul></li></ol>          </div></li><li><p><strong>noexcept关键字</strong></p><p>程序员在语义层面声明“我保证这个函数不会异常，编译器你不用检查了”，之后编译器就不会对该函数进行异常检查，也没办法实施try-catch操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_not_throw</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// noexcept函数中本不应有throw，没意义，但编译器不会检查是否有throw</span><br><span class="hljs-comment">// 所以编译通过，不会报错（可能会有警告）</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">func_not_throw</span>(); <span class="hljs-comment">// 直接 terminate，不会被 catch</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;catch int&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>注意：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTest</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;const&quot;</span> &lt;&lt; endl;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;normal&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CTest a;<br>a.<span class="hljs-built_in">show</span>();<br> <br><span class="hljs-type">const</span> CTest b;<br>b.<span class="hljs-built_in">show</span>();<br> <br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/48HvQ9oENy1ksPd.png" alt=""></p><p>这两个show函数可不是重载！**重载函数的形参必须不同！！**这俩就不是同一个函数原型（因为加了const，是常成员函数）</p><p>那么调用的时候如何区分这俩捏？</p><p>它们各自被调用的时机为：<strong>如果定义的对象是常对象，则调用的是const成员函数，如果定义的对象是非常对象，则调用重载的非const成员函数。</strong></p><div class="note note-warning">            <p>💡 PS. 不过从另一个角度来理解，也可以把它俩看成重载 —— 首先理解下函数签名：它包含着一个函数的信息，包括**函数名、参数类型、参数个数、顺序以及它所在的类和命名空间，**两个函数只有在签名不同时才能被区分。<br>那上面两个show( )的签名到底哪里不同了捏？ 答案是参数类型，每个成员函数的参数中其实自带this指针，只不过藏起来了，谁调用成员函数，this 就指向谁。<strong>而成员函数尾巴上的const，实质修饰的是this指针！</strong> 当a调用show方法时，函数签名为show(a){}，即a传给this指针，一看，诶！a为非常对象，对应普通this指针，即非const版本的show()；b同理。</p>          </div></li><li><p><strong>typename关键字作用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Map, <span class="hljs-type">bool</span> IsConst&gt;<br><span class="hljs-keyword">typename</span> HashMapIterator&lt;Map, IsConst&gt;::reference HashMapIterator&lt;Map, IsConst&gt;::<span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> _node-&gt;value; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>作为类型声明，效果完全等同于class —— 代码中的typename Map等同于class Map，它俩都是告诉编译器，“我后面跟着的这个是个类型名称，而不是成员变量或成员函数”。（这好像也能映证“模板函数在实例化后才会被编译”）</p></li><li><p>作为<strong>修饰关键字：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; proto)</span></span>&#123;<br>    <span class="hljs-function">T::const_iterator <span class="hljs-title">it</span><span class="hljs-params">(proto.begin())</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>**motivation：**虽然人类编程者一眼就知道const_iterator是个类型名称，但编译器不知道呀，万一它是个变量呢？在模板实例化之前，完全没有办法来区分它们，所以这个写法是会error的！ 怎么办捏？ 这时候就需要使用typename关键字来修饰，编译器才会将该名称当成是类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typename</span> T::const_iterator <span class="hljs-title">it</span><span class="hljs-params">(proto.begin())</span></span>;<br></code></pre></td></tr></table></figure><p>这样编译器就可以确定T: :const_iterator是一个类型，而不再需要等到实例化时期才能确定，因此消除了前面提到的歧义。</p><div class="note note-warning">            <p>💡 PS. 总结：同时使用模板类T和域解析符: : 时，就得加typename</p>          </div></li></ul></li><li><p>模板类中的成员函数（往往也是模板函数）的具体实现通常也会放在.h中，除非函数太多太长</p></li><li><p>两个指针相减 = 两指针的地址差值/sizeof(数据类型)，即得到的结果就是两指针之间间隔的元素个数</p><p>注意： 不需要人为手动去除sizeof哈！减号自动会完成这个操作（c和cpp中都是）</p></li><li><p><strong>运算符重载</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//秒表类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">stopwatch</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">stopwatch</span>(): <span class="hljs-built_in">m_min</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">m_sec</span>(<span class="hljs-number">0</span>)&#123; &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setzero</span><span class="hljs-params">()</span></span>&#123; m_min = <span class="hljs-number">0</span>; m_sec = <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function">stopwatch <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 运行</span><br>    stopwatch <span class="hljs-keyword">operator</span>++();  <span class="hljs-comment">//++i，前置形式</span><br>    stopwatch <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> n);  <span class="hljs-comment">//i++，后置形式</span><br>    <span class="hljs-keyword">friend</span> ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream &amp;, <span class="hljs-type">const</span> stopwatch &amp;);<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_min;  <span class="hljs-comment">//分钟</span><br>    <span class="hljs-type">int</span> m_sec;  <span class="hljs-comment">//秒钟</span><br>&#125;;<br><br><span class="hljs-function">stopwatch <span class="hljs-title">stopwatch::run</span><span class="hljs-params">()</span></span>&#123;<br>    ++m_sec;<br>    <span class="hljs-keyword">if</span>(m_sec == <span class="hljs-number">60</span>)&#123;<br>        m_min++;<br>        m_sec = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>stopwatch stopwatch::<span class="hljs-keyword">operator</span>++()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">run</span>();<br>&#125;<br><br>stopwatch stopwatch::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> n)&#123;<br>    stopwatch s = *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-built_in">run</span>();<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;( ostream &amp; out, <span class="hljs-type">const</span> stopwatch &amp; s)&#123;<br>    out&lt;&lt;<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>)&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>)&lt;&lt;s.m_min&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>)&lt;&lt;s.m_sec;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stopwatch s1, s2;<br><br>    s1 = s2++;<br>    cout &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span>&lt;&lt; s1 &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;s2: &quot;</span>&lt;&lt; s2 &lt;&lt;endl;<br>    s1.<span class="hljs-built_in">setzero</span>();<br>    s2.<span class="hljs-built_in">setzero</span>();<br><br>    s1 = ++s2;<br>    cout &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span>&lt;&lt; s1 &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;s2: &quot;</span>&lt;&lt; s2 &lt;&lt;endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++运算符重载，本质上等于定义一个成员函数(实际上也可能是全局函数)。例如a+b，本质上等同于调用函数**「a.operator+(b)」**，该函数的名字叫「operator+」 ++的重载分为前置和后置情况，a = ++b;(前置)， a = b++;(后置)。因为符号一样，所以给后置版本加一个int形参作为区分，这个形参是0，但是在函数体中是用不到的，只是为了区分前置后置。 至于为啥加了个形参就能区分前后缀，没想懂，也没查到资料</p></li><li><p><strong>this指针</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br>HashMap&lt;K, M, H&gt;::~<span class="hljs-built_in">HashMap</span>() &#123;<br>    <span class="hljs-built_in">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用clear()用不用加this指针？ 答案是可加可不加，编译器都会隐式调用</p><p>Q: 什么时候this指针是必不可少的捏？</p><p>A: 当你在对象方法里需要<strong>明确</strong>使用自己的时候，比如区分同名的形参和成员变量</p></li><li><p>当一个函数的返回值为引用类型时，<strong>不要return 某个在stack上的变量的引用！</strong>（否则该函数一退出，stack就释放，引用就掉了）</p></li><li><p><strong>遍历类的实例化对象（自定义类的迭代器）</strong></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> HashMap&lt;K, M, H&gt;&amp; lhs, <span class="hljs-type">const</span> HashMap&lt;K, M, H&gt;&amp; rhs) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [key, mapped] : lhs)&#123;<br>        。。。<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Q: lhs是自定义的HashMap类，其成员变量不只是装有&lt;key, mapped&gt;的链表，还有各种int size、int load_factor等属性啊，为啥可以直接用 : 进行range based for loop捏？或者说，为啥只会循环到想要的链表，而不会访问其它成员变量捏？</p><p>A: 之所以会有上述误区，<strong>是因为把range based循环当成了编译器内置运算符，事实上是自己要为该类定义一个iterator类！</strong></p><p>range based的 : 符号只是一种简略写法，它的源码实现大概为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> ( range_declaration : range_expression) loop_statement<br>&#123;  <br>    <span class="hljs-keyword">auto</span> &amp;&amp; __range = range_expression ;   <br>    <span class="hljs-keyword">auto</span> __begin = <span class="hljs-built_in">begin_expr</span>(__range);   <br>    <span class="hljs-keyword">auto</span> __end = <span class="hljs-built_in">end_expr</span>(__range);   <br>    <span class="hljs-keyword">for</span> (;__begin != __end; ++__begin) &#123;  <br>        range_declaration = *__begin;   <br>        loop_statement   <br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p>由此可见，自定义的iterator类至少要有5个功能：</p><ul><li>begin( )</li><li>end( )</li><li>重载++、*、! =三个运算符</li></ul><p>其中begin( )、end( )返回类型就是iterator</p><p>现在就可以理解为啥可用range based循环获取自定义类中想要的数据了 —— iterator功能全是用户自己定义的，想获取啥就获取啥捏</p><ol start="13"><li><strong>Q: 右值引用的类对象的属性也是右值吗？</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//移动构造函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br>HashMap&lt;K, M, H&gt;::<span class="hljs-built_in">HashMap</span>(HashMap&amp;&amp; rhs):<br>    _size&#123;rhs._size&#125;,<br>    _hash_function&#123;rhs._hash_function&#125;,<br>    _buckets_array&#123;rhs.<span class="hljs-built_in">bucket_count</span>(), <span class="hljs-literal">nullptr</span>&#125; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">bucket_count</span>(); i++)&#123;<br>        _buckets_array[i] = rhs._buckets_array[i];<br>        rhs._buckets_array[i] = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    rhs._size = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>A: 将类对象用move()强转为右值，并不影响类中成员变量的左右值属性，该是啥还是啥</p><ol start="14"><li><p><strong>对上面这个问题的进一步深层理解：</strong></p><p>Q: 被move()过的变量会被编译器自动给销毁吗？如果会，那为啥还要手动让rhs._buckets_array[i] 指向nullptr？如果不会，那强转右值有啥意义啊？</p><p>A: 变量会被怎么处理，与它是否被move()过没半毛钱关系，<strong>move()并不改变变量本身，只是额外提供了一个return的右值</strong>，这一点看源码即可明白</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// FUNCTION TEMPLATE move</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function"><span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(_Ty&amp;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);<br>&#125;<br><span class="hljs-comment">//只是把返回值用static_cast强制转换成右值，但传入的原变量该是啥还是啥</span><br></code></pre></td></tr></table></figure><p>那move()的意义是啥捏 —— <strong>多提供一种数据类型，用于重载函数的形参匹配</strong>。 说白了，就是<strong>手动帮助编译器选择重载函数，同时向编译器发誓再也不碰这个对象</strong>！ 那这个作用的motivation又是啥捏 —— 若没有右值引用，那拷贝函数就要分成deep_copy()和shallow_copy()两个版本来写，且每次都要手动显式调用 —— 这既麻烦，又容易出错；但利用重载写成copy(const T&amp; val)和copy(T&amp;&amp; val)后，就可以让编译器自动调用。而若用户自己发现，诶！这个指针a虽然是左值，但我之后不用了，可以直接浅拷贝，ok，那用move()强转一次即可，即所谓的“手动帮编译器选择重载函数”。 回到一开始的问题，经move()的变量会被销毁咩？ 那得看移动构造函数/移动赋值构造函数是咋实现的：在上面HashMap的那个移动构造函数中，手动释放了指针并让size清零（这也是符合实际写代码的思路的，既然认定了“这个对象不会再碰”，那就应该释放它，留着既占空间、又有修改内存的风险）；反之，如果移动构造函数中没释放右值，那它就原封不动地在那儿 —— 说到底，还是<strong>与变量是左值/右值本身没半毛钱关系，而是取决于SMF中怎么去处理这个变量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; val)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;value: &quot;</span> &lt;&lt; val&lt;&lt; <span class="hljs-string">&quot;, type: 左值&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;&amp; val)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;value: &quot;</span> &lt;&lt; val&lt;&lt; <span class="hljs-string">&quot;, type: 右值&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-built_in">move</span>(a);<br>    <span class="hljs-built_in">test_fun</span>(a); <span class="hljs-comment">//a没有被销毁</span><br>    <span class="hljs-built_in">test_fun</span>(b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/H3Y1s7jSPFquXCK.png" alt=""></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>核心科技看美帝</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>斯坦福</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《CS61C笔记》</title>
    <link href="/2023/04/14/%E3%80%8ACS61C%E7%AC%94%E8%AE%B0%E3%80%8B/"/>
    <url>/2023/04/14/%E3%80%8ACS61C%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>课程来源：UCB-CS61C(20 summer)</p><p>课程介绍：<a href="https://github.com/qlhhahaha/CS61C-SU20">https://github.com/qlhhahaha/CS61C-SU20</a></p>          </div><h1>《CS61C笔记》@qlhhahaha</h1><hr><h3 id="Q-C-完全兼容C，为什么C还有单独存在的必要？">Q: C++完全兼容C，为什么C还有单独存在的必要？</h3><h3 id="A">A:</h3><h3 id="一、大道至简，多并非好：用更少的资源做同样的事（单片机、底层芯片资源有限）">一、大道至简，多并非好：用更少的资源做同样的事（单片机、底层芯片资源有限）</h3><h3 id="二、跨平台兼容性：仅有C能做到完美跨平台（这也是因为它简单，C-版本太多、标准协议都不统一，老一点的机器可能根本就不支持C17甚至C11等现代语法）">二、跨平台兼容性：仅有C能做到完美跨平台（这也是因为它简单，C++版本太多、标准协议都不统一，老一点的机器可能根本就不支持C17甚至C11等现代语法）</h3><h3 id="三、C-太难，人力成本高，学习陡峭、维护困难">三、C++太难，人力成本高，学习陡峭、维护困难</h3><h3 id="（新增：四、两种语言在实际应用中的使用思路其实差异非常大，C编程者写C-只能写出C-with-class，属于有了大炮还用棒棒戳；C-者写C会发现技能全被封印，不知如何用平A打boss——总之一句话，让剑宗和气宗各自去做自己的事吧）">（新增：四、两种语言在实际应用中的使用思路其实差异非常大，C编程者写C++只能写出C with class，属于有了大炮还用棒棒戳；C++者写C会发现技能全被封印，不知如何用平A打boss——总之一句话，让剑宗和气宗各自去做自己的事吧）</h3><h1>Lecture4、C Memory Management</h1><ol><li>sizeof( )可以查看数组的大小，但不能查看指针所指区域的大小（但这仍然不应成为一种普遍用法，更好的做法是使用两个参数：数组指针和数组长度）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">61</span>] ;<br><span class="hljs-type">int</span>* ptr = a;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the size of a is: %d, ptr is %d&quot;</span>, <span class="hljs-keyword">sizeof</span>(a), <span class="hljs-keyword">sizeof</span>(ptr))<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/KyR5fEG2k4iWZjo.png" alt=""></p><ol start="2"><li>一种常见的内存泄漏bug —— 改变指针却未留副本</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">plk = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>...<br>plk++;<br></code></pre></td></tr></table></figure><h1>Lecture6、Assembly Language, RISC-V Intro</h1><ol><li><strong>主流架构</strong></li></ol><p><img src="https://s2.loli.net/2023/04/14/t67yLVeOrbdn9z2.png" alt=""></p><ul><li>**x86：**属于CISC(complex instruction set computer)，intel和AMD都使用x86架构，MacBook和pc(Core i3, i5, i7, M)皆使用x86指令集</li><li>**ARM：**属于RISC(reduced instruction set computer)，用于智能手机、树莓派、嵌入式系统</li><li>**risc-V：**属于RISC，新兴架构，最大优点是开源，常用于云计算、物联网等</li></ul><ol start="2"><li><strong>memory hierarchy</strong></li></ol><p><img src="https://s2.loli.net/2023/04/14/VH4ydbQIkExq7zZ.png" alt=""></p><ol start="3"><li><p><strong>riscv简介</strong></p><p>共32个寄存器，有些用于存编程中的变量，有些用于存临时变量</p><p><img src="https://s2.loli.net/2023/04/14/4O7d1hY6rEVZkRH.png" alt=""></p><p><strong>基本语法：</strong></p><p><img src="https://s2.loli.net/2023/04/14/TtZaqi3FPbB8Swk.png" alt=""></p><p><strong>数据传输指令：</strong></p><ul><li>Load Word（lw）：读内存，即memory 到register</li><li>Store Word（sw）：反之</li></ul><p><img src="https://s2.loli.net/2023/04/14/F6iyTX91EgADKzV.png" alt=""></p><p><strong>内存读写指令：</strong></p><ul><li>lb：lb rd,imm(rs) —— 从内存 imm+rs 处读取8bit数据(符号拓展)到 rd 中</li><li>sb：sb rs2,imm(rs1) —— 将rs2中的8bit数据写入内存imm+rs1处</li></ul><p><img src="https://s2.loli.net/2023/04/14/WaCwBDVMZFRTnUS.png" alt=""></p></li></ol><div class="note note-warning">            <p>💡 PS.</p><ol><li>riscv采用的是小字节序，即对于s0，第一个字节存80，第二个存01这样子</li><li>offset的单位是字节</li><li>因为lb只读写8个bit，而riscv是32位架构，所以要进行符号拓展。如给s2中读入0x80，即1000 0000，拓展后s2的前24位就都变成了F</li><li>也有其它的读写指令，如lw和sw是读写32bit数据</li></ol>          </div><p>​<strong>控制指令：</strong></p><p><img src="https://s2.loli.net/2023/04/14/iqQIOF7pmfMrJR9.png" alt=""></p><ul><li>beq：相等则跳</li><li>bne：not equal</li><li>blt：branch less than</li><li>bge：branch greater than</li><li>jal（jump and link）：jal rd,label指令的下一条指令地址存入rd,跳转到label</li></ul><p>​<strong>比较指令：</strong></p><p><img src="https://s2.loli.net/2023/04/14/LP9hcsIFHp67Cm5.png" alt=""></p><h1>Lecture7、RISC-V Functions</h1><ol><li><p><strong>位数拓展</strong></p><p>拓展符号位即可，即正数补充0，负数补充1</p><p><img src="https://s2.loli.net/2023/04/14/PRQYrc2WsikVbDe.png" alt=""></p></li><li><p><strong>函数</strong></p><p><img src="https://s2.loli.net/2023/04/14/ieJP4dKS5mn3faZ.png" alt=""></p><p>其中jal的参数ra是x1寄存器，存放函数返回地址（return address）</p><p>而伪指令j等效于jal x0 label，由于x0恒为0且无法更改，所以相当于只跳转而不记录返回地址；</p><p>jr等效于jalr x0,0(rs)，(rs+imm)位置的内存到x0（实际无效），并跳转到rs寄存器保存的地址</p><div class="note note-warning">            <p>💡 PS. jal和j都是用label跳转；jr是用寄存器跳转</p>          </div></li></ol><h1>Lecture8、RISC-V Instruction Formats</h1><ol><li><p><strong>汇编代码转换为二进制代码：</strong></p><p>思路：将一条汇编语句分为各个field，每个field占据一定的位长，表示特定含义（一条汇编语句占据32bit）</p><p>如R-Format语句：输入3个寄存器（add、mul等）</p><p><img src="https://s2.loli.net/2023/04/14/p3OV82MSdCsLbn6.png" alt=""></p><p>寄存器的field都是5bit，正好可以表示32个寄存器</p></li></ol><h1>Lecture10、digital logic</h1><ol><li><strong>布尔代数运算</strong></li></ol><p><img src="https://s2.loli.net/2023/04/14/bgfhmUysV6zwXRJ.png" alt=""></p><ol start="2"><li><strong>数电系统有两种基本类型：</strong></li></ol><ul><li><p>**combinational logic（CL）：**输出仅仅是输入的函数，与历史状态无关（如cpu中的加法运算器）</p></li><li><p>**sequential logic（SL）：**与历史状态有关（如memory and registers）</p></li></ul><h1>Lecture12、RISC-V Datapath, Single-Cycle Control Intro</h1><ol><li><p><strong>cpu执行汇编语句的硬件实现</strong></p><p>**版本1.0：**实现R-type语句（以add t0 t2 t3为例）</p><p><img src="https://s2.loli.net/2023/04/14/xiFk6514aodpylg.png" alt=""></p><p>(1) 获取汇编指令：在PC寄存器中获取当前指令的地址，将指令内容传给IMEM（instruction memory），同时加4byte返回给PC（即下一条指令的地址）</p><p>(2) 将指令分段成各个field</p><p>(3) 将寄存器地址传给寄存器堆（register file），获取寄存器中的值</p><p>(4) 将获取的值传给运算器ALU，并由控制位ALUSel(ect)决定采用哪种运算（add、sub、xor。。）</p><p>(5) ALU输出运算结果并将值return给register files</p><p>**版本2.0：**实现loads类型语句（lb、sb）</p><p><img src="https://s2.loli.net/2023/04/14/7XGujUOA5wZpdix.png" alt=""></p><p>说明：</p><p>（1）多了一个immediate generator，用于生成立即数，再在01选择器处进行选择，即add和addi的区别</p><p>（2）多了一个data memory，用于执行loads类型的指令（在内存中读写数据），其中MemRW（memory read and write）用于选择读/写：为0时读数据，将Addr处的数据输出；为1时写数据，将输入的数据存到Addr处的内存中</p><p><img src="https://s2.loli.net/2023/04/14/jSRNUOicTJhrd4B.png" alt=""></p><p>**版本3.0：**实现分支控制语句（beq、blt）</p><p><img src="https://s2.loli.net/2023/04/14/asl3DvzpPGjbSAc.png" alt=""></p><p>说明：多了分支控制模块，将DataA和DataB进行比较，根据结果将下面BrUn几个控制位设为0/1，再用ASel控制01选择器，使ALU的输出为要跳转的地址，return给PC</p></li></ol><p>​**最终版本：**实现跳转语句</p><p><img src="https://s2.loli.net/2023/04/14/1rKli23jMkvx87Z.png" alt=""></p><h1>Lecture13、RISC-V Single-Cycle Control and Pipelining</h1><ol><li><p><strong>控制器设计</strong></p><p>以PCSel为例，默认输出0，仅当opcode为branch语句（63）或jump语句（67或6f）时才会输出1，则在mux中选择ALU输出</p><p><img src="https://s2.loli.net/2023/04/14/IURA27kP5EHxicZ.png" alt=""></p></li><li><p><strong>控制器结构</strong></p><p>观察上面的CPU结构可知，控制器一共有三个输入，其余的皆是输出</p><p>实际中由ROM实现控制器</p><p><img src="https://s2.loli.net/2023/04/14/m7x2VWFOSo1rshY.png" alt=""></p></li><li><p><strong>pipeline</strong></p><p>**motivation：**单条指令运行时，大部分版块都处于空闲状态，</p><p><img src="https://s2.loli.net/2023/04/14/wWYksDqCdZnixHG.png" alt=""></p><p><strong>cpu性能表现：</strong></p><p><img src="https://s2.loli.net/2023/04/14/spvkcf2x5ITZz9Y.png" alt=""></p><p>（1）每个程序的指令数取决于：</p><ul><li>程序算法的时间复杂度</li><li>编程语言</li><li>编译器</li><li>ISA</li></ul><p>（2）每条指令要执行多少个cpu循环</p><ul><li>指令复杂程度</li></ul><p>（3）每个cpu循环所耗费的时间</p><ul><li>cpu设计</li><li>电子参数（晶体管尺寸、电压大小）</li></ul><p><strong>流水线技术：</strong></p><p><img src="https://s2.loli.net/2023/04/14/6DrgXQPSoFdTafs.png" alt=""></p> <div class="note note-warning">            <p>💡 PS. 流水线中，单个板块的耗时由短板决定</p>          </div></li></ol><p><img src="https://s2.loli.net/2023/04/14/kOFKpimAJRhWtNu.png" alt=""></p><p>​<strong>riscv的5段流水线</strong><br><img src="https://s2.loli.net/2023/04/14/hRSsPQYO7Jpzu12.png" alt="Untitled"></p><h1>Lecture14、RISC-V 5-Stage Pipeline</h1><ol><li><p>流水线设计也会带来一些问题：</p><p>**结构性问题：**抢占资源，如两条指令同时需要用到RegFile</p><p>解决思路：</p><ul><li>让读/写端口相互独立</li><li>在一个时钟周期的前半部分写数据，后半部分读数据（这在理论上是可行的，因为RegFile的access time远低于时钟周期的一半）</li></ul><p><img src="https://s2.loli.net/2023/04/14/wNPK5C8cMFSGinW.png" alt=""></p><p>**数据更新问题：**一个典型案例，多条语句都要对t0进行修改，但第一次还没生效，后面几次就开始用了</p><p><img src="https://s2.loli.net/2023/04/14/qfBl9nzE2GigCsW.png" alt=""></p><p>解决思路：</p><ul><li>贮存：加入一些空指令进行拖延，确保上一条指令的结果写入后，下一条指令才开始读取</li></ul><p><img src="https://s2.loli.net/2023/04/14/H6gGC5djiPaKeyW.png" alt=""></p><ul><li>转发：结果算出后立马传输给之后的ALU，而不是从RegFile中读取</li></ul><p><img src="https://s2.loli.net/2023/04/14/8ATpVMf9w7khNyb.png" alt=""></p><p><strong>分支控制问题：</strong>”等待branch语句产生结果“这一行为会带来巨大的延迟，如所谓的流水线打嗝（pipeline hiccup）产生气泡（bubble），为此我们可以使用**分支预测（branch prediction）**来解决这个问题。</p><p>先来看一段代码，在一个大小为32768的数组中随机、均匀地放入0~255的数字，再去统计数组中＞128的数的总和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 随机产生整数，用分区函数填充，以避免出现分桶不均</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> arraySize = <span class="hljs-number">32768</span>;<br>    <span class="hljs-type">int</span> data[arraySize];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> c = <span class="hljs-number">0</span>; c &lt; arraySize; ++c)<br>        data[c] = std::<span class="hljs-built_in">rand</span>() % <span class="hljs-number">256</span>;<br><br>    <span class="hljs-comment">// !!! 排序后下面的Loop运行将更快</span><br>    std::<span class="hljs-built_in">sort</span>(data, data + arraySize);<br><br>    <span class="hljs-comment">// 测试部分</span><br>    <span class="hljs-type">clock_t</span> start = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i)<br>    &#123;<br>        <span class="hljs-comment">// 主要计算部分，选一半元素参与计算</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> c = <span class="hljs-number">0</span>; c &lt; arraySize; ++c)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (data[c] &gt;= <span class="hljs-number">128</span>)<br>                sum += data[c];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">double</span> elapsedTime = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-built_in">clock</span>() - start) / CLOCKS_PER_SEC;<br><br>    std::cout &lt;&lt; elapsedTime &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于有序数组：</p><p><img src="https://s2.loli.net/2023/04/14/YbFymqfUp5kreCM.png" alt=""></p><p>而对于无序数组：</p><p><img src="https://s2.loli.net/2023/04/14/NfwLXZRz7yISuW5.png" alt=""></p><p>上述耗时差异由分支预测导致，而实际中的分支预测常由历史数据决定。对于有序数据，前一半皆＜128，处理器很容易找出其中的pattern；无序数组则相当于瞎蒙，只有50%的命中率</p><p><img src="https://s2.loli.net/2023/04/14/kSy1c4aegBpC8NE.png" alt=""></p><div class="note note-warning">            <p>💡 PS. 这个例子给我们启示: 在大规模循环逻辑中要尽量避免数据强依赖的分支(data-dependent branching).</p>          </div><p>分支预测的策略大致可以分为两种：静态预测和动态预测</p><p>**静态预测：**固定的预测策略，如”≥指令一律跳，＜一律不跳“、”与上次taken保持一致“，这类策略简单易实现且能耗小，也可以保持不错的正确率（70%以上），对性能要求不是特别高但又要低功耗低成本的系统可以使用</p><p>**动态预测：**如2-bit 状态机： 初始值为00，每当一个branch taken就+1，branch没有taken则-1。根据第一位的值来进行预测，例如11预测taken，01预测 not taken。 用一个2bit状态机的核心思路就是：<strong>这次预测错了不要紧，再给你一次机会，还是预测错了的话那再改变预测结果</strong>。总之就是提供了一定的容错率，可想而知这样的预测准确率自然也是提高了的。</p></li></ol><h1>Lecture15-17、 Cache</h1><ol><li><strong>典型内存分级</strong></li></ol><p><img src="https://s2.loli.net/2023/04/14/jL2HfckoJCMQ5NX.png" alt=""></p><p>​cache用static RAM：更快（1ns），但功耗更高也更贵，通电时内容一直在</p><p>​主存用dynamic RAM：更便宜也更慢（70ns），定时更新内容</p><ol start="2"><li><p>**两个基本原理：**时间局部性（如果一个地址被访问了一次，那么它接下来还可能被访问很多次）与空间局部性（如果一个地址被访问了一次，那么它周围的内存也可能被访问，如数组）</p></li><li><p><strong>以直接映射（direct mapping）为例，完整叙述cache工作过程</strong></p><p>假设cache大小64bytes，分为8个cache line（或称cache block），则每个line大小为8bytes</p> <div class="note note-warning">            <p>💡 PS. cache line是cache和主存之间传输数据的最小单位，line 大小一般设为word的整数倍（4byte、8byte这样子），很少会做成1byte，为什么捏？见下文分析</p>          </div><p><img src="https://s2.loli.net/2023/04/14/DyBX4L6cQtol7s5.png" alt=""></p><p>假设地址位宽为48bit，cpu现在要在地址为0x0654空间中读数据，那么如图，首先通过黄色部分的010（称之为<strong>index</strong>）<strong>找到对应位置的cache line</strong>（这个过程可以称之为一次hash），但光找到line还不够，因为如果两个不同地址的bit3-bit5一样的话，经过hash后都会找到同一个cache line。 下一步是比较绿色的tag——<strong>每一个cache line都对应唯一一个tag</strong>，tag中保存的是整个48bit地址除去index和offset后的剩余部分。若地址的tag和line对应的tag相等，则说明cache确实把内存中前45位地址为00….011001010xxx的那8byte空间全搞进来了，即cache hit。ok，那么接下来只需要通过<strong>蓝色的offset就可在line中找到具体的那个byte</strong>；若tag不相等，则cache miss。这也解答了我们之前的一个疑问“为啥cache line不做成一个byte”，因为原本8byte对应一个tag，现在需要8个tag，占用太多空间（tag也是cache的一部分，但我们谈到cache size的时候并不考虑tag占用的内存部分）。 图中还可以看到tag旁的valid bit，它用来表示cache line中的数据是否有效，如系统刚启动时，cache中的数据应该都是无效的，因为还没有缓存任何数据。所以实际中比较tag前还会检查valid bit是否有效，无效则直接判定cache miss。</p> <div class="note note-warning">            <p>💡 PS. 体会一下上述查找cache的过程，会发现虽然看起来有点复杂，但本质上就是个通过地址找对应数据的过程——先判断cache中是否有这前45位地址，有的话直接往后找我要的那个数据，没有的话cache miss</p>          </div><p>直接映射优点：硬件设计简单、成本低 缺点：程序依次访问0x00、0x40、0x80（这3个地址的index一样的）时，首先访问第0个line，再访问0x40地址时依然会检索到第0个，然后发现数据缺失，于是从主存中加载0x0地址数据到第一个line，0x80亦是如此，所以此时cache的存在并没有对性能有啥提升，这种连续加载替换cache的现象叫做<strong>cache颠簸（cache thrashing）</strong>，针对这个问题我们引入多路组相连缓存</p></li><li><p><strong>两路相连缓存（two-way set associative cache）</strong></p><p>依然假设64 Bytes cache size，cache line size是8 Bytes。两路组相连缓存就是将cache平均分成2份，每份32 Bytes。</p><p><img src="https://s2.loli.net/2023/04/14/g4pRkofIhutGd7x.png" alt=""></p><p>cache被分成2路，每路包含4行cache line。我们将所有index一样的cache line组合在一起称之为一个set。例如，上图中一个组有两个cache line，总共4个组。我们依然假设从地址0x0654地址读取一个字节数据。由于cache line size是8 Bytes，因此offset需要3 bits，这和之前直接映射缓存一样；不一样的地方是index，在两路组相连缓存中，index只需要2 bits，因为一路只有4行cache line。上面的例子根据index找到第2行cache line（从0开始计算），第2行对应2个cache line，分别对应way 0和way 1。因此index也可以称作set index（组索引）。先根据index找到set，然后将组内的所有cache line对应的tag取出来和地址中的tag部分对比，如果其中一个相等就意味着命中。 因此，两路组相连缓存较直接映射缓存最大的差异就是：第一个地址对应的数据可以对应2个cache line，而直接映射缓存一个地址只对应一个cache line</p></li><li><p><strong>全相连缓存(Full associative cache)</strong></p><p>进一步把所有的cache line放在一个组里，称之为全相连缓存</p><p><img src="https://s2.loli.net/2023/04/14/Eefgy3G5dYlxDtH.png" alt=""></p><p>由于所有的cache line都在一个组内，因此地址中不需要set index部分。因为，只有一个组让你选择，也就是没得选。我们根据地址中的tag部分和所有的cache line对应的tag进行比较（硬件上可能并行比较也可能串行比较）。哪个tag比较相等，就意味着命中某个cache line。因此，在全相连缓存中，任意地址的数据可以缓存在任意的cache line中。所以，这可以最大程度的降低cache颠簸的频率，但是硬件成本上也是更高。</p></li><li><p><strong>缓存命中</strong></p><p>cache hit：cache中有block的有效副本，所以能返回期望数据</p><p>cache miss：cache中没有想要的block，所以只能从memory中取出</p><p>block replacement：若cache满了，就要撤销其中一个block，用期待读取的数据替换。但是替换哪个block捏？</p><p>常用的cache算法：</p><ul><li><p>随机替换</p></li><li><p>Least Recently Used（LRU）：最近一次访问时间最久远的那个block</p></li></ul></li><li><p><strong>多级cache之间的配合工作:</strong></p><p><img src="https://s2.loli.net/2023/04/14/X14bpdWwz5aSgCn.png" alt=""></p><p>当CPU试图从某地址load数据时，首先从L1 cache中查询是否命中，如果命中则把数据返回给CPU。如果L1 cache缺失，则继续从L2 cache中查找。当L2 cache命中时，数据会返回给L1 cache及CPU。如果L2 cache也缺失，很不幸，我们需要从主存中load数据，将数据返回给L2 cache、L1 cache及CPU。这种多级cache的工作方式称之为inclusive cache。某一地址的数据可能存在多级缓存中。与inclusive cache对应的是exclusive cache，这种cache保证某一地址的数据缓存只会存在于多级cache其中一级。也就是说，任意地址的数据不可能同时在L1和L2 cache中缓存</p></li><li><p><strong>写操作：</strong></p><p>写操作会造成cache和主存中的数据不一致，那么如何保证数据操作正确捏？</p><ul><li><p>通写（write through）：把数据写入cache的同时也写入主存，好处是保持一致性，坏处是极其影响写速度</p><p><img src="https://s2.loli.net/2023/04/14/EJbRZ36jGACeOsL.png" alt=""></p></li><li><p>回写（write back）：先把数据写回cache，当cache中的数据被替换时再写回主存。具体通过dirty bit实现，数据修改则置位。</p></li></ul><p><img src="https://s2.loli.net/2023/04/14/DHV7LmUpOwS63Ic.png" alt=""></p></li><li><p><strong>AMAT（Average Memory Access Time）</strong></p><p>同时考虑命中和丢失时的获取memory中数据的平均时间</p></li></ol><p><img src="https://s2.loli.net/2023/04/14/qd5wpKOuEiGHbyA.png" alt=""></p><p><img src="https://s2.loli.net/2023/04/14/5eh9B36T7NISdHL.png" alt=""></p><p>​AMAT=1+0.02*50=2 clock cycles=400ps</p><p>​——190ps clock：2 cycles=2*190=380</p><p>​——MP of 40 clock cycles：1+0.02*40=360</p><p>​<strong>——MR of 0.015*50=350 （√）</strong></p><h1>Lecture18-19、Operating Systems &amp; Virtual Memory</h1><ol><li><p>OS的最典型特征之一就是<strong>多任务</strong>，依赖于不同处理器的进程切换，但这个过程可能导致内存资源地址等发生变化</p><p><img src="https://s2.loli.net/2023/04/14/cwJQEKZl3WgzmU4.png" alt=""></p><p><img src="https://s2.loli.net/2023/04/14/yGSTfc3ELUFu4nQ.png" alt=""></p><p>造成这种现象的原因是应用未完全隔离，一个应用可以覆写另一个应用的内存，同时考虑到一些其他问题（如可能会处理比我们真正需求要多不少的内存，像稀疏矩阵），我们引入虚拟内存</p></li><li><p><strong>virtual memory</strong></p><ul><li>虚拟内存VM：给每个进程隔离的空间，进程认为其内存足够大，并且完全属于自己（仅自己有访问权）</li><li>物理内存PM：电脑中真实的限制性的RAM</li></ul><p><strong>key idea：<strong>由于程序大小的膨胀，且系统同时运行多个程序，经常会出现需要空间&gt;实际内存的问题，而虚拟内存可有效解决该问题：每个进程都持有各自的虚拟内存，<strong>分为很多个页</strong>，但并不是所有页都必须在内存中时才能运行程序。用到哪一页，就作映射去物理地址寻找数据；若映射这个物理地址不在内存中怎么办捏？那它在哪里捏？答案是：<strong>外存，即disk</strong>。接下来由系统自动完成将外存调入内存的的工作；而当内存空间不够时，系统按一定算法</strong>释放某部分内存空间</strong>。 通过上述操作，就能让程序在运行中感觉到拥有一个不受内存容量约束的、虚拟的、能够满足自己需求的存储器。</p><p>主要需要达成的几个目标：</p><ul><li><p>进程隔离</p></li><li><p>有限到无限空间的过渡</p></li><li><p>VM、PM地址的转换</p></li></ul></li><li><p><strong>解决思路：分段内存（segmented memory）</strong></p><p>每个段用基地址（base）和偏移地址（bound）表示，每个程序独享一个segment，在各自的内存视角中，都认为自己这个段的段首地址是0x0000</p><p>在裸的五段流水线中，PC输出的是真实的物理地址；但在base and bound机制中：</p><p><img src="https://s2.loli.net/2023/04/14/sEHDjNy6hVXOwtf.png" alt=""></p><p>但分段内存仍有一些问题：如果我们需要的地址比段空间大捏？RAM都分成了段导致连续空间不够捏？</p></li><li><p><strong>分页内存（paged memory）</strong></p><p>**key idea：**把物理内存均分为多个page，每个进程可以独享多个page。page在RAM中不必真的连续，但在各个进程的视角看来，它们对自己来说就是连续的</p><p>那VM、PM地址如何转换呢——page table，每个进程维护一张，用于记录自己占用的page和其真实物理地址</p><p><img src="https://s2.loli.net/2023/04/14/uHglNXbaPYtRD8G.png" alt=""></p><p>注意：虚拟内存在RAM没有对应是一件很正常的事哈（图中黄色的那些页），C盘里那个巨大的PageFile.Sys就是放在外存里的虚拟内存</p></li><li><p><strong>地址转换</strong></p><p><img src="https://s2.loli.net/2023/04/14/X95WOrG2kMZ7HAp.png" alt=""></p><p><img src="https://s2.loli.net/2023/04/14/IUG75RzLhYKfJ6F.png" alt=""></p><p><strong>转换算法：</strong></p><p>1）通过virtual page number在表中找到对应位置</p><p>2）检查valid和access rights位是否有效</p><p>3）通过physical page number和offset算出物理地址</p></li><li><p><strong>页面表</strong></p><p>若是简单的线性结构表，需要表0和表n时得遍历整个表，很耗时间（一个操作系统中page table里的entry可多达数百万条），为此，我们可以使用一些改进结构</p><ul><li><p><strong>分级分页</strong></p><p><img src="https://s2.loli.net/2023/04/14/pfaS9cNI3jtsAvB.png" alt=""></p></li></ul></li><li><p><strong>页表缓冲TLB（Translation Lookaside Buffer）</strong></p><p>在分级分页中，获取一个数据可能需要多次访问physical address，造成速度缓慢，而既然page中也存在局部性，那我们可以考虑使用和cache的类似的缓存结构</p><p><img src="https://s2.loli.net/2023/04/14/J7bRiFxkNu6yQHD.png" alt=""></p><ul><li>TLB中存的不是内存数据，而是VPN→PPN的映射</li><li>TLB通常很小，一般存32-128条entry</li><li>速度比cache快很多</li></ul><p>**TLB和cache的组合工作原理：**先在TLB中查虚拟地址，命中则直接在cache中读物理地址；否则在page table中找映射关系</p><p><img src="https://s2.loli.net/2023/04/14/kE78VqNFfGBLZlj.png" alt=""></p></li></ol><h1>Lecture20、IO</h1><ol><li><p>**disks are I/O：**因为cpu无法从磁盘（包括ssd和机械）中直接读写数据，page从disk移向RAM后才会变成memory；电脑没disk也能跑</p></li><li><p><strong>IO操作方式：</strong></p><p>处理器频率一般远大于IO设备，所以需要一定方式进行操作</p><ul><li><p><strong>轮询（polling）</strong></p><p>处理器在循环中不断等待control register信号，若ready bit置一，则处理器向data register中读写数据，c语言中的while(getchar()==‘x’)其实就是一种最简单的轮询思想 轮询对于一些简单设备没问题，如鼠标，一秒只做30次polling，cpu耗时比例很低；但磁盘每秒读写数MB的数据，算下来cpu高达40%的时间都耗在轮询上，显然不可接受</p></li><li><p><strong>中断（interrupt）</strong></p><p><img src="https://s2.loli.net/2023/04/14/D5sxBgJl7cUIuOw.png" alt=""></p><p>经计算，中断可把cpu在磁盘读写上的耗时降到2%，但还可以优化</p></li><li><p>**DMA：**memory和IO设备直接传数据，不经过cpu</p><p>一个比喻：polling像饿了去餐馆，过一会儿问下“菜好没”；interrupt像在线下单，你继续干活，做好了再叫你，去了直接拿直接走；dma则像下一单外卖，拿取都取消，只管等东西来</p><p><img src="https://s2.loli.net/2023/04/14/gMWR4TAvKzIw9Jk.png" alt=""></p><p>经计算，dma可把cpu在磁盘读写上的耗时降到0.2%</p></li></ul></li></ol><h1>Lecture21、Data-level Parallelism</h1><ol><li><p>**motivation：**晶体管的发展受限，无法通过提高时钟频率进一步提升cpu性能，而并行正是解决这一问题的好方法</p></li><li><p><strong>并行化分类</strong></p><p><img src="https://s2.loli.net/2023/04/14/zlKvwu2JBD8m4aL.png" alt=""></p></li><li><p><strong>SIMD(Single Instruction Multiple Data)架构</strong></p><p>许多基本数据类型为8bit，而现在处理器是32/64bit，若一次只用64位中的低八位处理数据显然很浪费，但若将64位寄存器拆成8个8位寄存器就能同时完成8个操作，计算效率提升8倍，这就是SIMD的初衷，具体表现为向量运算</p><p><img src="https://s2.loli.net/2023/04/14/DeBKghxMAmLtojf.png" alt=""></p><p>intel的一些拓展指令集SSE（Streaming SIMD Extensions）、AVX（Advanced Vector Extensions）用于进行SIMD运算</p><p>具体实现上，常用内置函数（intrinsics）方式，如下图所示让两数组相加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add_no_SSE</span><span class="hljs-params">(<span class="hljs-type">int</span> size, <span class="hljs-type">int</span> *first_array, <span class="hljs-type">int</span> *second_array)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>first_array[i] += second_array[i];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add_SSE</span><span class="hljs-params">(<span class="hljs-type">int</span> size, <span class="hljs-type">int</span> *first_array, <span class="hljs-type">int</span> *second_array)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">4</span> &lt;= size; i+=<span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// only works if (size%4) == 0</span><br><span class="hljs-comment">// load 128-bit chunks of each array</span><br>__m128i first_values = _mm_loadu_si128((__m128i*) &amp;first_array[i]);<br>__m128i second_values = _mm_loadu_si128((__m128i*) &amp;second_array[i]);<br><span class="hljs-comment">// add each pair of 32-bit integers in the 128-bit chunks</span><br>first_values = _mm_add_epi32(first_values, second_values);<br><span class="hljs-comment">// store 128-bit chunk to first array</span><br>_mm_storeu_si128((__m128i*) &amp;first_array[i], first_values);<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>循环展开</strong></p><p><img src="https://s2.loli.net/2023/04/14/wW4sJ17DUOF3xtM.png" alt=""></p><p>为什么这种循环展开可以加速运算呢？</p><p>未展开时的汇编代码：每个元素操作完后都要跳一次loop</p><p><img src="https://s2.loli.net/2023/04/14/Z68HIYsCQLaOqRk.png" alt=""></p><p>展开后：汇编代码重排，可利用SIMD机制</p></li></ol><p><img src="https://s2.loli.net/2023/04/14/se4LKvalYpqyCRH.png" alt=""></p><h1>Lecture22、Thread-level Parallelism</h1><ol><li><p><strong>多处理器运行多进程(并行)</strong></p><p><img src="https://s2.loli.net/2023/04/14/5xt7rjyhSsvkwz1.png" alt=""></p><p>每个进程在各自的处理器上运行，但享用同样的系统内存</p></li><li><p><strong>单处理器运行多个线程（并发）</strong></p><p>各个线程有自己的PC、寄存器、栈空间，享用相同的静态空间。一个典型的例子是浏览器中开多个页面，每个页面的浏览器源码和全局设置是一样的，但有着各自不同的stack和寄存器（但事实上现在的浏览器出于安全和性能原因，给每个页面用的是独立的处理器）</p><p><img src="https://s2.loli.net/2023/04/14/vyPLMpWEcDRr6kB.png" alt=""></p><p>多线程有啥好处呢：处理器的资源宝贵，多线程可以尽可能**避免其空闲，**如cache miss后有个很长的memory latency，则直接切换到其它线程（所以切换上下文的开销得小于cache miss latency）</p></li><li><p><strong>并发中的一些问题</strong></p><ul><li><p><strong>加速性能</strong></p><p>阿姆达尔定律：</p><p><img src="https://s2.loli.net/2023/04/14/tj3WE45JF9sIxfg.png" alt=""></p><p>可知对于一个5%的时间使用并行，即使用5个处理器，其加速性能也不过是：</p><p><img src="https://s2.loli.net/2023/04/14/cHliG971Uqwv6Sn.png" alt=""></p><p>只有并行运算占比足够高时，处理器数量的增加才会带来明显性能提升</p><p><img src="https://s2.loli.net/2023/04/14/hgDJ5ktYdTmsX8K.png" alt=""></p><p>但这样的加速也有瓶颈，由阿姆达尔定律可知，S足够大时，speedup接近于常数</p><p>**解决思路：**原始运算中尽可能少用标量运算，也就是尽量提升并行化占比</p></li><li><p><strong>数据竞争</strong></p><p>线程调度是<strong>不确定的</strong>，因此当多个线程对同一个变量操作时，其最终的值也是不确定的</p><p>**解决思路：**不要往相同的内存写数据；让读写同步，从而获得确定行为</p></li></ul></li><li><p><strong>锁同步</strong></p><p>用lock来对重要区域（比如有共同操作的变量的内存区域）作访问限制，以便一次只有一个线程能访问</p><p><img src="https://s2.loli.net/2023/04/14/lkWcYZOyRASI84p.png" alt=""></p></li><li><p><strong>cache coherence</strong></p><p><img src="https://s2.loli.net/2023/04/14/wDslLqVnNKrOdg3.png" alt=""></p><p>假设两个core同时运行两个线程，都对变量i进行操作，这时A执行了i++，cache采用写回策略，即先放到自己的cache里并把dirty bit置一，并未同步到memory。这时B从内存读i的值，则读到的将会是错误值，即所谓的缓存一致性问题</p><p>解决方法：</p><ul><li><p><strong>写传播（write propagation）</strong></p><p>key idea：当某个core更新了cache中的数据时，要把该事件广播通知到其它core ，最常见的实现方法是<strong>总线嗅探（bus snooping）</strong></p><p>如core A改变了i的值后，会通过总线把这个事件广播给其它所有core；其它core随时保持监听总线上的广播事件，并检查是否有相同的数据在自己的cache里，若有则更新</p><p>但这个方法并不完美：一来每修改一个数据都要广播一次，会加重总线负载；二来总线嗅探只能保证某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串行化（即不知道谁先改谁后改）</p></li><li><p><strong>MESI 协议</strong></p><p>MESI 协议其实是 4 个状态单词的开头字母缩写，分别是：Modified（已修改）、Exclusive（独占）、Shared（共享）、Invalidated（已失效），这四个状态来标记 Cache Line 四个不同的状态</p><p>整个 MESI 状态的变更，则是根据来自本地 CPU 核心的请求，或者来自其他 CPU 核心通过总线传输过来的请求，从而构成一个流动的状态机。另外，对于在「已修改」或者「独占」状态的 Cache Line，修改更新其数据不需要发送广播给其他 CPU 核心</p><p><img src="https://s2.loli.net/2023/04/14/mTnkYR1GqaQlJEA.png" alt=""></p></li></ul></li></ol><h1>Lecture24、Warehouse Scale Computers, MapReduce</h1><ol><li><p><strong>典型结构</strong></p><p><img src="https://s2.loli.net/2023/04/14/RLmXyJhxjcdo2OT.png" alt=""></p><p>一个WSC中包含多个array（aka cluster），一个array中有多个rack（机架），一个rack中又包含多个服务器</p></li><li><p><strong>阐述wsc架构工作过程（以google搜索hust为例）</strong></p><ol><li>发送请求给最近的Google warehouse scale computer</li><li>前端平衡负载，在众多cluster中找出最合适的那个</li><li>在cluster内部找出一个google web servers来处理请求，生成网页</li><li>google web servers和内部服务器交流，找到包含“hust”的那个文件</li><li>返回相关的文件列表以及对应的关联分数</li></ol><p>此外，随之发生的还可能有：</p><ul><li>推荐系统生成相关广告</li><li>根据关联分数对搜索结果进行排序，在网页中显示</li><li>对索引和文件生成副本，用于提高request-level parallelism</li></ul></li></ol><h1>Lecture_Bonus</h1><ol><li><p><strong>进程与线程</strong></p><p>CPU执行一个函数的本质是那么<strong>把该函数对应的第一条机器指令的地址写入PC寄存器</strong>，而机器指令要加载到内存中执行，需要记录下内存的起始地址和长度，同时要找到函数的入口地址并写到PC寄存器中——这正是构建<strong>进程</strong>的思路</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">process</span>&#123;<br>   <span class="hljs-type">void</span>* start_addr;<br>   <span class="hljs-type">int</span> len;<br>   <br>   <span class="hljs-type">void</span>* start_point;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><p>​常规程序中，main()是第一个执行的；但是我们能先执行其它函数吗？能！因为main()和其它函数并无本质区别，既然可以把PC寄存器指向main()，就也可以把PC指向任何一个函数；而当我们指向非main()函数的时候，**线程（thread）**就诞生了</p><p><img src="https://s2.loli.net/2023/04/14/resuH62xw1tSl5D.png" alt=""></p><p>​那么进一步解放思想——一个进程内有多个入口函数，也就是说同一个进程中的机器指令可以被多个CPU同时执行，即多线程并发</p><div class="note note-warning">            <p>💡 PS.</p><ol><li>并不是一定得有多核才能多线程，单核同样可以，因为<strong>线程是OS层面的实现，与有多少个核心无关</strong>，CPU在执行机器指令时也意识不到执行的机器指令属于哪个线程</li><li>上述理论也说明了为啥OS要给每个线程分配一个栈，因为每个线程的执行流都需要保存自己正在执行的函数的数据（参数、局部变量、返回地址等）</li></ol>          </div><ol start="2"><li><p><strong>线程池</strong></p><p>**motivation：<strong>对于短任务（一次网络请求、数据库查询），若来一个请求就创建一个进程，用完再摧毁，则即耗时间又费内存；如果你是公司老板，和“来一个任务招一个人”相比，更好的办法当然是招一批人养着，有事做事，没事躺尸，这就是</strong>线程池（thread pool）**的由来</p><p>**基本结构：**队列结构，生产者提交任务，消费者消费任务</p><p><img src="https://s2.loli.net/2023/04/14/Ucm5pV8CeJkTzWo.png" alt=""></p><p>提交给线程池的任务包含两部分：需要被处理的数据和处理数据的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task</span> &#123;<br>   <span class="hljs-type">void</span>* data;     <span class="hljs-comment">// 任务所携带的数据</span><br>   handler handle; <span class="hljs-comment">// 处理数据的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>生产者向队列中写入数据后，线程池中的某个线程会被唤醒，该线程从队列中取出上述结构体，执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">task</span> = <span class="hljs-built_in">GetFromQueue</span>(); <span class="hljs-comment">// 从队列中取出数据</span><br> task-&gt;<span class="hljs-built_in">handle</span>(task-&gt;data);     <span class="hljs-comment">// 处理数据</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>核数与线程数的关系</strong></p><p>结论：没有直接关系，一个核可执行多个线程</p><p>Q：那么线程数为多少时性能最佳捏？</p><p>A：如果线程不涉及任何I/O、没有任何同步互斥的纯计算类型，那么每个核心一个线程通常是最佳选择；但通常来说，线程都需要一定的I/O，可能需要一定的同步互斥，那么此时<strong>适当增加线程</strong>可能会提高性能，但线程数量达到一个<strong>临界值后性能会开始下降</strong>，这时线程间切换的开销将显著增加。</p></li><li><p><strong>一段典型riscv代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs nasm">#打印第n个斐波那契数<br><br>.data<br>.word 2, 4, 6, 8<br>n: .word 9<br><br>.text<br>main:   <br>    add t0, x0, x0<br>    addi t1, x0, 1<br>    la t3, n <br>    lw t3, 0(t3)<br>fib:    <br>    beq t3, x0, finish<br>    add t2, t1, t0<br>    mv t0, t1<br>    mv t1, t2<br>    addi t3, t3, -1  <br>    j fib<br>finish: <br>    addi a0, x0, 1<br>    addi a1, t0, 0<br>    ecall # print integer ecall<br>    addi a0, x0, 10<br>    ecall # terminate ecall<br></code></pre></td></tr></table></figure><p>.data和.text是伪操作指令，表示将接下来的代码分配到data区和text区，.word表示按字（32bit）分配数据，即data区的第一个word放入0x02（多余的bit补零），第二个word放0x04这样子 la表示把n的地址给到t3，lw则是把n的地址中存的值放入t3中，即t3中的值变为9，la和lw通常配套使用 fib标签中的内容就是不断判断比较累加得斐波那契数了 最后的ecall是系统调用，由参数决定具体调用内容，a0和a1都是参数 (argument) 寄存器，用于在函数调用过程中保存第一个和第二个参数，以及在函数返回时传递返回值。ecall 1就是print，ecall 10就是exit</p></li><li><p><strong>流水线寄存器</strong></p><p><img src="https://s2.loli.net/2023/04/14/Iq4Qw7DaX9HbEoP.png" alt=""></p><p>流水线的基本原理如此，上面的笔记也探讨过，那具体应该怎么实现捏？或者说，普通的串联组合逻辑电路怎么就不能实现pipeline捏？</p><p>实现方法：加<strong>流水线寄存器</strong>。如我们能把指令存储器输出的指令编码事先保存下来，那就可以提前更新PC寄存器的值，并用这新的值去指令存储器当中取出一个新的指令，而在取新指令的同时，刚才取出的那条指令的编码就会被分解成不同位域，而寄存器堆也会根据输入送出对应寄存器的内容。由此就实现了各个阶段分别运行，互不干扰。</p><p>打个比方，小志年轻力壮，搬快递时猛得一p，后面接手的老师傅说哎呀我要摸鱼，年轻人<strong>你只管搬你的别管我们</strong>（流水线思想），你速度快，多搬出来的那些<strong>放旁边小车上就好，待会我直接从小车上取就行</strong>（小车就是流水线寄存器）</p><p><img src="https://s2.loli.net/2023/04/14/fQLhHwrpKyxuIki.png" alt="Untitled"></p><p>性能分析，与之前的流水线相比，多了流水线寄存器的延迟，周期200到250ps</p><p><img src="https://s2.loli.net/2023/04/14/QAwatYbL73v1Exj.png" alt=""></p><p>而至于为什么不加寄存器就不能实现流水线，我想应解释为各部分时延不匹配造成的<strong>线路信号冲突</strong>，即如果后面部分还没执行完，IF就在一直吭哧吭哧取指，那么取出来的instruction word想必不会被ID接受，也就成了无效输入</p></li><li><p>cache<strong>命中时</strong>，策略为回写（write back）和直写（write through）； <strong>未命中时</strong>，策略为写分配（write-allocate）和无写分配（no write-allocate），写分配表示发生write miss时，把没命中的那个块放到cache中，而无写分配则意味着只改memory 通常，write back和write-allocate搭配使用，这样的memory永远不会被直接修改；write through和no write-allocate搭配</p></li><li><p><strong>用指针非空判断数组边界？</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> array[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span> , <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span>* ptr = array;<br><br>    <span class="hljs-keyword">while</span>(ptr != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\\n&quot;</span>, *ptr);<br>        ptr += <span class="hljs-number">1</span>;<br>    &#125; <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/oJjaIEqM2rtQDcX.png" alt=""></p><p>输出结果相当炸裂，这是为什么捏？</p><p>因为<strong>用指针非空判断数组边界本就是错的！数组大小为4不代表第五个内存空间就没有其它东西了啊！</strong>（下面这段代码也可以说明这一点，两个数组分别申请，但内存位置是连续的）</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span> , <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span> array2[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span> , <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br>    <span class="hljs-type">int</span>* ptr = <span class="hljs-built_in">array</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\\n&quot;</span>, *ptr);<br>        ptr += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/8xdBXH6YoyEjtD7.png" alt=""></p><p>也就解释了为什么C语言中反复强调，传数组指针时，也必须显式地将数组长度传进去；光通过一个数组指针是没办法获取数组长度的！（char数组用strlen()除外） 而至于为啥在过去的代码中好像用过“指针非空”来判断边界呢。。是因为使用场景是链表，链表初始化就把next指针设为nullptr了；而像vector的边界判断，那也是用的vector.end()，是个迭代器，而不是普通的一个nullptr。。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>核心科技看美帝</category>
      
    </categories>
    
    
    <tags>
      
      <tag>体系结构</tag>
      
      <tag>riscv</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个典型的cache工作原理演示实验</title>
    <link href="/2023/04/14/%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84cache%E6%BC%94%E7%A4%BA%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/04/14/%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84cache%E6%BC%94%E7%A4%BA%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>前言：本文章将在可视化环境下对cache工作原理进行演示实验，通过下面三个实验，读者应能：</p><ol><li>理解cache三种访问模式（直连、两路相连、全连）的工作原理；</li><li>学会计算命中率（hit rate），并理解各个参数（循环次数、步长、cache size等）如何影响hit rate；</li><li>理解不同的cache策略（回写、直写、LRU）对hit rate的影响；</li><li>知道如何优化代码，以实现更高的hit rate</li></ol><p>实验来源：<a href="https://inst.eecs.berkeley.edu/~cs61c/su20/labs/lab07/">CS61C（20-SUMMER）- lab 7</a></p><p>可视化平台：<a href="https://venus.cs61c.org/">venus</a></p>          </div><div class="note note-warning">            <p>PS. 完整的题目和描述请参考<a href="https://inst.eecs.berkeley.edu/~cs61c/su20/labs/lab07/">CS61C（20-SUMMER）- lab 7</a>！下述所有分析仅相当于是实验答案，对题目本身不再赘述😪</p>          </div><p><strong>汇编对应的C代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> array[];  <span class="hljs-comment">//Assume sizeof(int) == 4</span><br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; repcount; k++) &#123;<span class="hljs-comment">// repeat repcount times</span><br>  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; arraysize; index += stepsize) &#123;<br>    <span class="hljs-keyword">if</span>(option==<span class="hljs-number">0</span>)<br>      array[index] = <span class="hljs-number">0</span>;<span class="hljs-comment">// Option 0: One cache access - write</span><br>    <span class="hljs-keyword">else</span><br>      array[index] = array[index] + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// Option 1: Two cache accesses - read AND write</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实验一：直接映射</strong></p><p>参数设置为：</p><ul><li>Array Size (a0): 128 (bytes)，即32个int</li><li>Step Size (a1): 8</li><li>Rep Count (a2): 1</li><li>Option (a3): 0</li><li>cache line设为8byte，共4个line</li><li>策略为direct map + LRU</li></ul><p>手动分析，一次for循环中，要访问array[0、8、16、24]这4个元素，访问array[0]时，cache miss（此时cache中还没东西），于是从memory中把array[0、1]都放进来；但下一次访问array[8]时仍然会miss，这么一路下来cache access为4，hit rate为0</p><p><img src="https://s2.loli.net/2023/04/14/WzSZARV1gETyI5C.png" alt=""></p><p>经验证确实如此，注意为啥只在cache0上操作捏？</p><p><img src="https://s2.loli.net/2023/04/14/lY2BUCygoJn4qvG.jpg" alt=""></p><p>看图就清楚了：index 2bit，offset 3bit。访问的是array[0、8、16、24]这几个元素，地址为0、32、64、96，其二进制的index一样的，都是对应line0</p><p>那么同理，我们把stepsize改成4、2，hit rate始终都是0;</p><p>改成1则hit rate=50%</p><p><img src="https://s2.loli.net/2023/04/14/LqTQDVnlOGaXjrc.png" alt="Untitled"></p><p><strong>实验二：4路映射</strong></p><p>参数设置为：</p><ul><li>Array Size (a0): 256(bytes)，即64个int</li><li>Step Size (a1): 2</li><li>Rep Count (a2): 1</li><li>Option (a3): 1</li><li>cache line设为16byte，共16个line</li><li>策略为4 way set associative + LRU</li></ul><p><img src="https://s2.loli.net/2023/04/14/Daexf5wv9JUN3jp.jpg" alt=""></p><p>手动分析hit rate = 0.75，经验证确实如此</p><p><img src="https://s2.loli.net/2023/04/14/s9TJvIlmoUVYHQX.png" alt=""></p><p>进一步思考：那把repcount设为2，hit rate还是0.75吗？</p><p>显然不是，因为第一遍for把所有cache line都填满了（整个array[]正好全装进去了！），所以后续每次cache access都会命中；hit rate = （48+64）/（2*64） = 0.875</p><p><img src="https://s2.loli.net/2023/04/14/5vKhocQJH1t3V7u.png" alt=""></p><p>repcount设为100时，hit rate就很接近于100%了（这其实也是映证了cache的基本原理，时空局部性，即数据重复度越高，cache越管用）</p><p><img src="https://s2.loli.net/2023/04/14/S9wBezDrEpVi1vf.png" alt=""></p><p><strong>实验三：两级cache</strong></p><p>参数设置为：</p><ul><li>Array Size (a0): 128(bytes)，即32个int</li><li>Step Size (a1): 1</li><li>Rep Count (a2): 1</li><li>Option (a3): 0</li></ul><p>L1 cache：</p><ul><li>cache line设为8byte，共8个line</li><li>策略为direct map + LRU</li></ul><p>L2 cache：</p><ul><li>cache line设为8byte，共16个line</li><li>策略为direct map + LRU</li></ul><p><img src="https://s2.loli.net/2023/04/14/5DNjmzHWGcyhRis.png" alt=""></p><p><img src="https://s2.loli.net/2023/04/14/zygfL8HXFeiOMuk.png" alt=""></p><p><strong>解释：</strong></p><p>L1 hit rate 50%不解释，同实验一；</p><p>L2为啥是0%捏？ 其实想想那个过程就清楚了：找array[0]的时候，L1、L2都miss，然后从memory中把array[0、1]拿出来，接下来访问array[1]的时候在L1里就直接找到了，根本不会去访问L2，所以L2一共也就会访问16次，次次miss</p><p>**Q：**改变哪个参数会让L1命中率不变且L2命中率增加？</p><p>**A：**rep count。因为增加for重复次数时，L1中始终只装了一半的array，永远都是第一个元素miss、第二个hit；而L2 cache size为128bytes，刚好能把整个数组装下，所以rep count越大，L2的hit rate越接近于100%<br>$$</p><p>$$</p>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>体系结构</tag>
      
      <tag>cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最优化计算方法（文再文）笔记</title>
    <link href="/2023/04/13/%E3%80%8A%E6%9C%80%E4%BC%98%E5%8C%96%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E6%96%87%E5%86%8D%E6%96%87%EF%BC%89%E7%AC%94%E8%AE%B0%E3%80%8B/"/>
    <url>/2023/04/13/%E3%80%8A%E6%9C%80%E4%BC%98%E5%8C%96%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E6%96%87%E5%86%8D%E6%96%87%EF%BC%89%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1>《最优化计算方法（文再文）笔记》</h1><h1>第一章、最优化简介</h1><h3 id="一、概述">一、概述</h3><ol><li><p><strong>最优化问题一般形式：</strong></p><p><img src="https://s2.loli.net/2023/04/14/wazjU2bHxYqCuVs.png" alt=""></p><p>其中$x=(x_1,x_2,…,x_n)^T\in R^n$是<strong>决策变量</strong></p><p>$f:R^n\rightarrow R$是<strong>目标函数</strong></p><p>$\chi\in R^n$是约束集合，即<strong>可行域</strong></p><p>s.t.是subject to，专指<strong>约束条件</strong></p><p>但f(x)的min/max不总是存在的，此时我们关心其上下确界，即将上式改为inf(sup) f(x)</p></li><li><p><strong>最优化问题分类</strong></p><ul><li>目标函数和约束函数皆为线性时，称为线性规划</li><li>至少有一个非线性时称为非线性规划</li><li>目标函数为二次函数时称为二次规划</li><li>还有整数规划、非光滑规划、无导数规划等。。</li></ul></li><li><p><strong>凸优化</strong></p><p>定义：最小化问题中，目标函数和可行域分别是凸函数和凸集；相反，只要有一个不为凸，则为非凸优化问题。因为凸优化问题的任何局部最优解都是全局最优解，所以其相应的算法设计以及理论分析相对非凸优化问题简单很多。</p><div class="note note-warning">            <p>💡 PS. 所以用凸模型对非凸问题进行转换/逼近是一个很重要的手段</p>          </div></li></ol><h1>第二章、基础知识</h1><h3 id="一、概述-2">一、概述</h3><ol><li><p><strong>矩阵范数</strong></p><p>当p=1时，矩阵$A\in R^{m×n}$的$l_1$范数定义为：<br>$$<br>\lVert A \rVert_1=\sum_{i=1}^m\sum_{j=1}^n\vert a_{ij} \vert<br>$$<br>p=2时：<br>$$<br>\lVert A \rVert_2=\sqrt{Tr(AA^T)}=\sqrt{\sum_{i,j}a_{ij}^2}<br>$$<br>Tr(X)表示方阵的迹，即方阵的主对角线的元素之和</p><div class="note note-warning">            <p>💡 PS. 一个结论： 矩阵的2范数是该矩阵的最大奇异值（why？）</p>          </div></li><li><p><strong>海瑟矩阵</strong></p><p><img src="https://s2.loli.net/2023/04/14/BECN3juMKan6xLo.png" alt=""></p></li><li><p><strong>矩阵变量函数的导数</strong></p><p><img src="https://s2.loli.net/2023/04/14/hzEMxDuX9WcHiyt.png" alt=""></p><p><img src="https://s2.loli.net/2023/04/14/219YjdlZ5aShr3x.png" alt=""></p></li><li><p><strong>凸集</strong></p><p>如果连接集合C中任意两点的线段都在C内，则称C为凸集</p><p><img src="https://s2.loli.net/2023/04/14/bRu7fcMCqldoD6W.png" alt=""></p></li><li><p><strong>凸包</strong></p><p>对于形如</p><p><img src="https://s2.loli.net/2023/04/14/HZlsb1pIMCx6Gwc.png" alt=""></p><p>的点称为x1、x2。。。xk构成的<strong>凸组合</strong>，集合S中点所有可能的凸组合构成的集合称作S的<strong>凸包</strong>，记作<strong>convS</strong>．实际上，<strong>convS</strong>是包含S的最小的凸集。如下图所示，分别为离散点集的凸包和扇形的凸包。</p><p><img src="https://s2.loli.net/2023/04/14/luNXMaWSRO12Ko4.png" alt=""></p></li><li><p><strong>一些重要的凸集</strong></p><ul><li>超平面和半空间</li></ul><p><img src="https://s2.loli.net/2023/04/14/xw7VaQyXfHuZlbA.png" alt=""></p><ul><li>球、椭球、椎</li></ul><p>常规的球、椭球、椎的定义用的是欧几里得范数，但可用其它范数进行概念推广</p><p>多面体</p><ul><li>（半）正定椎</li></ul><p><img src="https://s2.loli.net/2023/04/14/DEHSgQ6AaeNpC5w.png" alt=""></p></li><li><p><strong>强凸函数</strong></p><p><img src="https://s2.loli.net/2023/04/14/Aoa2UdNbKrw7chf.png" alt="Untitled"></p><p>强凸函数减去一个正定二次函数仍然是凸的。和普通凸函数相比，强凸函数有更好的性质。</p><div class="note note-warning">            <p>💡 PS. 结论：设 <em>f</em> 为强凸函数且存在最小值，则 <em>f</em> 的最小值点唯一</p>          </div></li></ol><h1>第三章、典型优化问题</h1><h3 id="一、线性规划">一、线性规划</h3><ol><li><p>一般形式</p><p><img src="https://s2.loli.net/2023/04/14/RwBQujfqc4stJIK.png" alt=""></p><p>常见的两种形式：标准型（等式约束+决策变量非负）</p><p><img src="https://s2.loli.net/2023/04/14/WXe3PD5Oc1faYjN.png" alt=""></p><p>不等式形（没有等式约束）</p><p><img src="https://s2.loli.net/2023/04/14/f1jFugUqNXJ3PYc.png" alt=""></p></li></ol><h1>第四章、无约束优化算法</h1><h3 id="一、线搜索方法">一、线搜索方法</h3><p>给定当前迭代点xk，首先通过某种算法选取向量dk，之后确定正数αk，则下一步的迭代点可写作<br>$$<br>x^{k+1}=x^k+\alpha_kd^k<br>$$<br>其中dk是搜索方向，αk是步长，线搜索算法的关键就是选取好的dk和αk，为了选出合适的步长αk，我们要引入一定的要求，称之为<strong>线搜索准则</strong>，常见的有Armijo准则、Goldstein准则、Wolfe准则等</p><p>其中，用于满足Armijo准则的常用方法是<strong>回退法</strong>，其基本思想为由大到小不断试验α，直至输出一个满足Armijo准则且尽可能大的步长</p><p><img src="https://s2.loli.net/2023/04/14/87Lrs5XoR4M9ObN.png" alt=""></p><h3 id="二、梯度类算法">二、梯度类算法</h3><ol><li><p><strong>梯度下降法</strong></p><p>$$ x^{k+1}=x^k-\alpha_k\nabla f(x^k) $$</p></li><li><p><strong>BB算法（Barzilai-Borwein）</strong></p><p>$$ x^{k+1}=x^k-\alpha_{BB1}^K\nabla f(x^k) $$</p><p>$$ x^{k+1}=x^k-\alpha_{BB2}^K\nabla f(x^k) $$</p><p>其中</p><p><img src="https://s2.loli.net/2023/04/14/PmaeTIGiWnXb1YH.png" alt=""></p><p><img src="https://s2.loli.net/2023/04/14/6chSM21efDy8BY7.png" alt=""></p><p>由上式可见，BB算法仅需要知道函数相邻两步的梯度信息和迭代点信息，所以BB算法的应用范围很广泛</p><p><img src="https://s2.loli.net/2023/04/14/q1dE8OU5Pr9zgGJ.png" alt=""></p></li></ol><h3 id="三、次梯度算法">三、次梯度算法</h3><ol><li><p><strong>motivation：<strong>使用GDA的前提为目标函数 f(x) 是一阶可微的，但实际应用中经常会遇到</strong>不可微</strong>的函数，对于这类函数我们无法在每个点处求出梯度，但往往它们的最优值都是在不可微点处取到的。为了能处理这种情形，我们引入次梯度算法</p></li><li><p><strong>次梯度算法的结构</strong></p><p><img src="https://s2.loli.net/2023/04/14/MlaJcfgUHEtXpbo.png" alt=""></p><p>即对于凸函数来说，其切线总是在函数的下方。</p><p>类比上式可定义，给定函数f，对于任意y，如果满足：</p><p>$$ f(y)\ge f(x)+g^T(y-x) $$</p><p>则称 g 是函数 f 在点 x 处的次梯度，可见次梯度不一定唯一，也可能不存在。</p><p>将 f 在 x 处所有次梯度构成的集合称为 f 在 x 处的次微分，记作$\partial f(x)$</p><div class="note note-warning">            <p>💡 PS. 注意：次微分是一个集合，而凸函数的次微分总是非空，即必有次梯度</p>          </div><p>假设凸函数 f 在不可微点x0处的左右导数分别为a、b，那么闭区间[a，b]中的任何一个取值都是次梯度，如$f(x)=\vert x \vert$，则$g=\begin{cases}sgn(x)&amp;x\neq0\ any\in[-1,1]&amp;x=0\end{cases}$</p></li><li><p><strong>收敛性</strong></p><p>一个常用的取法是$\alpha_k=\frac{1}{k}$，这样可保证算法的收敛性</p></li></ol><h3 id="四、牛顿类算法">四、牛顿类算法</h3><ol><li><p><strong>motivation：</strong></p><p>梯度法仅仅依赖函数值和梯度的信息（即一阶信息），如果函数 <em>f</em>(<em>x</em>) 充分光滑，则可以利用二阶导数信息构造下降方向 <em>dk</em>。牛顿类算法就是利用二阶导数信息来构造迭代格式的算法。由于利用的信息变多，牛顿法的实际表现可以远好于梯度法，但是它对函数 <em>f</em>(<em>x</em>) 的要求也相应变高</p></li><li><p><strong>经典牛顿法</strong><br>$$<br>x^{k+1}=x^k-\nabla^2f(x^k)^{-1}\nabla f(x^k)<br>$$<br>经典牛顿法的特点：</p><ul><li>步长恒为1</li><li>收敛速度很快，但只有局部收敛性，即初始点x0必须离真实解较近，较远时容易失效</li></ul><p>因此在在实际应用中，人们通常会使用梯度类算法先求得较低精度的解，而后调用牛顿法来获得高精度的解</p></li><li><p><strong>修正牛顿法</strong></p><p><img src="https://s2.loli.net/2023/04/14/kO4vuQbPhI3tcs6.png" alt=""></p><p>基本思想是对牛顿方程中的海瑟矩阵$\nabla^2f(x^k)$进行修正</p></li></ol><h3 id="五、拟牛顿类算法">五、拟牛顿类算法</h3><ol><li><p>**motivation：**拟牛顿方法不计算海瑟矩阵$\nabla^2f(x^k)$ ，而是构造其近似矩阵$B^k$或其逆的近似矩阵 $H^k$，我们希望 $B^k$ **或$H^k$仍然保留海瑟矩阵的部分性质，例如使dk仍然为下降方向</p></li><li><p><strong>算法框架</strong></p><p><img src="https://s2.loli.net/2023/04/14/P34FKpX1rmdulV5.png" alt=""></p></li><li><p><strong>拟牛顿矩阵更新方式</strong></p></li></ol><ul><li><p>秩一更新（SR1）</p><p>$$ B^{k+1}=B^k+\dfrac{(y^k-B^ks^k)(y^k-B^k s^k)^{\text{T}}}{(y^k-B^kj)^{\text{T}}s^k} $$</p><p>$$ H^{k+1}=H^k+\dfrac{(s^k-H^k y^k)(s^k-H^ky^k)^{\mathrm{T}}}{(s^k-H^ky^{k})^{\mathrm{T}}y^k} $$</p></li><li><p>BFGS公式</p><p>$$ B^{k+1}=B^k+\dfrac{y^k(y^k)^{T}}{(s^k)^{T}y^k}-\dfrac{B^k s^k(B^k s^k)^}{(s^k)^{T}B^k s^k} $$</p><p>BFGS 公式是目前最有效的拟牛顿更新格式之一，它有比较好的理论性质，实现起来也并不复杂</p></li></ul><ol><li><p><strong>有限内存BFGS方法</strong></p><p>拟牛顿法虽然克服了计算海瑟矩阵的困难，但是它仍然无法应用在大规模优化问题上。一般来说，拟牛顿矩阵$B^k$ 或$H^k$ 是稠密矩阵，而存储稠密矩阵要消耗 <em>O</em>(n²) 的内存，这对于大规模问题显然是不可能实现的，故引入有限内存BFGS方法（L-BFGS）</p><p><img src="https://s2.loli.net/2023/04/14/PwRMakbExuog97v.png" alt=""></p><p><img src="https://s2.loli.net/2023/04/14/hB2pODdcqLivJRy.png" alt=""></p></li></ol><h3 id="六、信赖域算法">六、信赖域算法</h3><ol><li><p>**motivation：**在信赖域类算法中，我们直接在一个有界区域内求解这个近似模型，而后迭代到下一个点．因此信赖域算法实际上是同时选择了方向和步长</p></li><li><p><strong>形式：</strong></p><p>我们在如下球内考虑 f(x) 的近似<br>$$<br>\Omega_k={x^k+d\mid|d|\leqslant\Delta_k}<br>$$<br><img src="https://s2.loli.net/2023/04/14/uDc6BfUdOZrG5v2.png" alt=""></p><p>其中，mk(d)是在点x=xk处对f(x)的近似</p><p>$$ m_k(d)=f(x^k)+\nabla f(x^k)^{\mathrm T}d+\dfrac12d^{\mathrm T}B^kd $$</p><p>选取信赖域半径非常关键，它决定了算法的收敛性。考虑到信赖域半径是“对模型 <em>mk</em>(<em>d</em>) 相</p><p>信的程度”，如果 <em>mk</em>(<em>d</em>) 对函数 <em>f</em>(<em>x</em>) 近似较好，就应该扩大信赖域半径；反之减小。我们引入如下定义来衡量 <em>mk</em>(<em>d</em>) 近似程度的好坏</p><p>$$ \rho_k=\dfrac{f(x^k)-f(x^k+d^k)}{m_k(0)-m_k(d^k)} $$</p><p>如果<em>ρk</em> 接近于1，说明用 <em>mk</em>(<em>d</em>) 来近似 <em>f</em>(<em>x</em>) 是比较成功的，我们应该扩大 <em>∆k</em>；如果 <em>ρk</em> 非常小甚至为负，就说明我们过分地相信了二阶模型 <em>mk</em>(<em>d</em>)，此时应该缩小 <em>∆k</em></p><p><img src="https://s2.loli.net/2023/04/14/pRejfTP5g3yAiLV.png" alt="Untitled"></p></li></ol><h1>第五章、约束优化算法</h1><h3 id="一、罚函数法">一、罚函数法</h3><ol><li><p><strong>motivation：</strong></p><p>可行域的约束导致很多无约束算法不能直接使用（如梯度下降沿负梯度下降的点未必是可行点），而罚函数的思想是将约束条件作为惩罚项加到目标函数中，从而转换为无约束优化问题。</p><p>而这样做的原理是什么捏 —— 对于<strong>可行域外的点，惩罚项为正</strong>，即对该点进行惩罚；对于<strong>可行域内的点，惩罚项为 0</strong>，即不做任何惩罚。因此，惩罚项会促使无约束优化问题的解落在可行域内（好聪明的做法）。</p></li><li><p><strong>等式约束条件罚函数</strong></p><p><img src="https://s2.loli.net/2023/04/14/pDF1ZyodE9vP5jI.png" alt=""></p></li><li><p><strong>不等式约束</strong></p><p><img src="https://s2.loli.net/2023/04/14/xX73rBP5fuwVtlS.png" alt=""></p><p>我们设计加入罚函数的目标函数为：</p><p><img src="https://s2.loli.net/2023/04/14/WXZBYGvCbUFSNo2.png" alt=""></p><p><img src="https://s2.loli.net/2023/04/14/KEHV2ipQcxqT7N9.png" alt=""></p><p>这样的罚函数只会惩罚ci(x)＞0的部分，且由于函数 <em>h</em>(<em>t</em>) = (max*{t*, 0*}*)²关于 <em>t</em> 是可导的，因此 <em>PI</em>(<em>x</em>,<em>σ</em>) 的梯度也存在，则可以使用梯度类算法来求解子问题</p></li><li><p><strong>内点罚函数</strong></p><p>基本思想：普通的外点罚函数允许取可行域之外的点，只是要进行惩罚；而内点法直接不允许取可行域之外的点，即从可行域内部逼近最优解</p><p><img src="https://s2.loli.net/2023/04/14/2LPyCemrqFWRujQ.png" alt=""></p><p>上式既做到了限制可行域，又做到了“x趋近于边界时进行惩罚”（In无穷大）</p></li></ol><h3 id="二、增广拉格朗日函数法">二、增广拉格朗日函数法</h3><ol><li><strong>结构</strong></li></ol><p><img src="https://s2.loli.net/2023/04/14/67anqbXZ3CoHMRx.png" alt=""></p><ol><li><p><strong>一般约束优化问题的增广拉格朗日函数法</strong></p><p><img src="https://s2.loli.net/2023/04/14/2DK1ludNp9EkQit.png" alt=""></p><p>思路：引入松弛变量将不等式约束转化为等式约束和简单的非负约束，再构造增广拉格朗日函数</p><p><img src="https://s2.loli.net/2023/04/14/9CePmiN4RJXKWHg.png" alt=""></p><p>对上述问题我们可以构造出一个经典的拉格朗日函数</p><p><img src="https://s2.loli.net/2023/04/14/A2b8cl9PHEz4NJf.png" alt=""></p></li></ol><h1>第六章、复合优化算法</h1><h3 id="一、背景">一、背景</h3><p>复合优化问题定义为：</p><p><img src="https://s2.loli.net/2023/04/14/7fLqF8cXxjO3ZVS.png" alt=""></p><p>其中 <em>f</em>(<em>x</em>) 为可微函数（可能非凸），<em>h</em>(<em>x</em>) 可能为不可微函数</p><h3 id="二、近似点梯度法">二、近似点梯度法</h3><ol><li><p><strong>邻近算子</strong></p><p>对于一个凸函数 <em>h</em>，定义它的邻近算子为</p><p><img src="https://s2.loli.net/2023/04/14/MXkIeUJt6zPBFlC.png" alt=""></p><p>可见，邻近算子的目的是求解一个距 <em>x</em> 不算太远的点，并使函数值 <em>h</em>(<em>x</em>) 也相对较小</p></li><li><p><strong>公式</strong></p><p>对于一个复合优化问题</p><p><img src="https://s2.loli.net/2023/04/14/P4NxGtKcvzmS8XF.png" alt=""></p><p>近似点梯度法的思想非常简单：注意到 <em>ψ</em>(<em>x</em>) 有两部分，对于光滑部分<em>f</em> 做梯度下降，对于非光滑部分 <em>h</em> 使用邻近算子，则近似点梯度法的迭代公式为：</p><p><img src="https://s2.loli.net/2023/04/14/aOG3ESCUkqFM5Np.png" alt=""></p><p>其中 <em>tk &gt;</em> 0 为每次迭代的步长，它可以是一个常数或者由线搜索得出。</p><p><img src="https://s2.loli.net/2023/04/14/jTPA6um7OtqriVL.png" alt=""></p></li></ol><h3 id="三、Nesterov加速算法">三、Nesterov加速算法</h3><ol><li><p><strong>FISTA算法</strong>（可对近似点梯度算法进行加速）</p><p>FISTA 算法由两步组成：第一步沿着前两步的计算方向计算一个新点，第二步在该新点处做一步近似点梯度迭代，即</p><p><img src="https://s2.loli.net/2023/04/14/Oyvg5k97UMNCELB.png" alt=""></p><p><img src="https://s2.loli.net/2023/04/14/LFejMiZGSY1V2Nn.png" alt=""></p></li></ol><h3 id="四、分块坐标下降法（block-coordinate-descent，BCD）">四、分块坐标下降法（block coordinate descent，BCD）</h3><ol><li><p><strong>motivation：</strong> 实际问题中的目标函数虽可能有成百上千个自变量，求解十分困难，但当固定其中若干变量时，函数的结构会得到极大的简化，是原问题被拆分为数个只有少数自变量的子问题，这也正是BCD方法的基本思想</p></li><li><p><strong>形式：</strong></p><p><img src="https://s2.loli.net/2023/04/14/Z8oWvxUuVjlCy9H.png" alt=""></p><p>将自变量 <em>x</em> 拆分成 <em>s</em> 个变量块 <em>x</em>1, <em>x</em>2,<em>···</em> , <em>xs</em>，函数 <em>f</em> 是关于 <em>x</em> 的可微函数，每个 <em>ri</em>(<em>xi</em>) 关于 <em>xi</em> 是适当的闭凸函数。 单独考虑每一块自变量时，f 有简单结构，ri 只与第 i 个自变量块有关</p></li><li><p><strong>举例</strong></p><p>考虑二元二次函数的优化问题</p><p><img src="https://s2.loli.net/2023/04/14/Z8oWvxUuVjlCy9H.png" alt=""></p><p>现在对变量 <em>x</em>,<em>y</em> 使用分块坐标下降法求解。当固定 <em>y</em> 时，可知当 <em>x</em> = 2 + <em>y</em>时函数取极小值；当固定 <em>x</em> 时，可知当 <em>y</em> = 1 +*x/*10时函数取极小值。故采用的分块坐标下降法为：</p><p><img src="https://s2.loli.net/2023/04/14/O5J1ovfhcqgCaZt.png" alt=""></p><p>经验证，初始点为(0.5, 0.2)时，经过七次迭代就与最优解相当接近</p><p><img src="https://s2.loli.net/2023/04/14/JDINTVim7MEvOKZ.png" alt=""></p></li></ol><h3 id="五、对偶算法">五、对偶算法</h3><ol><li>对偶思想常用思路有两种：把前面的算法应用到对偶问题上，如对偶近似点梯度法；另一种是同时把原始问题和对偶问题结合起来考虑，如原始-对偶混合梯度类算法 对偶算法主要考虑如下形式的问题：</li></ol><p><img src="https://s2.loli.net/2023/04/14/CVquzigKfx4jYQJ.png" alt=""></p><ol start="2"><li><strong>对偶近似点梯度法</strong></li></ol><p>​如果我们写出上述约束优化问题的拉格朗日函数和增广拉格朗日函数</p><p><img src="https://s2.loli.net/2023/04/14/pfmt3ELqnaowGNk.png" alt=""></p><p>​则迭代格式可以写为</p><p><img src="https://s2.loli.net/2023/04/14/81PytDkENRAsQVY.png" alt=""></p><p>​上述迭代格式又称为**交替极小化方法，**第一步迭代为在拉格朗日函数中关于 <em>x</em> 求极小，第二步迭代为在增广拉格朗日函数中关于 <em>y</em> 求极小，第三步迭代为更新拉格朗日乘子。</p><ol start="3"><li><strong>原始-对偶混合梯度算法（primaldual hybrid gradient, PDHG）</strong></li></ol><p>​PDGH在每次迭代时同时考虑原始变量和对偶变量的更新，这使得它在一定程度上可以有效避免单独针对原始问题或对偶问题求解算法中可能出现的问题 仍然考虑如下形式：</p><p><img src="https://s2.loli.net/2023/04/14/5ERFWfJcpC9xrlb.png" alt=""></p><p>​其中 <em>f</em> , <em>h</em> 是适当的闭凸函数．由于 <em>h</em> 有自共轭性，我们将上述问题变形为：</p><p><img src="https://s2.loli.net/2023/04/14/qclZvI8Y1K5EsGF.png" alt=""></p><p>​此时问题变形为一个极小-极大问题，即一个典型的<strong>鞍点问题</strong>。PDHG 算法交替更新原始变量以及对偶变量，其迭代格式如下：</p><p><img src="https://s2.loli.net/2023/04/14/89ROHGwP5YDfgoc.png" alt=""></p><h3 id="六、交替方向乘子法（alternating-direction-method-of-multipliers-ADMM）">六、交替方向乘子法（alternating direction method of multipliers, ADMM）</h3><ol><li><p><strong>定义：</strong></p><p>本节考虑如下凸问题：</p><p><img src="https://s2.loli.net/2023/04/14/OjyM8sLdxBIUTho.png" alt=""></p><p>注意：很多常见的问题都可转化为上述形式</p><p>如把</p><p><img src="https://s2.loli.net/2023/04/14/ePVhFaBwXq4dG5g.png" alt=""></p><p>转化为：</p><p><img src="https://s2.loli.net/2023/04/14/5NPCMdZmROeQ23B.png" alt=""></p><p>再比如对于<strong>一致性问题</strong>：</p><p><img src="https://s2.loli.net/2023/04/14/4ZTa6v2eUuIQSPx.png" alt=""></p><p>令 <em>x</em> = <em>z</em>，并将 <em>x</em> 复制 <em>N</em> 份，分别为 <em>xi</em>，那么问题转化为：</p><p><img src="https://s2.loli.net/2023/04/14/KVco15f4PrFmuUx.png" alt=""></p><p>如果令$x=(x_1^\mathrm T,x_2^\mathrm T,\cdots,x_N^\mathrm T)^\mathrm T$以及$f_1(x)=\sum\limits_{i=1}^N\phi_i(x_i),\quad f_2(z)=0$ 则此问题可以化为：</p><p><img src="https://s2.loli.net/2023/04/14/lUen9HYD73EhXdW.png" alt=""></p><p>其中矩阵 <em>A</em>1, <em>A</em>2 定义为：</p><p><img src="https://s2.loli.net/2023/04/14/hFfUAVeaGOc731n.png" alt=""></p></li><li><p><strong>迭代格式</strong></p><p>首先写出问题的增广拉格朗日函数</p><p><img src="https://s2.loli.net/2023/04/14/ckdolxbypJTeZ42.png" alt=""></p><p>则迭代格式为：</p></li></ol><p><img src="https://s2.loli.net/2023/04/14/62H5jK1lVUkQrzO.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>科研只为把业毕</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>凸优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>借top K题目思考总结堆（heap）与优先队列（priority_queque）用法</title>
    <link href="/2023/04/13/%E5%80%9FtopK%E9%A2%98%E7%9B%AE%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%94%A8%E6%B3%95/"/>
    <url>/2023/04/13/%E5%80%9FtopK%E9%A2%98%E7%9B%AE%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1>一、前言</h1><p>今天做了传说中的top K ，即“<strong>用大顶堆/小顶堆对数据进行排序</strong>”的经典题目</p><p><img src="https://s2.loli.net/2023/04/13/ayuA9B7DGbOni2p.png" alt=""><br>本题思路：</p><ol><li>用map记录每个元素出现的频率</li><li>用heap对map进行排序并节选出前K个元素</li></ol><p>若第一次见此类题，难点当为heap的原理和对应stl容器（priority_queue）的用法。查阅了一些资料，发现不管是leetcode题解抑或博客文章都写得略语焉不详，对新手不甚友好，故笔者试图用自己的话对其原理进行粗糙解释。</p><hr><h1>二、堆（heap）的原理和用法（下述所有例子默认用小顶堆）</h1><h3 id="1-定义">1.定义</h3><p>（1） 堆是一种具有特殊排序关系的完全二叉树，也就是说，堆首先得具有完全二叉树的所有特性<br>（2） 特殊排序关系指——以小顶堆为例——<strong>每个节点的value都小于其两个子节点</strong> ；大顶堆反之</p><p>下图就是一个典型的小顶堆</p><p><img src="https://s2.loli.net/2023/04/13/LYr9ecyzTOpSwCM.png" alt=""></p><h3 id="3-堆的建立（push）">3.堆的建立（push）</h3><p>对于一个已经建好的堆，push新元素的方法是：</p><ol><li><strong>插入</strong>：将该元素插入到heap的尾部</li><li><strong>比较</strong>：然后不断“上浮”，直至满足堆的条件。所谓“上浮”，就是将该元素与其父节点进行比较，比父节点小则上浮一层，否则不动，一直操作直至上浮不动。</li></ol><p>而若是要从零开始建立一个堆捏？很简单，从第一个元素开始，对每个元素都执行一次push操作就行了。<br>下图展示了从零开始建立一个heap过程</p><p><img src="https://s2.loli.net/2023/04/13/gkV1vRcHpiLSujf.jpg" alt=""></p><h3 id="2-堆的删除（pop）">2.堆的删除（pop）</h3><p>三步走：</p><ol><li><strong>弹出</strong>：将堆顶元素（即最小的那个元素）直接pop</li><li><strong>提上</strong>：将heap的最后一个元素提到堆顶</li><li><strong>下沉</strong>：将提上的这个堆顶元素不断与其子节点比较，大于子节点就下沉一层，直至全满足定义</li></ol><p>如下图所示<br><img src="https://s2.loli.net/2023/04/13/RXMb5QG1VdutzF6.jpg" alt=""></p><hr><h1>三、优先队列（priority_queue）的使用</h1><h3 id="1-定义-2">1.定义</h3><p>我们可以用c++ stl中的priority_queue容器来实现heap的操作，其定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = std::vector&lt;T&gt;,<br>    <span class="hljs-keyword">class</span> Compare = std::less&lt;<span class="hljs-keyword">typename</span> Container::value_type&gt;<br>&gt; <span class="hljs-keyword">class</span> priority_queue;<br></code></pre></td></tr></table></figure><p>T是指堆中元素的<strong>数据类型</strong>；<br>container指用于存储这些元素的<strong>底层容器类型</strong>（<strong>默认用vector</strong>，一般也不用改）；<br>compare是元素之间的<strong>比较方式</strong>，用于决定建立的是大顶堆or小顶堆，默认用less函数建立大顶堆（当然，你也可以自定义compare方法来建立一些奇奇怪怪的堆。。）</p><h3 id="2-常用方法">2.常用方法</h3><p>和普通队列一样，常用的就pop()、push()、top()、empty()</p><h3 id="3-代码示例">3.代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">print_queue</span><span class="hljs-params">(T&amp; q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; q.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : &#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;)<br>        q.<span class="hljs-built_in">push</span>(n);<br> <br>    <span class="hljs-built_in">print_queue</span>(q);<br> <br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt; &gt; q2;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : &#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;)<br>        q2.<span class="hljs-built_in">push</span>(n);<br> <br>    <span class="hljs-built_in">print_queue</span>(q2);<br> <br>    <span class="hljs-comment">// 用 lambda 比较元素。</span><br>    <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123; <span class="hljs-built_in">return</span> (left ^ <span class="hljs-number">1</span>) &lt; (right ^ <span class="hljs-number">1</span>); &#125;;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">q3</span>(cmp);<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : &#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;)<br>        q3.<span class="hljs-built_in">push</span>(n);<br> <br>    <span class="hljs-built_in">print_queue</span>(q3);<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="https://s2.loli.net/2023/04/13/n4RIGtX7NACKceQ.png" alt=""><br>上述代码及运行结果，与前面我手画的那两张图都是吻合的</p><hr><h1>四、题解</h1><p>回到开头那道topK力扣题，答案如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 小顶堆</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> <br>    &#123;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span><br><span class="hljs-function">            </span>&#123;<br>                <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>            &#125;<br>    &#125;;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter : nums) &#123;<br>            map[iter]++;<br>        &#125;<br><br>        <span class="hljs-comment">// 对频率排序</span><br>        <span class="hljs-comment">// 定义一个小顶堆，大小为k</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br><br>        <span class="hljs-comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">begin</span>(); it != map.<span class="hljs-built_in">end</span>(); it++) <br>        &#123;<br>            pri_que.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span> (pri_que.<span class="hljs-built_in">size</span>() &gt; k) &#123; <span class="hljs-comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span><br>                pri_que.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result[i] = pri_que.<span class="hljs-built_in">top</span>().first;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>做一些解释说明：</p><ol><li><p>首先注意，我们要<strong>找出前K大的元素，那要用的是小顶堆</strong>，因为小顶堆才能把小元素排出去，剩下的就是前K大元素嘛</p></li><li><p>map中的单个元素的数据类型是pair&lt;Type, Type&gt;</p></li><li><p>关于compare方法的理解：默认的<strong>less方法建立的是大顶堆</strong>，要<strong>建立小顶堆则改用greater&lt;T&gt;</strong></p><p>然后所谓的less方法，是将第一个实参（称之为左实参）与第二个实参（称之为右实参）进行比较，return left&lt;right——那么左实参更小时则为true，为true则交换；greater方法反之，return left&gt;right；</p><p>在上述代码的自定义方法mycomparison中也可以说明这一点，它使用的是return left&gt;right,即greater方法，即建立小顶堆</p></li></ol><blockquote><p>总结：<br>建立大顶堆 = less方法 = return left &lt; right<br>建立小顶堆 = greater方法 = return left &gt; right</p></blockquote><div class="note note-warning">            <p>TO-DO：<br>上述第三条纯属自己理解，这么死记用来做题应用没啥问题，但还是得挑个良辰吉日去翻翻源码才行捏😣</p>          </div>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>借一道leetcode思考总结map/set的应用及区别</title>
    <link href="/2023/04/13/%E5%80%9F%E4%B8%80%E9%81%93leetcode%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93mapset%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/04/13/%E5%80%9F%E4%B8%80%E9%81%93leetcode%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93mapset%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>原题是leetcode349，要求两个数组的交集</p><p><img src="https://s2.loli.net/2023/04/13/WmNqiBn9R6Lh7f4.png" alt=" "><br>这题本身不难，主要是要考虑到：</p><ol><li>原题只需求“频率”，无需考虑“顺序”，则应使用哈希表结构，而不是顺序结构+两个for暴力遍历</li><li>用于作键值key的是数字而非字母，所以应该用正儿八经的set/map，而不是用vector搞伪hash（否则当数字键值很大且稀疏时，vector会浪费大量空间）</li><li>不需要设置明确的key，所以用set，而不是map</li><li>不考虑顺序，所以用unordered_set</li></ol><p>上述思路理清之后，代码自然就出来了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果，之所以用set是为了给结果集去重</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter : nums2) <br>        &#123;<br>            <span class="hljs-comment">// 发现nums2的元素 在nums_set里又出现过</span><br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(iter) != nums_set.<span class="hljs-built_in">end</span>()) <br>            &#123;<br>                result_set.<span class="hljs-built_in">insert</span>(iter); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由此题我们可以一窥set/map的具体使用场景，下面对其差别和应用进行简单总结</p><hr><h1>一、定义和类型</h1><p>STL中的部分容器（vector、list、deque等）底层为线性序列的数据结构，故将这些容器统称为<strong>序列式容器</strong>，里面存储的是元素本身；对应的，有另外一种用&lt;key，value&gt;键值对方式储存数据的数据结构，我们称其为<strong>关联式容器</strong>，典型的有set类和map类容器。</p><p>这种关联式容器的motivition应该是用某种特殊的底层数据结构来代替线性序列，以避免线性结构容易导致的空间浪费问题，同时提高curd效率 – – 线性序列为O(n)，那再提高就是O(log n)和O(1)，对应的是啥捏？</p><p><em><strong>树和hash table嘛！这也正是set\map的底层实现方式</strong></em></p><p>具体如下：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值可重复</th><th>数值可更改</th><th>curd效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td></tr></tbody></table><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值可重复</th><th>数值可更改</th><th>curd效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>有序</td><td>key不可重复</td><td>否</td><td>O(log n)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>有序</td><td>key可重复</td><td>否</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>key不可重复</td><td>否</td><td>O(1)</td></tr></tbody></table><p>其需要注意的是，set\multiset\map\multimap的实现都为红黑树，红黑树是一种平衡二叉搜索树，所以key有序且不能修改，修改key会导致整棵树的错乱；<br>而我们要用集合来解决hash问题时，优先使用unordered，因为其底层使用hash table，curd效率最高（只需执行一次hash function，复杂度为O(1)）</p><hr><h1>二、set类说明</h1><ol><li>与map/multimap不同，map中存储的是真正的键值对&lt;key, value&gt;，set中只放value，但在底层实际存放的是由&lt;value, value&gt;构成的键值对（即一个元素的value同时也会标识它，value就是key）。故set中插入元素时，<strong>只需要插入value即可，不需要构造键值对</strong></li><li>set中的元素不可以重复，因此可以使用set进行<strong>去重</strong></li><li>set中的元素有序（默认升序），故可用iteration<strong>遍历set得有序序列</strong></li><li>set中的元素<strong>不允许修改</strong>（元素总是const）</li><li>set中的count()方法只能返回0或1，所以其实就是个find()。。而find()返回的是查找元素的位置指针，没有则返回set.end()</li><li>multiset与set的区别是<strong>前者中的元素可重复</strong>，其它都一样</li><li>unordered_set与set的区别是<strong>前者中的元素不会排序</strong></li></ol><p>代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestSet</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 用数组array中的元素构造set</span><br><span class="hljs-type">int</span> array[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span> &#125;;<br>set&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : array)<br>s.<span class="hljs-built_in">insert</span>(e);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;set中的元素个数为: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">// 正向打印set中的元素，从打印结果中可以看出：set可去重</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;正向打印set中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : s)<br>cout&lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 使用迭代器逆向打印set中的元素</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;逆向打印set中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">rbegin</span>(); it != s.<span class="hljs-built_in">rend</span>(); ++it)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// set中值为3的元素出现了几次</span><br>cout &lt;&lt; <span class="hljs-string">&quot;set中值为x的元素出现了几次：&quot;</span> &lt;&lt; s.<span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br><br>    <span class="hljs-function">multiset&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">muls</span><span class="hljs-params">(array, array + <span class="hljs-keyword">sizeof</span>(array) / <span class="hljs-keyword">sizeof</span>(array[<span class="hljs-number">0</span>]))</span></span>;<br>    cout &lt;&lt;  <span class="hljs-string">&quot;正向打印multiset中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : muls)<br>cout &lt;&lt;e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><br>    <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">unorders</span><span class="hljs-params">(array, array + <span class="hljs-keyword">sizeof</span>(array) / <span class="hljs-keyword">sizeof</span>(array[<span class="hljs-number">0</span>]))</span></span>;<br>    cout &lt;&lt;  <span class="hljs-string">&quot;打印unordered_set中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : unorders)<br>cout &lt;&lt;e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">TestSet</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="https://s2.loli.net/2023/04/13/w8kQyJztoIBaq1E.png" alt=""></p><hr><h1>三、map类说明</h1><ol><li>需要<strong>构造键值对</strong></li><li>map支持下标访问符，即在[]中放入key，就可以找到与key对应的value；<a href="http://xn--ujqw61c2rb.at">也支持.at</a>()方法，但二者有所不同（见下面代码）</li><li>multimap和map的唯一不同就是：map中的<strong>key是唯一</strong>的，而multimap中key是<strong>可以重复的</strong></li><li>unordered_map和map : : unordered_map存储元素时是<strong>没有顺序的</strong>，只是根据key的哈希值，将元素存在指定位置，所以根据key查找单个value时非常高效</li></ol><p>代码示例（来源: <a href="https://blog.csdn.net/qq_61635026/article/details/126070134?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166593410616782412589556%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=166593410616782412589556&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-126070134-null-null.142%5Ev56%5Econtrol_1,201%5Ev3%5Econtrol_2&amp;utm_term=stl%20set%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB&amp;spm=1018.2226.3001.4187">C++ STL中 set和map介绍以及使用方法</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestMap</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;string, string&gt; m;<br><span class="hljs-comment">// 向map中插入元素的方式：</span><br><span class="hljs-comment">// 将键值对&lt;&quot;peach&quot;,&quot;桃子&quot;&gt;插入map中，用pair直接来构造键值对</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, string&gt;(<span class="hljs-string">&quot;peach&quot;</span>, <span class="hljs-string">&quot;桃子&quot;</span>));<br><span class="hljs-comment">// 将键值对&lt;&quot;peach&quot;,&quot;桃子&quot;&gt;插入map中，用make_pair函数来构造键值对</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;banan&quot;</span>, <span class="hljs-string">&quot;香蕉&quot;</span>));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">operator[]的原理是：</span><br><span class="hljs-comment"> 用&lt;key, T()&gt;构造一个键值对，然后调用insert()函数将该键值对插入到map中</span><br><span class="hljs-comment"> 如果key已经存在，插入失败，insert函数返回该key所在位置的迭代器</span><br><span class="hljs-comment"> 如果key不存在，插入成功，insert函数返回新插入元素所在位置的迭代器</span><br><span class="hljs-comment"> operator[]函数最后将insert返回值键值对中的value返回</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 将&lt;&quot;apple&quot;, &quot;&quot;&gt;插入map中，插入成功，返回value的引用，将“苹果”赋值给该引用结果</span><br>m[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-string">&quot;苹果&quot;</span>;<br><br><span class="hljs-comment">// key不存在时抛异常</span><br><span class="hljs-comment">//m.at(&quot;waterme&quot;) = &quot;水蜜桃&quot;;</span><br><br>cout &lt;&lt; m.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 用迭代器去遍历map中的元素，可以得到一个按照key排序的序列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : m)<br>cout &lt;&lt; e.first &lt;&lt; <span class="hljs-string">&quot;---&gt;&quot;</span> &lt;&lt; e.second &lt;&lt; endl;<br>cout &lt;&lt; endl;<br><span class="hljs-comment">// map中的键值对key一定是唯一的，如果key存在将插入失败</span><br><span class="hljs-keyword">auto</span> ret = m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;peach&quot;</span>, <span class="hljs-string">&quot;another桃子&quot;</span>));<br><span class="hljs-keyword">if</span> (ret.second)<br>cout &lt;&lt; <span class="hljs-string">&quot;&lt;peach, another桃子&gt;不在map中, 已经插入&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot;键值为peach的元素已经存在：&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="hljs-string">&quot;---&gt;&quot;</span><br>&lt;&lt; ret.first-&gt;second &lt;&lt; <span class="hljs-string">&quot; 插入失败&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 删除key为&quot;apple&quot;的元素</span><br>m.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;apple&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == m.<span class="hljs-built_in">count</span>(<span class="hljs-string">&quot;apple&quot;</span>))<br>cout &lt;&lt; <span class="hljs-string">&quot;apple还在&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot;apple被吃了&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">TestMap</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.loli.net/2023/04/13/A3rM12B8DJKzVS7.png" alt=""><br>如果用at()查值，则key不在时抛出异常</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;waterme&quot;</span>) = <span class="hljs-string">&quot;水蜜桃&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/13/bMPIHgarpTBKlu1.png" alt=""></p><hr><h1>总结</h1><p><strong>1. 用set类还是map类？</strong><br>如果需要建立明确的<strong>键值对应关系</strong>（如示例中的水果），那只能用map；如果只需知道“<strong>存在与否</strong>”，那用set就够了（如leetcode例题，其实没有体现一个明确的key，coding时关心的也是value而不是key）</p><p><strong>2. 用set类还是array伪hash？</strong><br>如果key分布在一个<strong>不大的连续区间</strong>内（ 如26个字母），则可以直接用array，这样更快，因为set不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的；<br>但如果key随机则用set，如key为<strong>分布稀疏</strong>的大数字时，用数组就非常浪费空间，只能用set。</p><p><strong>3. 用set还是unordered_set？（map同理）</strong><br>有序set（红黑树），无序unordered_set（hash table）</p><p><strong>PS.</strong> py中的in关键字在不同结构中（tuple, list, dict, set）查找元素时效率是相差很大的，因为dict, set底层是一个hash table；而tuple, list只是一个单纯类于数组的线性结构。。</p>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
      <tag>哈希算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记位运算符(＞＞)使用不当引起的一次bug</title>
    <link href="/2023/04/13/%E8%AE%B0%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6(%EF%BC%9E%EF%BC%9E)%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%80%E6%AC%A1bug/"/>
    <url>/2023/04/13/%E8%AE%B0%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6(%EF%BC%9E%EF%BC%9E)%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%80%E6%AC%A1bug/</url>
    
    <content type="html"><![CDATA[<h1>问题描述</h1><p>今天刷leetcode时遇到个死活也想不通的bug</p><p>原题很简单，线性数组插值问题，暴力遍历和二分法都可以做</p><p><img src="https://s2.loli.net/2023/04/13/ifSOReA2dapUFsh.png" alt=""><br>不假思索用区间左闭右开的二分法，三下五除二就整了出来，胸有成竹😋</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.size();<br>        <span class="hljs-keyword">while</span>(left &lt; right)<br>        &#123;<br>            <span class="hljs-type">int</span> middle = left + (right - left) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target )<br>                right = middle;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target )<br>                left = middle + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>谁知提交时一直在示例3（即输入数组为[1 3 5 6]，查询值target = 7）卡bug，提示超时。。</p><hr><h1>原因分析：</h1><p>原以为是区间边界条件设置不当，反复检查，手动演算，脑袋想破了也觉得没问题。。</p><p>无奈debug，发现执行这一句后，middle一值变化很奇怪。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> middle = left + (right - left) &gt;&gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>突然虎躯一震，意识到可能是运算符优先级一问题，速google之，果然！</p><p><img src="https://s2.loli.net/2023/04/13/ildhp5643oy9vXw.png" alt=""></p><p><em><strong>原来加减符的优先级是要高于位运算符的！</strong></em><br>一验证发现也的确如此<br><img src="https://s2.loli.net/2023/04/13/r8KHytNjmulQXIv.png" alt=""></p><p><img src="https://s2.loli.net/2023/04/13/pCmWrFxzQE8AY1T.png" alt=""></p><hr><h1>解决方案：</h1><p>加个括号即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> middle = left +( (right - left) &gt;&gt; <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>问题解决，顺利通关！</p><p><img src="https://s2.loli.net/2023/04/13/vtzFBo3YmZqg4XV.png" alt=""></p><hr><h1>总结反思：</h1><ol><li>善于使用括号，尤其是主观上希望某个式子部分先运算时。</li><li>老老实实用乘除得了，别整些什么花里胡哨trick。。代码省下几毫秒，debug多花几十分钟。。</li></ol>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
