<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>借top K题目思考总结堆（heap）与优先队列（priority_queque）用法</title>
    <link href="/2023/04/13/%E5%80%9FtopK%E9%A2%98%E7%9B%AE%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%94%A8%E6%B3%95/"/>
    <url>/2023/04/13/%E5%80%9FtopK%E9%A2%98%E7%9B%AE%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>今天做了传说中的top K ，即“<strong>用大顶堆&#x2F;小顶堆对数据进行排序</strong>”的经典题目</p><p><img src="https://s2.loli.net/2023/04/13/ayuA9B7DGbOni2p.png"><br>本题思路：</p><ol><li>用map记录每个元素出现的频率</li><li>用heap对map进行排序并节选出前K个元素</li></ol><p>若第一次见此类题，难点当为heap的原理和对应stl容器（priority_queue）的用法。查阅了一些资料，发现不管是leetcode题解抑或博客文章都写得略语焉不详，对新手不甚友好，故笔者试图用自己的话对其原理进行粗糙解释。</p><hr><h1 id="二、堆（heap）的原理和用法（下述所有例子默认用小顶堆）"><a href="#二、堆（heap）的原理和用法（下述所有例子默认用小顶堆）" class="headerlink" title="二、堆（heap）的原理和用法（下述所有例子默认用小顶堆）"></a>二、堆（heap）的原理和用法（下述所有例子默认用小顶堆）</h1><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>（1） 堆是一种具有特殊排序关系的完全二叉树，也就是说，堆首先得具有完全二叉树的所有特性<br>（2） 特殊排序关系指——以小顶堆为例——<strong>每个节点的value都小于其两个子节点</strong> ；大顶堆反之</p><p>下图就是一个典型的小顶堆</p><p><img src="https://s2.loli.net/2023/04/13/LYr9ecyzTOpSwCM.png"></p><h3 id="3-堆的建立（push）"><a href="#3-堆的建立（push）" class="headerlink" title="3.堆的建立（push）"></a>3.堆的建立（push）</h3><p>对于一个已经建好的堆，push新元素的方法是：</p><ol><li><strong>插入</strong>：将该元素插入到heap的尾部</li><li><strong>比较</strong>：然后不断“上浮”，直至满足堆的条件。所谓“上浮”，就是将该元素与其父节点进行比较，比父节点小则上浮一层，否则不动，一直操作直至上浮不动。</li></ol><p>而若是要从零开始建立一个堆捏？很简单，从第一个元素开始，对每个元素都执行一次push操作就行了。<br>下图展示了从零开始建立一个heap过程</p><p><img src="https://s2.loli.net/2023/04/13/gkV1vRcHpiLSujf.jpg"></p><h3 id="2-堆的删除（pop）"><a href="#2-堆的删除（pop）" class="headerlink" title="2.堆的删除（pop）"></a>2.堆的删除（pop）</h3><p>三步走：</p><ol><li><strong>弹出</strong>：将堆顶元素（即最小的那个元素）直接pop</li><li><strong>提上</strong>：将heap的最后一个元素提到堆顶</li><li><strong>下沉</strong>：将提上的这个堆顶元素不断与其子节点比较，大于子节点就下沉一层，直至全满足定义</li></ol><p>如下图所示<br><img src="https://s2.loli.net/2023/04/13/RXMb5QG1VdutzF6.jpg"></p><hr><h1 id="三、优先队列（priority-queue）的使用"><a href="#三、优先队列（priority-queue）的使用" class="headerlink" title="三、优先队列（priority_queue）的使用"></a>三、优先队列（priority_queue）的使用</h1><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>我们可以用c++ stl中的priority_queue容器来实现heap的操作，其定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = std::vector&lt;T&gt;,<br>    <span class="hljs-keyword">class</span> Compare = std::less&lt;<span class="hljs-keyword">typename</span> Container::value_type&gt;<br>&gt; <span class="hljs-keyword">class</span> priority_queue;<br></code></pre></td></tr></table></figure><p>T是指堆中元素的<strong>数据类型</strong>；<br>container指用于存储这些元素的<strong>底层容器类型</strong>（<strong>默认用vector</strong>，一般也不用改）；<br>compare是元素之间的<strong>比较方式</strong>，用于决定建立的是大顶堆or小顶堆，默认用less函数建立大顶堆（当然，你也可以自定义compare方法来建立一些奇奇怪怪的堆。。）</p><h3 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h3><p>和普通队列一样，常用的就pop()、push()、top()、empty()</p><h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3.代码示例"></a>3.代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">print_queue</span><span class="hljs-params">(T&amp; q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; q.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : &#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;)<br>        q.<span class="hljs-built_in">push</span>(n);<br> <br>    <span class="hljs-built_in">print_queue</span>(q);<br> <br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt; &gt; q2;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : &#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;)<br>        q2.<span class="hljs-built_in">push</span>(n);<br> <br>    <span class="hljs-built_in">print_queue</span>(q2);<br> <br>    <span class="hljs-comment">// 用 lambda 比较元素。</span><br>    <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123; <span class="hljs-built_in">return</span> (left ^ <span class="hljs-number">1</span>) &lt; (right ^ <span class="hljs-number">1</span>); &#125;;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">q3</span>(cmp);<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : &#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;)<br>        q3.<span class="hljs-built_in">push</span>(n);<br> <br>    <span class="hljs-built_in">print_queue</span>(q3);<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="https://s2.loli.net/2023/04/13/n4RIGtX7NACKceQ.png"><br>上述代码及运行结果，与前面我手画的那两张图都是吻合的</p><hr><h1 id="四、题解"><a href="#四、题解" class="headerlink" title="四、题解"></a>四、题解</h1><p>回到开头那道topK力扣题，答案如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 小顶堆</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> <br>    &#123;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span><br><span class="hljs-function">            </span>&#123;<br>                <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>            &#125;<br>    &#125;;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter : nums) &#123;<br>            map[iter]++;<br>        &#125;<br><br>        <span class="hljs-comment">// 对频率排序</span><br>        <span class="hljs-comment">// 定义一个小顶堆，大小为k</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br><br>        <span class="hljs-comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">begin</span>(); it != map.<span class="hljs-built_in">end</span>(); it++) <br>        &#123;<br>            pri_que.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span> (pri_que.<span class="hljs-built_in">size</span>() &gt; k) &#123; <span class="hljs-comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span><br>                pri_que.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result[i] = pri_que.<span class="hljs-built_in">top</span>().first;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>做一些解释说明：</p><ol><li><p>首先注意，我们要<strong>找出前K大的元素，那要用的是小顶堆</strong>，因为小顶堆才能把小元素排出去，剩下的就是前K大元素嘛</p></li><li><p>map中的单个元素的数据类型是pair&lt;Type, Type&gt;</p></li><li><p>关于compare方法的理解：默认的<strong>less方法建立的是大顶堆</strong>，要<strong>建立小顶堆则改用greater&lt;T&gt;</strong></p><p>然后所谓的less方法，是将第一个实参（称之为左实参）与第二个实参（称之为右实参）进行比较，return left&lt;right——那么左实参更小时则为true，为true则交换；greater方法反之，return left&gt;right；</p><p>在上述代码的自定义方法mycomparison中也可以说明这一点，它使用的是return left&gt;right,即greater方法，即建立小顶堆</p></li></ol><blockquote><p>总结：<br>建立大顶堆 &#x3D; less方法 &#x3D; return left &lt; right<br>建立小顶堆 &#x3D; greater方法 &#x3D; return left &gt; right</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% note success %&#125;<br>TO-DO：<br>上述第三条纯属自己理解，这么死记用来做题应用没啥问题，但还是得挑个良辰吉日去翻翻源码才行捏😣<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>借一道leetcode思考总结map/set的应用及区别</title>
    <link href="/2023/04/13/%E5%80%9F%E4%B8%80%E9%81%93leetcode%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93mapset%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/04/13/%E5%80%9F%E4%B8%80%E9%81%93leetcode%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93mapset%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原题是leetcode349，要求两个数组的交集</p><p><img src="https://s2.loli.net/2023/04/13/WmNqiBn9R6Lh7f4.png" alt=" "><br>这题本身不难，主要是要考虑到：</p><ol><li>原题只需求“频率”，无需考虑“顺序”，则应使用哈希表结构，而不是顺序结构+两个for暴力遍历</li><li>用于作键值key的是数字而非字母，所以应该用正儿八经的set&#x2F;map，而不是用vector搞伪hash（否则当数字键值很大且稀疏时，vector会浪费大量空间） </li><li>不需要设置明确的key，所以用set，而不是map</li><li>不考虑顺序，所以用unordered_set</li></ol><p>上述思路理清之后，代码自然就出来了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果，之所以用set是为了给结果集去重</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter : nums2) <br>        &#123;<br>            <span class="hljs-comment">// 发现nums2的元素 在nums_set里又出现过</span><br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(iter) != nums_set.<span class="hljs-built_in">end</span>()) <br>            &#123;<br>                result_set.<span class="hljs-built_in">insert</span>(iter); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由此题我们可以一窥set&#x2F;map的具体使用场景，下面对其差别和应用进行简单总结</p><hr><h1 id="一、定义和类型"><a href="#一、定义和类型" class="headerlink" title="一、定义和类型"></a>一、定义和类型</h1><p>STL中的部分容器（vector、list、deque等）底层为线性序列的数据结构，故将这些容器统称为<strong>序列式容器</strong>，里面存储的是元素本身；对应的，有另外一种用&lt;key，value&gt;键值对方式储存数据的数据结构，我们称其为<strong>关联式容器</strong>，典型的有set类和map类容器。</p><p>这种关联式容器的motivition应该是用某种特殊的底层数据结构来代替线性序列，以避免线性结构容易导致的空间浪费问题，同时提高curd效率 – – 线性序列为O(n)，那再提高就是O(log n)和O(1)，对应的是啥捏？</p><p><em><strong>树和hash table嘛！这也正是set\map的底层实现方式</strong></em></p><p>具体如下：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值可重复</th><th>数值可更改</th><th>curd效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td></tr></tbody></table><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值可重复</th><th>数值可更改</th><th>curd效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>有序</td><td>key不可重复</td><td>否</td><td>O(log n)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>有序</td><td>key可重复</td><td>否</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>key不可重复</td><td>否</td><td>O(1)</td></tr></tbody></table><p>其需要注意的是，set\multiset\map\multimap的实现都为红黑树，红黑树是一种平衡二叉搜索树，所以key有序且不能修改，修改key会导致整棵树的错乱；<br>而我们要用集合来解决hash问题时，优先使用unordered，因为其底层使用hash table，curd效率最高（只需执行一次hash function，复杂度为O(1)）</p><hr><h1 id="二、set类说明"><a href="#二、set类说明" class="headerlink" title="二、set类说明"></a>二、set类说明</h1><ol><li>与map&#x2F;multimap不同，map中存储的是真正的键值对&lt;key, value&gt;，set中只放value，但在底层实际存放的是由&lt;value, value&gt;构成的键值对（即一个元素的value同时也会标识它，value就是key）。故set中插入元素时，<strong>只需要插入value即可，不需要构造键值对</strong></li><li>set中的元素不可以重复，因此可以使用set进行<strong>去重</strong></li><li>set中的元素有序（默认升序），故可用iteration<strong>遍历set得有序序列</strong></li><li>set中的元素<strong>不允许修改</strong>（元素总是const）</li><li>set中的count()方法只能返回0或1，所以其实就是个find()。。而find()返回的是查找元素的位置指针，没有则返回set.end()</li><li>multiset与set的区别是<strong>前者中的元素可重复</strong>，其它都一样</li><li>unordered_set与set的区别是<strong>前者中的元素不会排序</strong></li></ol><p>代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestSet</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 用数组array中的元素构造set</span><br><span class="hljs-type">int</span> array[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span> &#125;;<br>set&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : array)<br>s.<span class="hljs-built_in">insert</span>(e);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;set中的元素个数为: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">// 正向打印set中的元素，从打印结果中可以看出：set可去重</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;正向打印set中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : s)<br>cout&lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 使用迭代器逆向打印set中的元素</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;逆向打印set中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">rbegin</span>(); it != s.<span class="hljs-built_in">rend</span>(); ++it)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// set中值为3的元素出现了几次</span><br>cout &lt;&lt; <span class="hljs-string">&quot;set中值为x的元素出现了几次：&quot;</span> &lt;&lt; s.<span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br><br>    <span class="hljs-function">multiset&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">muls</span><span class="hljs-params">(array, array + <span class="hljs-keyword">sizeof</span>(array) / <span class="hljs-keyword">sizeof</span>(array[<span class="hljs-number">0</span>]))</span></span>;<br>    cout &lt;&lt;  <span class="hljs-string">&quot;正向打印multiset中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : muls)<br>cout &lt;&lt;e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><br>    <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">unorders</span><span class="hljs-params">(array, array + <span class="hljs-keyword">sizeof</span>(array) / <span class="hljs-keyword">sizeof</span>(array[<span class="hljs-number">0</span>]))</span></span>;<br>    cout &lt;&lt;  <span class="hljs-string">&quot;打印unordered_set中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : unorders)<br>cout &lt;&lt;e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">TestSet</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<br> <img src="https://s2.loli.net/2023/04/13/w8kQyJztoIBaq1E.png"></p><hr><h1 id="三、map类说明"><a href="#三、map类说明" class="headerlink" title="三、map类说明"></a>三、map类说明</h1><ol><li>需要<strong>构造键值对</strong></li><li>map支持下标访问符，即在[]中放入key，就可以找到与key对应的value；也支持.at()方法，但二者有所不同（见下面代码）</li><li>multimap和map的唯一不同就是：map中的<strong>key是唯一</strong>的，而multimap中key是<strong>可以重复的</strong></li><li>unordered_map和map : : unordered_map存储元素时是<strong>没有顺序的</strong>，只是根据key的哈希值，将元素存在指定位置，所以根据key查找单个value时非常高效</li></ol><p>代码示例（来源: <a href="https://blog.csdn.net/qq_61635026/article/details/126070134?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166593410616782412589556%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166593410616782412589556&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-126070134-null-null.142%5Ev56%5Econtrol_1,201%5Ev3%5Econtrol_2&utm_term=stl%20set%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB&spm=1018.2226.3001.4187">C++ STL中 set和map介绍以及使用方法</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestMap</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;string, string&gt; m;<br><span class="hljs-comment">// 向map中插入元素的方式：</span><br><span class="hljs-comment">// 将键值对&lt;&quot;peach&quot;,&quot;桃子&quot;&gt;插入map中，用pair直接来构造键值对</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, string&gt;(<span class="hljs-string">&quot;peach&quot;</span>, <span class="hljs-string">&quot;桃子&quot;</span>));<br><span class="hljs-comment">// 将键值对&lt;&quot;peach&quot;,&quot;桃子&quot;&gt;插入map中，用make_pair函数来构造键值对</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;banan&quot;</span>, <span class="hljs-string">&quot;香蕉&quot;</span>));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">operator[]的原理是：</span><br><span class="hljs-comment"> 用&lt;key, T()&gt;构造一个键值对，然后调用insert()函数将该键值对插入到map中</span><br><span class="hljs-comment"> 如果key已经存在，插入失败，insert函数返回该key所在位置的迭代器</span><br><span class="hljs-comment"> 如果key不存在，插入成功，insert函数返回新插入元素所在位置的迭代器</span><br><span class="hljs-comment"> operator[]函数最后将insert返回值键值对中的value返回</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 将&lt;&quot;apple&quot;, &quot;&quot;&gt;插入map中，插入成功，返回value的引用，将“苹果”赋值给该引用结果</span><br>m[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-string">&quot;苹果&quot;</span>;<br><br><span class="hljs-comment">// key不存在时抛异常</span><br><span class="hljs-comment">//m.at(&quot;waterme&quot;) = &quot;水蜜桃&quot;;</span><br><br>cout &lt;&lt; m.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 用迭代器去遍历map中的元素，可以得到一个按照key排序的序列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : m)<br>cout &lt;&lt; e.first &lt;&lt; <span class="hljs-string">&quot;---&gt;&quot;</span> &lt;&lt; e.second &lt;&lt; endl;<br>cout &lt;&lt; endl;<br><span class="hljs-comment">// map中的键值对key一定是唯一的，如果key存在将插入失败</span><br><span class="hljs-keyword">auto</span> ret = m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;peach&quot;</span>, <span class="hljs-string">&quot;another桃子&quot;</span>));<br><span class="hljs-keyword">if</span> (ret.second)<br>cout &lt;&lt; <span class="hljs-string">&quot;&lt;peach, another桃子&gt;不在map中, 已经插入&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot;键值为peach的元素已经存在：&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="hljs-string">&quot;---&gt;&quot;</span><br>&lt;&lt; ret.first-&gt;second &lt;&lt; <span class="hljs-string">&quot; 插入失败&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 删除key为&quot;apple&quot;的元素</span><br>m.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;apple&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == m.<span class="hljs-built_in">count</span>(<span class="hljs-string">&quot;apple&quot;</span>))<br>cout &lt;&lt; <span class="hljs-string">&quot;apple还在&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot;apple被吃了&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">TestMap</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p> <img src="https://s2.loli.net/2023/04/13/A3rM12B8DJKzVS7.png"><br>如果用at()查值，则key不在时抛出异常</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;waterme&quot;</span>) = <span class="hljs-string">&quot;水蜜桃&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/13/bMPIHgarpTBKlu1.png"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>1. 用set类还是map类？</strong><br>如果需要建立明确的<strong>键值对应关系</strong>（如示例中的水果），那只能用map；如果只需知道“<strong>存在与否</strong>”，那用set就够了（如leetcode例题，其实没有体现一个明确的key，coding时关心的也是value而不是key）</p><p><strong>2. 用set类还是array伪hash？</strong><br>如果key分布在一个<strong>不大的连续区间</strong>内（ 如26个字母），则可以直接用array，这样更快，因为set不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的；<br>但如果key随机则用set，如key为<strong>分布稀疏</strong>的大数字时，用数组就非常浪费空间，只能用set。</p><p><strong>3. 用set还是unordered_set？（map同理）</strong><br>有序set（红黑树），无序unordered_set（hash table）</p><p><strong>PS.</strong> py中的in关键字在不同结构中（tuple, list, dict, set）查找元素时效率是相差很大的，因为dict, set底层是一个hash table；而tuple, list只是一个单纯类于数组的线性结构。。</p>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
      <tag>哈希算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分类占坑2</title>
    <link href="/2023/04/13/%E5%8D%A0%E4%B8%AA%E5%9D%912/"/>
    <url>/2023/04/13/%E5%8D%A0%E4%B8%AA%E5%9D%912/</url>
    
    <content type="html"><![CDATA[<p>这篇文章只是为了在分类板块中占个坑😆😆</p><p>顺便作为测试</p><p>这是一句话<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="参考资料1">[1]</span></a></sup></p><p>正文</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><p class="note note-primary">标签</p><span class="label label-primary">text</span><p><span class="label label-primary">Label</span></p>            <input type="checkbox" disabled checked="checked">text          <a class="btn" href="url"  title="title" target="_blank">text</a><p><a class="btn" href="url" title="title">text</a></p><p>$$<br>E&#x3D;mc^2<br>$$<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这是对应的脚注<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span>参考资料1<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>参考资料2<br><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    <categories>
      
      <category>偶尔也得摸摸鱼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记位运算符(＞＞)使用不当引起的一次bug</title>
    <link href="/2023/04/13/%E8%AE%B0%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6(%EF%BC%9E%EF%BC%9E)%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%80%E6%AC%A1bug/"/>
    <url>/2023/04/13/%E8%AE%B0%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6(%EF%BC%9E%EF%BC%9E)%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%80%E6%AC%A1bug/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>今天刷leetcode时遇到个死活也想不通的bug</p><p>原题很简单，线性数组插值问题，暴力遍历和二分法都可以做</p><p> <img src="https://s2.loli.net/2023/04/13/ifSOReA2dapUFsh.png"><br>不假思索用区间左闭右开的二分法，三下五除二就整了出来，胸有成竹😋</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.size();<br>        <span class="hljs-keyword">while</span>(left &lt; right)<br>        &#123;<br>            <span class="hljs-type">int</span> middle = left + (right - left) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target )<br>                right = middle;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target )<br>                left = middle + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>谁知提交时一直在示例3（即输入数组为[1 3 5 6]，查询值target &#x3D; 7）卡bug，提示超时。。</p><hr><h1 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h1><p>原以为是区间边界条件设置不当，反复检查，手动演算，脑袋想破了也觉得没问题。。</p><p>无奈debug，发现执行这一句后，middle一值变化很奇怪。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> middle = left + (right - left) &gt;&gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>突然虎躯一震，意识到可能是运算符优先级一问题，速google之，果然！</p><p><img src="https://s2.loli.net/2023/04/13/ildhp5643oy9vXw.png"></p><p><em><strong>原来加减符的优先级是要高于位运算符的！</strong></em><br>一验证发现也的确如此<br><img src="https://s2.loli.net/2023/04/13/r8KHytNjmulQXIv.png"></p><p><img src="https://s2.loli.net/2023/04/13/pCmWrFxzQE8AY1T.png"></p><hr><h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><p>加个括号即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> middle = left +( (right - left) &gt;&gt; <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>问题解决，顺利通关！</p><p><img src="https://s2.loli.net/2023/04/13/vtzFBo3YmZqg4XV.png"></p><hr><h1 id="总结反思："><a href="#总结反思：" class="headerlink" title="总结反思："></a>总结反思：</h1><ol><li>善于使用括号，尤其是主观上希望某个式子部分先运算时。</li><li>老老实实用乘除得了，别整些什么花里胡哨trick。。代码省下几毫秒，debug多花几十分钟。。</li></ol>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
