<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>最优化计算方法（文再文）笔记</title>
    <link href="/2023/04/13/%E3%80%8A%E6%9C%80%E4%BC%98%E5%8C%96%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E6%96%87%E5%86%8D%E6%96%87%EF%BC%89%E7%AC%94%E8%AE%B0%E3%80%8B/"/>
    <url>/2023/04/13/%E3%80%8A%E6%9C%80%E4%BC%98%E5%8C%96%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E6%96%87%E5%86%8D%E6%96%87%EF%BC%89%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="《最优化计算方法（文再文）笔记》"><a href="#《最优化计算方法（文再文）笔记》" class="headerlink" title="《最优化计算方法（文再文）笔记》"></a>《最优化计算方法（文再文）笔记》</h1><h1 id="第一章、最优化简介"><a href="#第一章、最优化简介" class="headerlink" title="第一章、最优化简介"></a>第一章、最优化简介</h1><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><ol><li><p><strong>最优化问题一般形式：</strong></p><p><img src="https://s2.loli.net/2023/04/14/wazjU2bHxYqCuVs.png"></p><p>其中$x&#x3D;(x_1,x_2,…,x_n)^T\in R^n$是<strong>决策变量</strong></p><p>$f:R^n\rightarrow R$是<strong>目标函数</strong></p><p>$\chi\in R^n$是约束集合，即<strong>可行域</strong></p><p>s.t.是subject to，专指<strong>约束条件</strong></p><p>但f(x)的min&#x2F;max不总是存在的，此时我们关心其上下确界，即将上式改为inf(sup) f(x)</p></li><li><p><strong>最优化问题分类</strong></p><ul><li>目标函数和约束函数皆为线性时，称为线性规划</li><li>至少有一个非线性时称为非线性规划</li><li>目标函数为二次函数时称为二次规划</li><li>还有整数规划、非光滑规划、无导数规划等。。</li></ul></li><li><p><strong>凸优化</strong></p><p>定义：最小化问题中，目标函数和可行域分别是凸函数和凸集；相反，只要有一个不为凸，则为非凸优化问题。因为凸优化问题的任何局部最优解都是全局最优解，所以其相应的算法设计以及理论分析相对非凸优化问题简单很多。</p><aside> 💡 PS. 所以用凸模型对非凸问题进行转换/逼近是一个很重要的手段</aside></li></ol><h1 id="第二章、基础知识"><a href="#第二章、基础知识" class="headerlink" title="第二章、基础知识"></a>第二章、基础知识</h1><h3 id="一、概述-1"><a href="#一、概述-1" class="headerlink" title="一、概述"></a>一、概述</h3><ol><li><p><strong>矩阵范数</strong></p><p>当p&#x3D;1时，矩阵$A\in R^{m×n}$的$l_1$范数定义为：<br>$$<br>\lVert A \rVert_1&#x3D;\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^n\vert a_{ij} \vert<br>$$<br>p&#x3D;2时：<br>$$<br>\lVert A \rVert_2&#x3D;\sqrt{Tr(AA^T)}&#x3D;\sqrt{\sum_{i,j}a_{ij}^2}<br>$$<br>Tr(X)表示方阵的迹，即方阵的主对角线的元素之和</p><div class="note note-warning">            <p>💡 PS. 一个结论： 矩阵的2范数是该矩阵的最大奇异值（why？）</p>          </div></li><li><p><strong>海瑟矩阵</strong></p><p><img src="https://s2.loli.net/2023/04/14/BECN3juMKan6xLo.png"></p></li><li><p><strong>矩阵变量函数的导数</strong></p><p><img src="https://s2.loli.net/2023/04/14/hzEMxDuX9WcHiyt.png"></p><p><img src="https://s2.loli.net/2023/04/14/219YjdlZ5aShr3x.png"></p></li><li><p><strong>凸集</strong></p><p>如果连接集合C中任意两点的线段都在C内，则称C为凸集</p><p><img src="https://s2.loli.net/2023/04/14/bRu7fcMCqldoD6W.png"></p></li><li><p><strong>凸包</strong></p><p>对于形如</p><p><img src="https://s2.loli.net/2023/04/14/HZlsb1pIMCx6Gwc.png"></p><p>的点称为x1、x2。。。xk构成的<strong>凸组合</strong>，集合S中点所有可能的凸组合构成的集合称作S的<strong>凸包</strong>，记作<strong>convS</strong>．实际上，<strong>convS</strong>是包含S的最小的凸集。如下图所示，分别为离散点集的凸包和扇形的凸包。</p><p><img src="https://s2.loli.net/2023/04/14/luNXMaWSRO12Ko4.png"></p></li><li><p><strong>一些重要的凸集</strong></p><ul><li>超平面和半空间</li></ul><p><img src="https://s2.loli.net/2023/04/14/xw7VaQyXfHuZlbA.png"></p><ul><li>球、椭球、椎</li></ul><p>常规的球、椭球、椎的定义用的是欧几里得范数，但可用其它范数进行概念推广</p><p>多面体</p><ul><li>（半）正定椎</li></ul><p><img src="https://s2.loli.net/2023/04/14/DEHSgQ6AaeNpC5w.png"></p></li><li><p><strong>强凸函数</strong></p><p><img src="https://s2.loli.net/2023/04/14/Aoa2UdNbKrw7chf.png" alt="Untitled"></p><p>强凸函数减去一个正定二次函数仍然是凸的。和普通凸函数相比，强凸函数有更好的性质。</p><div class="note note-warning">            <p>💡 PS. 结论：设 <em>f</em> 为强凸函数且存在最小值，则 <em>f</em> 的最小值点唯一   </p>          </div></li></ol><h1 id="第三章、典型优化问题"><a href="#第三章、典型优化问题" class="headerlink" title="第三章、典型优化问题"></a>第三章、典型优化问题</h1><h3 id="一、线性规划"><a href="#一、线性规划" class="headerlink" title="一、线性规划"></a>一、线性规划</h3><ol><li><p>一般形式</p><p><img src="https://s2.loli.net/2023/04/14/RwBQujfqc4stJIK.png"></p><p>常见的两种形式：标准型（等式约束+决策变量非负）</p><p><img src="https://s2.loli.net/2023/04/14/WXe3PD5Oc1faYjN.png"></p><p>不等式形（没有等式约束）</p><p><img src="https://s2.loli.net/2023/04/14/f1jFugUqNXJ3PYc.png"></p></li></ol><h1 id="第四章、无约束优化算法"><a href="#第四章、无约束优化算法" class="headerlink" title="第四章、无约束优化算法"></a>第四章、无约束优化算法</h1><h3 id="一、线搜索方法"><a href="#一、线搜索方法" class="headerlink" title="一、线搜索方法"></a>一、线搜索方法</h3><p>给定当前迭代点xk，首先通过某种算法选取向量dk，之后确定正数αk，则下一步的迭代点可写作<br>$$<br>x^{k+1}&#x3D;x^k+\alpha_kd^k<br>$$<br>其中dk是搜索方向，αk是步长，线搜索算法的关键就是选取好的dk和αk，为了选出合适的步长αk，我们要引入一定的要求，称之为<strong>线搜索准则</strong>，常见的有Armijo准则、Goldstein准则、Wolfe准则等</p><p>其中，用于满足Armijo准则的常用方法是<strong>回退法</strong>，其基本思想为由大到小不断试验α，直至输出一个满足Armijo准则且尽可能大的步长</p><p><img src="https://s2.loli.net/2023/04/14/87Lrs5XoR4M9ObN.png"></p><h3 id="二、梯度类算法"><a href="#二、梯度类算法" class="headerlink" title="二、梯度类算法"></a>二、梯度类算法</h3><ol><li><p><strong>梯度下降法</strong></p><p>$$ x^{k+1}&#x3D;x^k-\alpha_k\nabla f(x^k) $$</p></li><li><p><strong>BB算法（Barzilai-Borwein）</strong></p><p>$$ x^{k+1}&#x3D;x^k-\alpha_{BB1}^K\nabla f(x^k) $$</p><p>$$ x^{k+1}&#x3D;x^k-\alpha_{BB2}^K\nabla f(x^k) $$</p><p>其中</p><p><img src="https://s2.loli.net/2023/04/14/PmaeTIGiWnXb1YH.png"></p><p><img src="https://s2.loli.net/2023/04/14/6chSM21efDy8BY7.png"></p><p>由上式可见，BB算法仅需要知道函数相邻两步的梯度信息和迭代点信息，所以BB算法的应用范围很广泛</p><p><img src="https://s2.loli.net/2023/04/14/q1dE8OU5Pr9zgGJ.png"></p></li></ol><h3 id="三、次梯度算法"><a href="#三、次梯度算法" class="headerlink" title="三、次梯度算法"></a>三、次梯度算法</h3><ol><li><p><strong>motivation：</strong>使用GDA的前提为目标函数 f(x) 是一阶可微的，但实际应用中经常会遇到<strong>不可微</strong>的函数，对于这类函数我们无法在每个点处求出梯度，但往往它们的最优值都是在不可微点处取到的。为了能处理这种情形，我们引入次梯度算法</p></li><li><p><strong>次梯度算法的结构</strong></p><p><img src="https://s2.loli.net/2023/04/14/MlaJcfgUHEtXpbo.png"></p><p>即对于凸函数来说，其切线总是在函数的下方。</p><p>类比上式可定义，给定函数f，对于任意y，如果满足：</p><p>$$ f(y)\ge f(x)+g^T(y-x) $$</p><p>则称 g 是函数 f 在点 x 处的次梯度，可见次梯度不一定唯一，也可能不存在。</p><p>将 f 在 x 处所有次梯度构成的集合称为 f 在 x 处的次微分，记作$\partial f(x)$</p><div class="note note-warning">            <p>💡 PS. 注意：次微分是一个集合，而凸函数的次微分总是非空，即必有次梯度   </p>          </div><p>假设凸函数 f 在不可微点x0处的左右导数分别为a、b，那么闭区间[a，b]中的任何一个取值都是次梯度，如$f(x)&#x3D;\vert x \vert$，则$g&#x3D;\begin{cases}sgn(x)&amp;x\neq0\ any\in[-1,1]&amp;x&#x3D;0\end{cases}$</p></li><li><p><strong>收敛性</strong></p><p>一个常用的取法是$\alpha_k&#x3D;\frac{1}{k}$，这样可保证算法的收敛性</p></li></ol><h3 id="四、牛顿类算法"><a href="#四、牛顿类算法" class="headerlink" title="四、牛顿类算法"></a>四、牛顿类算法</h3><ol><li><p><strong>motivation：</strong></p><p>梯度法仅仅依赖函数值和梯度的信息（即一阶信息），如果函数 <em>f</em>(<em>x</em>) 充分光滑，则可以利用二阶导数信息构造下降方向 <em>dk</em>。牛顿类算法就是利用二阶导数信息来构造迭代格式的算法。由于利用的信息变多，牛顿法的实际表现可以远好于梯度法，但是它对函数 <em>f</em>(<em>x</em>) 的要求也相应变高</p></li><li><p><strong>经典牛顿法</strong><br>$$<br>x^{k+1}&#x3D;x^k-\nabla^2f(x^k)^{-1}\nabla f(x^k)<br>$$<br>经典牛顿法的特点：</p><ul><li>步长恒为1</li><li>收敛速度很快，但只有局部收敛性，即初始点x0必须离真实解较近，较远时容易失效</li></ul><p>因此在在实际应用中，人们通常会使用梯度类算法先求得较低精度的解，而后调用牛顿法来获得高精度的解</p></li><li><p><strong>修正牛顿法</strong></p><p><img src="https://s2.loli.net/2023/04/14/kO4vuQbPhI3tcs6.png"></p><p>基本思想是对牛顿方程中的海瑟矩阵$\nabla^2f(x^k)$进行修正</p></li></ol><h3 id="五、拟牛顿类算法"><a href="#五、拟牛顿类算法" class="headerlink" title="五、拟牛顿类算法"></a>五、拟牛顿类算法</h3><ol><li><p><strong>motivation：</strong>拟牛顿方法不计算海瑟矩阵$\nabla^2f(x^k)$ ，而是构造其近似矩阵$B^k$或其逆的近似矩阵 $H^k$，我们希望 $B^k$ **或$H^k$仍然保留海瑟矩阵的部分性质，例如使dk仍然为下降方向</p></li><li><p><strong>算法框架</strong></p><p><img src="https://s2.loli.net/2023/04/14/P34FKpX1rmdulV5.png"></p></li><li><p><strong>拟牛顿矩阵更新方式</strong></p></li></ol><ul><li><p>秩一更新（SR1）</p><p>$$ B^{k+1}&#x3D;B^k+\dfrac{(y^k-B^ks^k)(y^k-B^k s^k)^{\text{T}}}{(y^k-B^kj)^{\text{T}}s^k} $$</p><p>$$ H^{k+1}&#x3D;H^k+\dfrac{(s^k-H^k y^k)(s^k-H^ky^k)^{\mathrm{T}}}{(s^k-H^ky^{k})^{\mathrm{T}}y^k} $$</p></li><li><p>BFGS公式</p><p>$$ B^{k+1}&#x3D;B^k+\dfrac{y^k(y^k)^{T}}{(s^k)^{T}y^k}-\dfrac{B^k s^k(B^k s^k)^}{(s^k)^{T}B^k s^k} $$</p><p>BFGS 公式是目前最有效的拟牛顿更新格式之一，它有比较好的理论性质，实现起来也并不复杂</p></li></ul><ol><li><p><strong>有限内存BFGS方法</strong></p><p>拟牛顿法虽然克服了计算海瑟矩阵的困难，但是它仍然无法应用在大规模优化问题上。一般来说，拟牛顿矩阵$B^k$ 或$H^k$ 是稠密矩阵，而存储稠密矩阵要消耗 <em>O</em>(n²) 的内存，这对于大规模问题显然是不可能实现的，故引入有限内存BFGS方法（L-BFGS）</p><p><img src="https://s2.loli.net/2023/04/14/PwRMakbExuog97v.png"></p><p><img src="https://s2.loli.net/2023/04/14/hB2pODdcqLivJRy.png"></p></li></ol><h3 id="六、信赖域算法"><a href="#六、信赖域算法" class="headerlink" title="六、信赖域算法"></a>六、信赖域算法</h3><ol><li><p><strong>motivation：</strong>在信赖域类算法中，我们直接在一个有界区域内求解这个近似模型，而后迭代到下一个点．因此信赖域算法实际上是同时选择了方向和步长</p></li><li><p><strong>形式：</strong></p><p>我们在如下球内考虑 f(x) 的近似<br>$$<br>\Omega_k&#x3D;{x^k+d\mid|d|\leqslant\Delta_k}<br>$$<br><img src="https://s2.loli.net/2023/04/14/uDc6BfUdOZrG5v2.png"></p><p>其中，mk(d)是在点x&#x3D;xk处对f(x)的近似</p><p>$$ m_k(d)&#x3D;f(x^k)+\nabla f(x^k)^{\mathrm T}d+\dfrac12d^{\mathrm T}B^kd $$</p><p>选取信赖域半径非常关键，它决定了算法的收敛性。考虑到信赖域半径是“对模型 <em>mk</em>(<em>d</em>) 相</p><p>信的程度”，如果 <em>mk</em>(<em>d</em>) 对函数 <em>f</em>(<em>x</em>) 近似较好，就应该扩大信赖域半径；反之减小。我们引入如下定义来衡量 <em>mk</em>(<em>d</em>) 近似程度的好坏</p><p>$$ \rho_k&#x3D;\dfrac{f(x^k)-f(x^k+d^k)}{m_k(0)-m_k(d^k)} $$</p><p>如果<em>ρk</em> 接近于1，说明用 <em>mk</em>(<em>d</em>) 来近似 <em>f</em>(<em>x</em>) 是比较成功的，我们应该扩大 <em>∆k</em>；如果 <em>ρk</em> 非常小甚至为负，就说明我们过分地相信了二阶模型 <em>mk</em>(<em>d</em>)，此时应该缩小 <em>∆k</em></p><p><img src="https://s2.loli.net/2023/04/14/pRejfTP5g3yAiLV.png" alt="Untitled"></p></li></ol><h1 id="第五章、约束优化算法"><a href="#第五章、约束优化算法" class="headerlink" title="第五章、约束优化算法"></a>第五章、约束优化算法</h1><h3 id="一、罚函数法"><a href="#一、罚函数法" class="headerlink" title="一、罚函数法"></a>一、罚函数法</h3><ol><li><p><strong>motivation：</strong></p><p>可行域的约束导致很多无约束算法不能直接使用（如梯度下降沿负梯度下降的点未必是可行点），而罚函数的思想是将约束条件作为惩罚项加到目标函数中，从而转换为无约束优化问题。</p><p>而这样做的原理是什么捏 —— 对于<strong>可行域外的点，惩罚项为正</strong>，即对该点进行惩罚；对于<strong>可行域内的点，惩罚项为 0</strong>，即不做任何惩罚。因此，惩罚项会促使无约束优化问题的解落在可行域内（好聪明的做法）。</p></li><li><p><strong>等式约束条件罚函数</strong></p><p><img src="https://s2.loli.net/2023/04/14/pDF1ZyodE9vP5jI.png"></p></li><li><p><strong>不等式约束</strong></p><p><img src="https://s2.loli.net/2023/04/14/xX73rBP5fuwVtlS.png"></p><p>我们设计加入罚函数的目标函数为：</p><p><img src="https://s2.loli.net/2023/04/14/WXZBYGvCbUFSNo2.png"></p><p><img src="https://s2.loli.net/2023/04/14/KEHV2ipQcxqT7N9.png"></p><p>这样的罚函数只会惩罚ci(x)＞0的部分，且由于函数 <em>h</em>(<em>t</em>) &#x3D; (max*{t*, 0*}*)²关于 <em>t</em> 是可导的，因此 <em>PI</em>(<em>x</em>,<em>σ</em>) 的梯度也存在，则可以使用梯度类算法来求解子问题</p></li><li><p><strong>内点罚函数</strong></p><p>基本思想：普通的外点罚函数允许取可行域之外的点，只是要进行惩罚；而内点法直接不允许取可行域之外的点，即从可行域内部逼近最优解</p><p><img src="https://s2.loli.net/2023/04/14/2LPyCemrqFWRujQ.png"></p><p>上式既做到了限制可行域，又做到了“x趋近于边界时进行惩罚”（In无穷大）</p></li></ol><h3 id="二、增广拉格朗日函数法"><a href="#二、增广拉格朗日函数法" class="headerlink" title="二、增广拉格朗日函数法"></a>二、增广拉格朗日函数法</h3><ol><li><strong>结构</strong></li></ol><p><img src="https://s2.loli.net/2023/04/14/67anqbXZ3CoHMRx.png"></p><ol><li><p><strong>一般约束优化问题的增广拉格朗日函数法</strong></p><p><img src="https://s2.loli.net/2023/04/14/2DK1ludNp9EkQit.png"></p><p>思路：引入松弛变量将不等式约束转化为等式约束和简单的非负约束，再构造增广拉格朗日函数</p><p><img src="https://s2.loli.net/2023/04/14/9CePmiN4RJXKWHg.png"></p><p>对上述问题我们可以构造出一个经典的拉格朗日函数</p><p><img src="https://s2.loli.net/2023/04/14/A2b8cl9PHEz4NJf.png"></p></li></ol><h1 id="第六章、复合优化算法"><a href="#第六章、复合优化算法" class="headerlink" title="第六章、复合优化算法"></a>第六章、复合优化算法</h1><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>复合优化问题定义为：</p><p><img src="https://s2.loli.net/2023/04/14/7fLqF8cXxjO3ZVS.png"></p><p>其中 <em>f</em>(<em>x</em>) 为可微函数（可能非凸），<em>h</em>(<em>x</em>) 可能为不可微函数</p><h3 id="二、近似点梯度法"><a href="#二、近似点梯度法" class="headerlink" title="二、近似点梯度法"></a>二、近似点梯度法</h3><ol><li><p><strong>邻近算子</strong></p><p>对于一个凸函数 <em>h</em>，定义它的邻近算子为</p><p><img src="https://s2.loli.net/2023/04/14/MXkIeUJt6zPBFlC.png"></p><p>可见，邻近算子的目的是求解一个距 <em>x</em> 不算太远的点，并使函数值 <em>h</em>(<em>x</em>) 也相对较小</p></li><li><p><strong>公式</strong></p><p>对于一个复合优化问题</p><p><img src="https://s2.loli.net/2023/04/14/P4NxGtKcvzmS8XF.png"></p><p>近似点梯度法的思想非常简单：注意到 <em>ψ</em>(<em>x</em>) 有两部分，对于光滑部分<em>f</em> 做梯度下降，对于非光滑部分 <em>h</em> 使用邻近算子，则近似点梯度法的迭代公式为：</p><p><img src="https://s2.loli.net/2023/04/14/aOG3ESCUkqFM5Np.png"></p><p>其中 <em>tk &gt;</em> 0 为每次迭代的步长，它可以是一个常数或者由线搜索得出。</p><p><img src="https://s2.loli.net/2023/04/14/jTPA6um7OtqriVL.png"></p></li></ol><h3 id="三、Nesterov加速算法"><a href="#三、Nesterov加速算法" class="headerlink" title="三、Nesterov加速算法"></a>三、Nesterov加速算法</h3><ol><li><p><strong>FISTA算法</strong>（可对近似点梯度算法进行加速）</p><p>FISTA 算法由两步组成：第一步沿着前两步的计算方向计算一个新点，第二步在该新点处做一步近似点梯度迭代，即</p><p><img src="https://s2.loli.net/2023/04/14/Oyvg5k97UMNCELB.png"></p><p><img src="https://s2.loli.net/2023/04/14/LFejMiZGSY1V2Nn.png"></p></li></ol><h3 id="四、分块坐标下降法（block-coordinate-descent，BCD）"><a href="#四、分块坐标下降法（block-coordinate-descent，BCD）" class="headerlink" title="四、分块坐标下降法（block coordinate descent，BCD）"></a>四、分块坐标下降法（block coordinate descent，BCD）</h3><ol><li><p><strong>motivation：</strong> 实际问题中的目标函数虽可能有成百上千个自变量，求解十分困难，但当固定其中若干变量时，函数的结构会得到极大的简化，是原问题被拆分为数个只有少数自变量的子问题，这也正是BCD方法的基本思想</p></li><li><p><strong>形式：</strong></p><p><img src="https://s2.loli.net/2023/04/14/Z8oWvxUuVjlCy9H.png"></p><p>将自变量 <em>x</em> 拆分成 <em>s</em> 个变量块 <em>x</em>1, <em>x</em>2,<em>···</em> , <em>xs</em>，函数 <em>f</em> 是关于 <em>x</em> 的可微函数，每个 <em>ri</em>(<em>xi</em>) 关于 <em>xi</em> 是适当的闭凸函数。 单独考虑每一块自变量时，f 有简单结构，ri 只与第 i 个自变量块有关</p></li><li><p><strong>举例</strong></p><p>考虑二元二次函数的优化问题</p><p><img src="https://s2.loli.net/2023/04/14/Z8oWvxUuVjlCy9H.png"></p><p>现在对变量 <em>x</em>,<em>y</em> 使用分块坐标下降法求解。当固定 <em>y</em> 时，可知当 <em>x</em> &#x3D; 2 + <em>y</em>时函数取极小值；当固定 <em>x</em> 时，可知当 <em>y</em> &#x3D; 1 +*x&#x2F;*10时函数取极小值。故采用的分块坐标下降法为：</p><p><img src="https://s2.loli.net/2023/04/14/O5J1ovfhcqgCaZt.png"></p><p>经验证，初始点为(0.5, 0.2)时，经过七次迭代就与最优解相当接近</p><p><img src="https://s2.loli.net/2023/04/14/JDINTVim7MEvOKZ.png"></p></li></ol><h3 id="五、对偶算法"><a href="#五、对偶算法" class="headerlink" title="五、对偶算法"></a>五、对偶算法</h3><ol><li>对偶思想常用思路有两种：把前面的算法应用到对偶问题上，如对偶近似点梯度法；另一种是同时把原始问题和对偶问题结合起来考虑，如原始-对偶混合梯度类算法 对偶算法主要考虑如下形式的问题：</li></ol><p><img src="https://s2.loli.net/2023/04/14/CVquzigKfx4jYQJ.png"></p><ol start="2"><li><strong>对偶近似点梯度法</strong></li></ol><p>​如果我们写出上述约束优化问题的拉格朗日函数和增广拉格朗日函数</p><p><img src="https://s2.loli.net/2023/04/14/pfmt3ELqnaowGNk.png"></p><p>​则迭代格式可以写为</p><p><img src="https://s2.loli.net/2023/04/14/81PytDkENRAsQVY.png"></p><p>​上述迭代格式又称为<strong>交替极小化方法，</strong>第一步迭代为在拉格朗日函数中关于 <em>x</em> 求极小，第二步迭代为在增广拉格朗日函数中关于 <em>y</em> 求极小，第三步迭代为更新拉格朗日乘子。</p><ol start="3"><li><strong>原始-对偶混合梯度算法（primaldual hybrid gradient, PDHG）</strong></li></ol><p>​PDGH在每次迭代时同时考虑原始变量和对偶变量的更新，这使得它在一定程度上可以有效避免单独针对原始问题或对偶问题求解算法中可能出现的问题 仍然考虑如下形式：</p><p><img src="https://s2.loli.net/2023/04/14/5ERFWfJcpC9xrlb.png"></p><p>​其中 <em>f</em> , <em>h</em> 是适当的闭凸函数．由于 <em>h</em> 有自共轭性，我们将上述问题变形为：</p><p><img src="https://s2.loli.net/2023/04/14/qclZvI8Y1K5EsGF.png"></p><p>​此时问题变形为一个极小-极大问题，即一个典型的<strong>鞍点问题</strong>。PDHG 算法交替更新原始变量以及对偶变量，其迭代格式如下：</p><p><img src="https://s2.loli.net/2023/04/14/89ROHGwP5YDfgoc.png"></p><h3 id="六、交替方向乘子法（alternating-direction-method-of-multipliers-ADMM）"><a href="#六、交替方向乘子法（alternating-direction-method-of-multipliers-ADMM）" class="headerlink" title="六、交替方向乘子法（alternating direction method of multipliers, ADMM）"></a>六、交替方向乘子法（alternating direction method of multipliers, ADMM）</h3><ol><li><p><strong>定义：</strong></p><p>本节考虑如下凸问题：</p><p><img src="https://s2.loli.net/2023/04/14/OjyM8sLdxBIUTho.png"></p><p>注意：很多常见的问题都可转化为上述形式</p><p>如把</p><p><img src="https://s2.loli.net/2023/04/14/ePVhFaBwXq4dG5g.png"></p><p>转化为：</p><p><img src="https://s2.loli.net/2023/04/14/5NPCMdZmROeQ23B.png"></p><p>再比如对于<strong>一致性问题</strong>：</p><p><img src="https://s2.loli.net/2023/04/14/4ZTa6v2eUuIQSPx.png"></p><p>令 <em>x</em> &#x3D; <em>z</em>，并将 <em>x</em> 复制 <em>N</em> 份，分别为 <em>xi</em>，那么问题转化为：</p><p><img src="https://s2.loli.net/2023/04/14/KVco15f4PrFmuUx.png"></p><p>如果令$x&#x3D;(x_1^\mathrm T,x_2^\mathrm T,\cdots,x_N^\mathrm T)^\mathrm T$以及$f_1(x)&#x3D;\sum\limits_{i&#x3D;1}^N\phi_i(x_i),\quad f_2(z)&#x3D;0$ 则此问题可以化为：</p><p><img src="https://s2.loli.net/2023/04/14/lUen9HYD73EhXdW.png"></p><p>其中矩阵 <em>A</em>1, <em>A</em>2 定义为：</p><p><img src="https://s2.loli.net/2023/04/14/hFfUAVeaGOc731n.png"></p></li><li><p><strong>迭代格式</strong></p><p>首先写出问题的增广拉格朗日函数</p><p><img src="https://s2.loli.net/2023/04/14/ckdolxbypJTeZ42.png"></p><p>则迭代格式为：</p></li></ol><p><img src="https://s2.loli.net/2023/04/14/62H5jK1lVUkQrzO.png"></p>]]></content>
    
    
    <categories>
      
      <category>科研只为把业毕</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>凸优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>借top K题目思考总结堆（heap）与优先队列（priority_queque）用法</title>
    <link href="/2023/04/13/%E5%80%9FtopK%E9%A2%98%E7%9B%AE%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%94%A8%E6%B3%95/"/>
    <url>/2023/04/13/%E5%80%9FtopK%E9%A2%98%E7%9B%AE%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>今天做了传说中的top K ，即“<strong>用大顶堆&#x2F;小顶堆对数据进行排序</strong>”的经典题目</p><p><img src="https://s2.loli.net/2023/04/13/ayuA9B7DGbOni2p.png"><br>本题思路：</p><ol><li>用map记录每个元素出现的频率</li><li>用heap对map进行排序并节选出前K个元素</li></ol><p>若第一次见此类题，难点当为heap的原理和对应stl容器（priority_queue）的用法。查阅了一些资料，发现不管是leetcode题解抑或博客文章都写得略语焉不详，对新手不甚友好，故笔者试图用自己的话对其原理进行粗糙解释。</p><hr><h1 id="二、堆（heap）的原理和用法（下述所有例子默认用小顶堆）"><a href="#二、堆（heap）的原理和用法（下述所有例子默认用小顶堆）" class="headerlink" title="二、堆（heap）的原理和用法（下述所有例子默认用小顶堆）"></a>二、堆（heap）的原理和用法（下述所有例子默认用小顶堆）</h1><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>（1） 堆是一种具有特殊排序关系的完全二叉树，也就是说，堆首先得具有完全二叉树的所有特性<br>（2） 特殊排序关系指——以小顶堆为例——<strong>每个节点的value都小于其两个子节点</strong> ；大顶堆反之</p><p>下图就是一个典型的小顶堆</p><p><img src="https://s2.loli.net/2023/04/13/LYr9ecyzTOpSwCM.png"></p><h3 id="3-堆的建立（push）"><a href="#3-堆的建立（push）" class="headerlink" title="3.堆的建立（push）"></a>3.堆的建立（push）</h3><p>对于一个已经建好的堆，push新元素的方法是：</p><ol><li><strong>插入</strong>：将该元素插入到heap的尾部</li><li><strong>比较</strong>：然后不断“上浮”，直至满足堆的条件。所谓“上浮”，就是将该元素与其父节点进行比较，比父节点小则上浮一层，否则不动，一直操作直至上浮不动。</li></ol><p>而若是要从零开始建立一个堆捏？很简单，从第一个元素开始，对每个元素都执行一次push操作就行了。<br>下图展示了从零开始建立一个heap过程</p><p><img src="https://s2.loli.net/2023/04/13/gkV1vRcHpiLSujf.jpg"></p><h3 id="2-堆的删除（pop）"><a href="#2-堆的删除（pop）" class="headerlink" title="2.堆的删除（pop）"></a>2.堆的删除（pop）</h3><p>三步走：</p><ol><li><strong>弹出</strong>：将堆顶元素（即最小的那个元素）直接pop</li><li><strong>提上</strong>：将heap的最后一个元素提到堆顶</li><li><strong>下沉</strong>：将提上的这个堆顶元素不断与其子节点比较，大于子节点就下沉一层，直至全满足定义</li></ol><p>如下图所示<br><img src="https://s2.loli.net/2023/04/13/RXMb5QG1VdutzF6.jpg"></p><hr><h1 id="三、优先队列（priority-queue）的使用"><a href="#三、优先队列（priority-queue）的使用" class="headerlink" title="三、优先队列（priority_queue）的使用"></a>三、优先队列（priority_queue）的使用</h1><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>我们可以用c++ stl中的priority_queue容器来实现heap的操作，其定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = std::vector&lt;T&gt;,<br>    <span class="hljs-keyword">class</span> Compare = std::less&lt;<span class="hljs-keyword">typename</span> Container::value_type&gt;<br>&gt; <span class="hljs-keyword">class</span> priority_queue;<br></code></pre></td></tr></table></figure><p>T是指堆中元素的<strong>数据类型</strong>；<br>container指用于存储这些元素的<strong>底层容器类型</strong>（<strong>默认用vector</strong>，一般也不用改）；<br>compare是元素之间的<strong>比较方式</strong>，用于决定建立的是大顶堆or小顶堆，默认用less函数建立大顶堆（当然，你也可以自定义compare方法来建立一些奇奇怪怪的堆。。）</p><h3 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h3><p>和普通队列一样，常用的就pop()、push()、top()、empty()</p><h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3.代码示例"></a>3.代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">print_queue</span><span class="hljs-params">(T&amp; q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; q.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : &#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;)<br>        q.<span class="hljs-built_in">push</span>(n);<br> <br>    <span class="hljs-built_in">print_queue</span>(q);<br> <br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt; &gt; q2;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : &#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;)<br>        q2.<span class="hljs-built_in">push</span>(n);<br> <br>    <span class="hljs-built_in">print_queue</span>(q2);<br> <br>    <span class="hljs-comment">// 用 lambda 比较元素。</span><br>    <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123; <span class="hljs-built_in">return</span> (left ^ <span class="hljs-number">1</span>) &lt; (right ^ <span class="hljs-number">1</span>); &#125;;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">q3</span>(cmp);<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : &#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;)<br>        q3.<span class="hljs-built_in">push</span>(n);<br> <br>    <span class="hljs-built_in">print_queue</span>(q3);<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="https://s2.loli.net/2023/04/13/n4RIGtX7NACKceQ.png"><br>上述代码及运行结果，与前面我手画的那两张图都是吻合的</p><hr><h1 id="四、题解"><a href="#四、题解" class="headerlink" title="四、题解"></a>四、题解</h1><p>回到开头那道topK力扣题，答案如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 小顶堆</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> <br>    &#123;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span><br><span class="hljs-function">            </span>&#123;<br>                <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>            &#125;<br>    &#125;;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter : nums) &#123;<br>            map[iter]++;<br>        &#125;<br><br>        <span class="hljs-comment">// 对频率排序</span><br>        <span class="hljs-comment">// 定义一个小顶堆，大小为k</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br><br>        <span class="hljs-comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">begin</span>(); it != map.<span class="hljs-built_in">end</span>(); it++) <br>        &#123;<br>            pri_que.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span> (pri_que.<span class="hljs-built_in">size</span>() &gt; k) &#123; <span class="hljs-comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span><br>                pri_que.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result[i] = pri_que.<span class="hljs-built_in">top</span>().first;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>做一些解释说明：</p><ol><li><p>首先注意，我们要<strong>找出前K大的元素，那要用的是小顶堆</strong>，因为小顶堆才能把小元素排出去，剩下的就是前K大元素嘛</p></li><li><p>map中的单个元素的数据类型是pair&lt;Type, Type&gt;</p></li><li><p>关于compare方法的理解：默认的<strong>less方法建立的是大顶堆</strong>，要<strong>建立小顶堆则改用greater&lt;T&gt;</strong></p><p>然后所谓的less方法，是将第一个实参（称之为左实参）与第二个实参（称之为右实参）进行比较，return left&lt;right——那么左实参更小时则为true，为true则交换；greater方法反之，return left&gt;right；</p><p>在上述代码的自定义方法mycomparison中也可以说明这一点，它使用的是return left&gt;right,即greater方法，即建立小顶堆</p></li></ol><blockquote><p>总结：<br>建立大顶堆 &#x3D; less方法 &#x3D; return left &lt; right<br>建立小顶堆 &#x3D; greater方法 &#x3D; return left &gt; right</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% note success %&#125;<br>TO-DO：<br>上述第三条纯属自己理解，这么死记用来做题应用没啥问题，但还是得挑个良辰吉日去翻翻源码才行捏😣<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>借一道leetcode思考总结map/set的应用及区别</title>
    <link href="/2023/04/13/%E5%80%9F%E4%B8%80%E9%81%93leetcode%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93mapset%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/04/13/%E5%80%9F%E4%B8%80%E9%81%93leetcode%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93mapset%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原题是leetcode349，要求两个数组的交集</p><p><img src="https://s2.loli.net/2023/04/13/WmNqiBn9R6Lh7f4.png" alt=" "><br>这题本身不难，主要是要考虑到：</p><ol><li>原题只需求“频率”，无需考虑“顺序”，则应使用哈希表结构，而不是顺序结构+两个for暴力遍历</li><li>用于作键值key的是数字而非字母，所以应该用正儿八经的set&#x2F;map，而不是用vector搞伪hash（否则当数字键值很大且稀疏时，vector会浪费大量空间） </li><li>不需要设置明确的key，所以用set，而不是map</li><li>不考虑顺序，所以用unordered_set</li></ol><p>上述思路理清之后，代码自然就出来了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果，之所以用set是为了给结果集去重</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter : nums2) <br>        &#123;<br>            <span class="hljs-comment">// 发现nums2的元素 在nums_set里又出现过</span><br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(iter) != nums_set.<span class="hljs-built_in">end</span>()) <br>            &#123;<br>                result_set.<span class="hljs-built_in">insert</span>(iter); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由此题我们可以一窥set&#x2F;map的具体使用场景，下面对其差别和应用进行简单总结</p><hr><h1 id="一、定义和类型"><a href="#一、定义和类型" class="headerlink" title="一、定义和类型"></a>一、定义和类型</h1><p>STL中的部分容器（vector、list、deque等）底层为线性序列的数据结构，故将这些容器统称为<strong>序列式容器</strong>，里面存储的是元素本身；对应的，有另外一种用&lt;key，value&gt;键值对方式储存数据的数据结构，我们称其为<strong>关联式容器</strong>，典型的有set类和map类容器。</p><p>这种关联式容器的motivition应该是用某种特殊的底层数据结构来代替线性序列，以避免线性结构容易导致的空间浪费问题，同时提高curd效率 – – 线性序列为O(n)，那再提高就是O(log n)和O(1)，对应的是啥捏？</p><p><em><strong>树和hash table嘛！这也正是set\map的底层实现方式</strong></em></p><p>具体如下：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值可重复</th><th>数值可更改</th><th>curd效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td></tr></tbody></table><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值可重复</th><th>数值可更改</th><th>curd效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>有序</td><td>key不可重复</td><td>否</td><td>O(log n)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>有序</td><td>key可重复</td><td>否</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>key不可重复</td><td>否</td><td>O(1)</td></tr></tbody></table><p>其需要注意的是，set\multiset\map\multimap的实现都为红黑树，红黑树是一种平衡二叉搜索树，所以key有序且不能修改，修改key会导致整棵树的错乱；<br>而我们要用集合来解决hash问题时，优先使用unordered，因为其底层使用hash table，curd效率最高（只需执行一次hash function，复杂度为O(1)）</p><hr><h1 id="二、set类说明"><a href="#二、set类说明" class="headerlink" title="二、set类说明"></a>二、set类说明</h1><ol><li>与map&#x2F;multimap不同，map中存储的是真正的键值对&lt;key, value&gt;，set中只放value，但在底层实际存放的是由&lt;value, value&gt;构成的键值对（即一个元素的value同时也会标识它，value就是key）。故set中插入元素时，<strong>只需要插入value即可，不需要构造键值对</strong></li><li>set中的元素不可以重复，因此可以使用set进行<strong>去重</strong></li><li>set中的元素有序（默认升序），故可用iteration<strong>遍历set得有序序列</strong></li><li>set中的元素<strong>不允许修改</strong>（元素总是const）</li><li>set中的count()方法只能返回0或1，所以其实就是个find()。。而find()返回的是查找元素的位置指针，没有则返回set.end()</li><li>multiset与set的区别是<strong>前者中的元素可重复</strong>，其它都一样</li><li>unordered_set与set的区别是<strong>前者中的元素不会排序</strong></li></ol><p>代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestSet</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 用数组array中的元素构造set</span><br><span class="hljs-type">int</span> array[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span> &#125;;<br>set&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : array)<br>s.<span class="hljs-built_in">insert</span>(e);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;set中的元素个数为: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">// 正向打印set中的元素，从打印结果中可以看出：set可去重</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;正向打印set中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : s)<br>cout&lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 使用迭代器逆向打印set中的元素</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;逆向打印set中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">rbegin</span>(); it != s.<span class="hljs-built_in">rend</span>(); ++it)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// set中值为3的元素出现了几次</span><br>cout &lt;&lt; <span class="hljs-string">&quot;set中值为x的元素出现了几次：&quot;</span> &lt;&lt; s.<span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br><br>    <span class="hljs-function">multiset&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">muls</span><span class="hljs-params">(array, array + <span class="hljs-keyword">sizeof</span>(array) / <span class="hljs-keyword">sizeof</span>(array[<span class="hljs-number">0</span>]))</span></span>;<br>    cout &lt;&lt;  <span class="hljs-string">&quot;正向打印multiset中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : muls)<br>cout &lt;&lt;e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><br>    <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">unorders</span><span class="hljs-params">(array, array + <span class="hljs-keyword">sizeof</span>(array) / <span class="hljs-keyword">sizeof</span>(array[<span class="hljs-number">0</span>]))</span></span>;<br>    cout &lt;&lt;  <span class="hljs-string">&quot;打印unordered_set中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : unorders)<br>cout &lt;&lt;e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">TestSet</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<br> <img src="https://s2.loli.net/2023/04/13/w8kQyJztoIBaq1E.png"></p><hr><h1 id="三、map类说明"><a href="#三、map类说明" class="headerlink" title="三、map类说明"></a>三、map类说明</h1><ol><li>需要<strong>构造键值对</strong></li><li>map支持下标访问符，即在[]中放入key，就可以找到与key对应的value；也支持.at()方法，但二者有所不同（见下面代码）</li><li>multimap和map的唯一不同就是：map中的<strong>key是唯一</strong>的，而multimap中key是<strong>可以重复的</strong></li><li>unordered_map和map : : unordered_map存储元素时是<strong>没有顺序的</strong>，只是根据key的哈希值，将元素存在指定位置，所以根据key查找单个value时非常高效</li></ol><p>代码示例（来源: <a href="https://blog.csdn.net/qq_61635026/article/details/126070134?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166593410616782412589556%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166593410616782412589556&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-126070134-null-null.142%5Ev56%5Econtrol_1,201%5Ev3%5Econtrol_2&utm_term=stl%20set%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB&spm=1018.2226.3001.4187">C++ STL中 set和map介绍以及使用方法</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestMap</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;string, string&gt; m;<br><span class="hljs-comment">// 向map中插入元素的方式：</span><br><span class="hljs-comment">// 将键值对&lt;&quot;peach&quot;,&quot;桃子&quot;&gt;插入map中，用pair直接来构造键值对</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, string&gt;(<span class="hljs-string">&quot;peach&quot;</span>, <span class="hljs-string">&quot;桃子&quot;</span>));<br><span class="hljs-comment">// 将键值对&lt;&quot;peach&quot;,&quot;桃子&quot;&gt;插入map中，用make_pair函数来构造键值对</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;banan&quot;</span>, <span class="hljs-string">&quot;香蕉&quot;</span>));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">operator[]的原理是：</span><br><span class="hljs-comment"> 用&lt;key, T()&gt;构造一个键值对，然后调用insert()函数将该键值对插入到map中</span><br><span class="hljs-comment"> 如果key已经存在，插入失败，insert函数返回该key所在位置的迭代器</span><br><span class="hljs-comment"> 如果key不存在，插入成功，insert函数返回新插入元素所在位置的迭代器</span><br><span class="hljs-comment"> operator[]函数最后将insert返回值键值对中的value返回</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 将&lt;&quot;apple&quot;, &quot;&quot;&gt;插入map中，插入成功，返回value的引用，将“苹果”赋值给该引用结果</span><br>m[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-string">&quot;苹果&quot;</span>;<br><br><span class="hljs-comment">// key不存在时抛异常</span><br><span class="hljs-comment">//m.at(&quot;waterme&quot;) = &quot;水蜜桃&quot;;</span><br><br>cout &lt;&lt; m.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 用迭代器去遍历map中的元素，可以得到一个按照key排序的序列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : m)<br>cout &lt;&lt; e.first &lt;&lt; <span class="hljs-string">&quot;---&gt;&quot;</span> &lt;&lt; e.second &lt;&lt; endl;<br>cout &lt;&lt; endl;<br><span class="hljs-comment">// map中的键值对key一定是唯一的，如果key存在将插入失败</span><br><span class="hljs-keyword">auto</span> ret = m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;peach&quot;</span>, <span class="hljs-string">&quot;another桃子&quot;</span>));<br><span class="hljs-keyword">if</span> (ret.second)<br>cout &lt;&lt; <span class="hljs-string">&quot;&lt;peach, another桃子&gt;不在map中, 已经插入&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot;键值为peach的元素已经存在：&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="hljs-string">&quot;---&gt;&quot;</span><br>&lt;&lt; ret.first-&gt;second &lt;&lt; <span class="hljs-string">&quot; 插入失败&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 删除key为&quot;apple&quot;的元素</span><br>m.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;apple&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == m.<span class="hljs-built_in">count</span>(<span class="hljs-string">&quot;apple&quot;</span>))<br>cout &lt;&lt; <span class="hljs-string">&quot;apple还在&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot;apple被吃了&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">TestMap</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p> <img src="https://s2.loli.net/2023/04/13/A3rM12B8DJKzVS7.png"><br>如果用at()查值，则key不在时抛出异常</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;waterme&quot;</span>) = <span class="hljs-string">&quot;水蜜桃&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/13/bMPIHgarpTBKlu1.png"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>1. 用set类还是map类？</strong><br>如果需要建立明确的<strong>键值对应关系</strong>（如示例中的水果），那只能用map；如果只需知道“<strong>存在与否</strong>”，那用set就够了（如leetcode例题，其实没有体现一个明确的key，coding时关心的也是value而不是key）</p><p><strong>2. 用set类还是array伪hash？</strong><br>如果key分布在一个<strong>不大的连续区间</strong>内（ 如26个字母），则可以直接用array，这样更快，因为set不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的；<br>但如果key随机则用set，如key为<strong>分布稀疏</strong>的大数字时，用数组就非常浪费空间，只能用set。</p><p><strong>3. 用set还是unordered_set？（map同理）</strong><br>有序set（红黑树），无序unordered_set（hash table）</p><p><strong>PS.</strong> py中的in关键字在不同结构中（tuple, list, dict, set）查找元素时效率是相差很大的，因为dict, set底层是一个hash table；而tuple, list只是一个单纯类于数组的线性结构。。</p>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
      <tag>哈希算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分类占坑2</title>
    <link href="/2023/04/13/%E5%8D%A0%E4%B8%AA%E5%9D%912/"/>
    <url>/2023/04/13/%E5%8D%A0%E4%B8%AA%E5%9D%912/</url>
    
    <content type="html"><![CDATA[<p>这篇文章只是为了在分类板块中占个坑😆😆</p><p>顺便作为测试</p><p>这是一句话<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="参考资料1">[1]</span></a></sup></p><p>$$<br>E&#x3D;mc^2<br>$$</p><div class="note note-warning">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><p class="note note-primary">标签</p><span class="label label-primary">text</span><p><span class="label label-primary">Label</span></p>            <input type="checkbox" disabled checked="checked">text          <a class="btn" href="url"  title="title" target="_blank">text</a><p><a class="btn" href="url" title="title">text</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>$$</p><p>$$<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这是对应的脚注<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span>参考资料1<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>参考资料2<br><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    <categories>
      
      <category>偶尔也得摸摸鱼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记位运算符(＞＞)使用不当引起的一次bug</title>
    <link href="/2023/04/13/%E8%AE%B0%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6(%EF%BC%9E%EF%BC%9E)%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%80%E6%AC%A1bug/"/>
    <url>/2023/04/13/%E8%AE%B0%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6(%EF%BC%9E%EF%BC%9E)%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%80%E6%AC%A1bug/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>今天刷leetcode时遇到个死活也想不通的bug</p><p>原题很简单，线性数组插值问题，暴力遍历和二分法都可以做</p><p> <img src="https://s2.loli.net/2023/04/13/ifSOReA2dapUFsh.png"><br>不假思索用区间左闭右开的二分法，三下五除二就整了出来，胸有成竹😋</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.size();<br>        <span class="hljs-keyword">while</span>(left &lt; right)<br>        &#123;<br>            <span class="hljs-type">int</span> middle = left + (right - left) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target )<br>                right = middle;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target )<br>                left = middle + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>谁知提交时一直在示例3（即输入数组为[1 3 5 6]，查询值target &#x3D; 7）卡bug，提示超时。。</p><hr><h1 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h1><p>原以为是区间边界条件设置不当，反复检查，手动演算，脑袋想破了也觉得没问题。。</p><p>无奈debug，发现执行这一句后，middle一值变化很奇怪。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> middle = left + (right - left) &gt;&gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>突然虎躯一震，意识到可能是运算符优先级一问题，速google之，果然！</p><p><img src="https://s2.loli.net/2023/04/13/ildhp5643oy9vXw.png"></p><p><em><strong>原来加减符的优先级是要高于位运算符的！</strong></em><br>一验证发现也的确如此<br><img src="https://s2.loli.net/2023/04/13/r8KHytNjmulQXIv.png"></p><p><img src="https://s2.loli.net/2023/04/13/pCmWrFxzQE8AY1T.png"></p><hr><h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><p>加个括号即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> middle = left +( (right - left) &gt;&gt; <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>问题解决，顺利通关！</p><p><img src="https://s2.loli.net/2023/04/13/vtzFBo3YmZqg4XV.png"></p><hr><h1 id="总结反思："><a href="#总结反思：" class="headerlink" title="总结反思："></a>总结反思：</h1><ol><li>善于使用括号，尤其是主观上希望某个式子部分先运算时。</li><li>老老实实用乘除得了，别整些什么花里胡哨trick。。代码省下几毫秒，debug多花几十分钟。。</li></ol>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
