<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>EE364A笔记</title>
    <link href="/2023/06/14/%E3%80%8AEE364A%E7%AC%94%E8%AE%B0%E3%80%8B/"/>
    <url>/2023/06/14/%E3%80%8AEE364A%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="《EE364A笔记》"><a href="#《EE364A笔记》" class="headerlink" title="《EE364A笔记》"></a>《EE364A笔记》</h1><h1 id="Lecture-1-Introduction"><a href="#Lecture-1-Introduction" class="headerlink" title="Lecture_1 Introduction"></a>Lecture_1 Introduction</h1><ol><li><strong>最小二乘问题</strong></li></ol><p><img src="https://s2.loli.net/2023/06/14/6hporxeNmGwjKbC.png"></p><ul><li>有解析解：$x^*&#x3D;(A^TA)^{-1}A^Tb$</li><li>现已有成熟方法和软件来解决最小二乘问题</li></ul><ol start="2"><li><strong>线性规划问题</strong></li></ol><p><img src="https://s2.loli.net/2023/06/14/Ty8cbCUN71uZdYv.png"></p><ul><li>没有解析解</li><li>现已有成熟方法和软件来解决线性规划问题</li></ul><ol start="3"><li><strong>凸优化问题</strong></li></ol><p><img src="https://s2.loli.net/2023/06/14/UzswpgkhnlICyQf.png"></p><p>​其中目标函数 f0 和约束函数 fi 都是凸的，即满足：</p><p><img src="https://s2.loli.net/2023/06/14/OWtH2KeDRAimNac.png"></p><h1 id="Lecture-2-Convex-sets"><a href="#Lecture-2-Convex-sets" class="headerlink" title="Lecture_2 Convex sets"></a>Lecture_2 Convex sets</h1><h3 id="一、凸包与凸集"><a href="#一、凸包与凸集" class="headerlink" title="一、凸包与凸集"></a>一、凸包与凸集</h3><p>​见<a href="https://qlhhahaha.github.io/2023/04/13/%E3%80%8A%E6%9C%80%E4%BC%98%E5%8C%96%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E6%96%87%E5%86%8D%E6%96%87%EF%BC%89%E7%AC%94%E8%AE%B0%E3%80%8B/#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">《最优化计算方法（文再文）笔记》</a></p><h3 id="二、如何保证一个集合C的凸性"><a href="#二、如何保证一个集合C的凸性" class="headerlink" title="二、如何保证一个集合C的凸性"></a>二、如何保证一个集合C的凸性</h3><ol><li><strong>使用定义</strong></li></ol><p><img src="https://s2.loli.net/2023/06/14/RGnYNVfLv2zU1Zh.png"></p><ol start="2"><li><strong>证明C是由简单凸集经过以下操作得到：</strong></li></ol><ul><li><p>​<strong>相交：</strong>任意个数的凸集相交仍为凸集</p><p><img src="https://s2.loli.net/2023/06/14/qIwAbr251N4MTV6.png"></p></li></ul><p>​为什么说S是凸集捏？<br>​首先cos是偶函数，所以 t 的范围简化为0到pi&#x2F;3，我们假设 t 为该范围中的某个定值；<br>​定义子集$S_t&#x3D;{ x\in R^m  |   \left\vert p(t)\right\vert \le1 }$，即先固定 t ，<br>​则此时$\left\vert p(t)\right\vert \le1$是两个半平面的交集（因为 p(t)是[cos t, cos 2t]和[x1, x2]的内积，$p(t) \le1$是个半平面， $p(t) \ge -1$也是个半平面 ），所以 St 为凸集<br>​而$S&#x3D;\cap S_t ,t\in(0,\pi&#x2F;3)$，即为无数个凸集的交集，故 S 仍未凸集（见上右图）</p><ul><li><strong>仿射函数：</strong>凸集经仿射变换（缩放、平移、投影）仍是凸集</li><li><strong>透视函数与线性分式函数</strong></li></ul><p>​透视函数P：$R^{n+1}\rightarrow R^n$</p><p><img src="https://s2.loli.net/2023/06/14/ZBbct6EWzUN5LQu.png"></p><p>​线性分式函数 f：$R^{n}\rightarrow R^m$</p><p>​<img src="https://s2.loli.net/2023/06/14/4tYHiAjksyeaL5D.png"></p><h3 id="三、支撑超平面定理"><a href="#三、支撑超平面定理" class="headerlink" title="三、支撑超平面定理"></a>三、支撑超平面定理</h3><p>​如果C是凸集，那么在其每一个边界点上都存在至少一个支撑超平面（几何意义是切线、切面）</p><div class="note note-warning">            <p>​💡 PS. 支撑超平面不一定唯一，如矩形顶点处就有无数个超平面（因为边界突变）<br>​</p>          </div><h1 id="Lecture-3-Convex-functions"><a href="#Lecture-3-Convex-functions" class="headerlink" title="Lecture_3 Convex functions"></a>Lecture_3 Convex functions</h1><ol><li><p><strong>常见凸函数</strong></p><ul><li><p>指数函数</p></li><li><p>幂函数：$x^\alpha,\alpha \ge1,or ,\alpha\le0$</p></li><li><p>熵函数：$xlogx$</p></li><li><p>所有的范数</p></li></ul></li><li><p><strong>拓展函数</strong></p></li></ol><p><img src="https://s2.loli.net/2023/06/14/KOfqJhre8BkpQtL.png"></p><ol start="3"><li><strong>上境图（epigraph）</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/jqlZ5VfMLDPOIUc.png"></p><p>​f 为凸函数 $\iff$ 的上境图为凸集</p><ol start="4"><li><p><strong>共轭函数</strong></p> <img src="https://s2.loli.net/2023/06/14/ThjPmMAYB8sZWNk.png" style="zoom:80%;" /></li></ol><p>​$f^*$始终是凸函数（即使 f 不凸）</p><p>​举例：</p><p><img src="https://s2.loli.net/2023/06/14/pgZPLbSGxHqQcVW.png"></p><ol start="5"><li><strong>拟凸函数（quasiconvex function）</strong></li></ol><p>​定义：若 dom f 为凸集，且对任意的 α ，其下水平集<br>$$<br>S_\alpha&#x3D;{x\in domf | f(x) \le \alpha }<br>$$<br>​<img src="https://s2.loli.net/2023/06/14/FxYt8vHmyijQPbB.png" style="zoom:67%;" /></p><h1 id="Lecture-4-Convex-optimization-problems"><a href="#Lecture-4-Convex-optimization-problems" class="headerlink" title="Lecture_4 Convex optimization problems"></a>Lecture_4 Convex optimization problems</h1><ol><li><strong>标准形式</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/xU72RaZtkAoOp6s.png"></p><ol start="2"><li><strong>凸优化问题</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/M6ZID7QrkEmhdbV.png"></p><p>​其中 fi(x) 都是凸的；等式约束是仿射的</p><p>​<div class="note note-warning">            <p>​💡 PS. 凸优化问题的任何局部最优解都是全局最优解<br>​</p>          </div></p><ol start="3"><li><p><strong>一些常见的转换技巧</strong></p><ul><li><strong>消除等式约束</strong></li></ul><p> <img src="https://s2.loli.net/2023/06/14/GNf9QxmPc76VF4z.png"></p><p> ​即先把 Ax&#x3D;b 解出来，再带到不等式约束中</p><ul><li><strong>引入等式约束</strong></li></ul><p> <img src="https://s2.loli.net/2023/06/14/gavAucWLDYkzfhp.png"></p><ul><li><strong>引入松弛变量</strong></li></ul></li><li><p><strong>线性规划问题（Linear Program, LP）</strong></p></li></ol><p><img src="https://s2.loli.net/2023/06/14/RhoVEv6rnT4g9W5.png"></p><p>​几何解释为，线性规划的可行域是多面体P，该最优问题就是要在P上求仿射函数$c^Tx+d$的极小值</p><p>​<strong>举例：</strong></p><p>​一份健康的饮食包含m种不同的营养，每种至少需要b1,…,bm。我们可以从n种食物中选择非负的量x1，… ，xn以构成一份食谱。单位第 j 种食品含有营养 i 的量为 aj，而价格为 cj。我们希望设计出一份最便宜的满足营养需求的食谱。这一问题可以描述为线性规划</p><p>​<img src="https://s2.loli.net/2023/06/14/dmYERS9ArT4ockG.png"></p><ol start="5"><li><strong>二次优化问题（Quadratic program，QP）</strong></li></ol><p>​目标函数是凸二次型且约束函数为仿射</p><p>​<img src="https://s2.loli.net/2023/06/14/zpdoy2Ww67TD5Or.png"></p><p>​几何解释：可行集是多面体P，虚线为凸二次目标函数的等位线</p><p>​<img src="https://s2.loli.net/2023/06/14/veWtf29I3QhjOD8.png" style="zoom:67%;" /></p><p>​线性规划是二次规划的特例（P取0时退化为线性规划）</p><ol start="6"><li><strong>二次约束二次规划问题（QCQP）</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/VnTWEzr49bo8uHa.png"></p><p>​在二次规划的基础上，若不等式约束条件也是凸二次型，则称之为QCQP</p><ol start="7"><li><strong>二阶锥规划（Second order cone programming，SOCP）</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/u3QPtmK7WOAqjrY.png"></p><p>​当 ci &#x3D; 0时，退化为一个QCQP问题</p><h1 id="Lecture-5-Duality"><a href="#Lecture-5-Duality" class="headerlink" title="Lecture_5 Duality"></a>Lecture_5 Duality</h1><ol><li><strong>Lagrange对偶函数</strong></li></ol><p>​一个标准形式的问题（不要求是凸的）</p><p>​<img src="https://s2.loli.net/2023/06/14/yVwbc4Fizgvo6Hs.png" style="zoom:67%;" /></p><p>​把它写成</p><p>​<img src="https://s2.loli.net/2023/06/14/HVapvMDbdsgy8xm.png" style="zoom:67%;" /></p><p>​所谓的Lagrange对偶函数，就是去求它的下确界</p><p>​<img src="https://s2.loli.net/2023/06/14/XQI8zJFKjD4eNME.png" style="zoom:80%;" /></p><p>​对于可行域内所有的$\tilde{x}$，皆有$p^* \ge g(\lambda,v)$，即$g(\lambda,v)$是原问题最优值的下界</p><ol start="2"><li><strong>举例：线性方程组的最小二乘解</strong></li></ol><p>​考虑问题：</p><p>​<img src="https://s2.loli.net/2023/06/14/bfNtnDGL4EU3sd1.png" style="zoom:67%;" /></p><p>​其Lagrange函数为：</p><p>​<img src="https://s2.loli.net/2023/06/14/4L83i2favGyA9wQ.png" style="zoom:67%;" /></p><p>​为得最小值，求其导数：</p><p>​<img src="https://s2.loli.net/2023/06/14/lyd6zVUIMFagND9.png" style="zoom:67%;" /></p><img src="https://s2.loli.net/2023/06/14/GNsDmbSezfZXlxK.png" style="zoom:67%;" /><p>​所以可得原问题最优解的下界为：</p><p>​<img src="https://s2.loli.net/2023/06/14/3fhGcy8n92x6LBH.png" style="zoom:67%;" /></p><ol start="3"><li><strong>Lagrange对偶问题</strong></li></ol><p>​求Lagrange函数的最大值，也就是原问题的最好下界，这就是所谓的Lagrange对偶问题</p><p>​<img src="https://s2.loli.net/2023/06/14/D4RoZHMqxLeYQgh.png" style="zoom:67%;" /></p><p>​<strong>举例：</strong></p><p>​<img src="https://s2.loli.net/2023/06/14/NaHJB97GxjZh1u5.png" style="zoom: 80%;" /></p><p>​其Lagrange函数为：</p><p>​<img src="https://s2.loli.net/2023/06/14/WIP4YJpu8gRl2rH.png" style="zoom:80%;" /></p><p>​<div class="note note-warning">            <p>​💡 PS. 注意：此时 x 的定义域是R，也就是说不用再去考虑 (x-2)(x-4)为负这个约束条件，因为Lagrange函数本身就已经包含了这个条件<br>​</p>          </div></p><p>​那么显而易见，对于这个以 λ 为自变量的二次函数，$\lambda \le -1$时下确界为 -∞ ;$\lambda &gt; -1$时，在$\tilde{x}&#x3D;3\lambda&#x2F;(1+\lambda)$处取最小值，即</p><p>​<img src="https://s2.loli.net/2023/06/14/6bZegP2RjIQMhKB.png"></p><p>​此时我们得到了所谓的Lagrange对偶问题：</p><p>​<img src="https://s2.loli.net/2023/06/14/Ec1fbjwuSgXpRno.png"></p><p>​容易验证得到此时的最优点为 λ&#x3D;2，最优值为5，和原问题一致（这是必然的，因为当 x 属于(2, 4)时不等式严格成立，即满足Slater条件，且原问题是凸问题，那么强对偶性成立）</p><p>​<div class="note note-warning">            <p>​💡 PS. 除了Slater条件之外，还有其它很多判断准则<br>​</p>          </div></p><ol start="4"><li><strong>强弱对偶性</strong></li></ol><p>​Lagrange对偶问题的最优值用$d^*$表示</p><ul><li>弱对偶性指$d^* \le p^*$，弱对偶性始终满足（即使原问题不是凸的）</li><li>强对偶性指$d^* &#x3D; p^*$，原问题是凸的时候通常（但不总是）满足强对偶性</li></ul><ol start="5"><li><strong>Slater约束准则</strong></li></ol><p>​对于一个凸问题</p><p>​<img src="https://s2.loli.net/2023/06/14/HOyYXrIz5w9Bnba.png"></p><p>​如果存在一个点$x \in intD$（内点），使得$f_i(x)&lt;0, and,Ax&#x3D;b$（即不等式约束严格成立），则称之为满足Slater约束，此时强对偶性成立</p><ol start="6"><li><strong>互补松弛性（Complementary slackness）</strong></li></ol><p>​假设强对偶性成立，$x^*$是原问题最优解，$(\lambda^*,\nu^*)$是对偶问题的最优解</p><p>​则有：</p><p>​<img src="https://s2.loli.net/2023/06/14/c13xleTfoOuFUPB.png"></p><p>​得到结论：</p><p>​<img src="https://s2.loli.net/2023/06/14/ibavpBdZtWIGM9U.png"></p><p>​该结论就是所谓的互补松弛性</p><ol start="7"><li><strong>KKT最优条件</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/icf9kDuy5ATP4v3.png"></p><p>​对于一个凸问题来说，若某组$(\tilde{x},\tilde{\lambda},\tilde{\nu})$满足KKT条件，那它们就是最优解</p><h1 id="Lecture-6-Approximation-and-fitting"><a href="#Lecture-6-Approximation-and-fitting" class="headerlink" title="Lecture_6 Approximation and fitting"></a>Lecture_6 Approximation and fitting</h1><ol><li><strong>范数逼近</strong></li></ol><p>​典型的范数逼近问题是具有以下形式的无约束问题：</p><p>​<img src="https://s2.loli.net/2023/06/14/jSk2PFMpO6194Bc.png"></p><p>​从<strong>逼近</strong>的角度进行解释：</p><p>​通过将 Ax 表示为$Ax&#x3D;x_1a_1+…+x_na_n$，其中 ai 为 A 的列，我们可以看出，范数逼近问题的目标是用 A 的列的线性组合，尽可能准确地逼近或拟合向量 b</p><ol start="2"><li><strong>最小二乘逼近</strong></li></ol><p>​取范数为2，则原问题转换为：<br>$$<br>min ||Ax-b||_2^2<br>$$<br>​将目标函数表示为凸二次函数：<br>$$<br>f(x)&#x3D;x^TA^TAx-2b^TAx+b^Tb<br>$$<br>​求其导数有：<br>$$<br>\nabla f(x)&#x3D;2A^TAx-2A^Tb&#x3D;0<br>$$<br>​即 x 满足：<br>$$<br>A^TAx&#x3D;A^Tb<br>$$<br>​可得其唯一解$x&#x3D;(A^TA)^{-1}A^Tb$</p><ol start="3"><li><strong>罚函数逼近</strong></li></ol><p>​$l_p范数逼近问题的目标函数为：<br>$$<br>(|r_1|^p+\cdots+|r_m|^p)^{1&#x2F;p}<br>$$<br>​其中 ri &#x3D; Ax - b ，称之为残差，所谓的范数逼近，就是要残差尽可能地小，那么我们可以把范数逼近问题转换为以下形式：</p><p>​<img src="https://s2.loli.net/2023/06/14/aLej2nqWCifJ9xI.png"></p><p>​其中 Φ 称之为罚函数，我们通常将Φ设为一个对称的、非负的凸函数，则上述问题是一个凸优化问题</p><p>​常见的罚函数：</p><ul><li><p>二次罚函数$\phi(u)&#x3D;u^{2}$</p></li><li><p>带死区的罚函数$\phi(u)&#x3D;\max{0,|u|-a}$</p></li><li><p>对数罚函数<br>$$<br>\phi(u)&#x3D;\begin{cases}-a^2\log(1-(u&#x2F;a)^2)&amp;|u|&lt;a\ \infty&amp;\text{otherwise}\end{cases}<br>$$</p></li></ul><img src="https://s2.loli.net/2023/06/14/weIWRO76KdrNubG.png" style="zoom:67%;" /><ol start="4"><li><strong>正则化逼近</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/u7foyTsC2RGOhxt.png"></p><p>​研究的是双目标优化问题，即同时让|Ax-b|和|x|尽可能地小，这在鲁棒逼近中可解释为：x 小的时候，Ax&#x3D;b对误差的鲁棒性更好</p><ol start="5"><li><strong>信号重构问题</strong></li></ol><p>​假设信号被加性噪声 v 污染，即<br>$$<br>x_{cor}&#x3D;x+v<br>$$<br>​所谓<strong>信号重构</strong>，就是在给定受污染信号 xcor 的情况下，构建对原始信号 x 的估计值 $\hat{x}$，也叫<strong>光滑化</strong></p><p>​重构问题的一个简单形式是双准则问题</p><p>​<img src="https://s2.loli.net/2023/06/14/wWBtCq4ouKRQpf8.png"></p><p>​其中 Φ 是凸的，称为正则化函数或光滑目标。这个双准则问题，就是要寻求一个接近被污染信号并且光滑的信号</p><ul><li>​<strong>二次光滑</strong></li></ul><img src="https://s2.loli.net/2023/06/14/zpAnhSduUiymxsj.png" style="zoom: 50%;" /><ul><li>​<strong>总变差重构</strong></li></ul><img src="https://s2.loli.net/2023/06/14/Csn6IaPi37WBqUd.png" style="zoom:67%;" /><ol start="6"><li><strong>鲁棒逼近</strong></li></ol><p>​问题形式为，在 A 不确定的情况下，最可能地最小化$||Ax-b||$</p><p>​两种解决思路：</p><ul><li>随机：假设 A 是随机的，最小化$E||Ax-b||$</li><li>最坏情况：求$min,sup||Ax-b||$</li></ul><h1 id="Lecture-10-Unconstrained-minimization"><a href="#Lecture-10-Unconstrained-minimization" class="headerlink" title="Lecture_10 Unconstrained minimization"></a>Lecture_10 Unconstrained minimization</h1><ol><li><strong>定义</strong></li></ol><p>​字面意思，没有约束条件的优化问题，我们假设 f 是可微凸函数，那么无约束优化问题其实就是去求梯度为零的点</p><p>​<img src="https://s2.loli.net/2023/06/14/yhokBVYK4SmZ7tv.png"></p><ol start="2"><li><strong>下降方法</strong></li></ol><p>​即选择合适的搜索步长 t</p><ul><li>​<strong>精确直线搜索</strong></li></ul><p>​找到让函数值最小的那个步长 t，即<br>$$<br>t&#x3D;argmin_{s \ge 0}, f(x+s\Delta x)<br>$$<br>​当目标函数形式简单，能求得解析解时可考虑使用这种方法</p><ul><li>​<strong>回溯直线搜索</strong></li></ul><p>​<img src="https://s2.loli.net/2023/06/14/9UpaeJWEyI3O5QF.png"></p><p>​基本思路是：先采用单位步长，若不满足条件，则不断缩小。</p><p>​满足条件时的几何意义：$f(x+t\Delta x)$落入两条虚线之间的范围</p><p>​<img src="https://s2.loli.net/2023/06/14/2cwMjJrspdaETqg.png" style="zoom:67%;" /></p><ol start="3"><li>其余内容参考<a href="https://qlhhahaha.github.io/2023/04/13/%E3%80%8A%E6%9C%80%E4%BC%98%E5%8C%96%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E6%96%87%E5%86%8D%E6%96%87%EF%BC%89%E7%AC%94%E8%AE%B0%E3%80%8B/#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E6%97%A0%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95">《最优化计算方法（文再文）笔记》</a></li></ol><h1 id="Lecture-11-Equality-constrained-minimization"><a href="#Lecture-11-Equality-constrained-minimization" class="headerlink" title="Lecture_11 Equality constrained minimization"></a>Lecture_11 Equality constrained minimization</h1><ol><li><strong>定义</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/jaecJsrBzb4qm2I.png"></p><p>​x* 为最优点的充要条件是：存在 v* 满足</p><p>​<img src="https://s2.loli.net/2023/06/14/noNjm1WsgJ9lSaF.png"></p><ol start="2"><li><p><strong>等式约束二次规划</strong></p><p><img src="https://s2.loli.net/2023/06/14/GCusPihe2NI9qVo.png"></p></li></ol><p>​那么此时最优性条件为：<br>$$<br>Ax^*&#x3D;b,, Px^*+q+A^Tv^*&#x3D;0<br>$$<br>​写成矩阵形式为：</p><p>​<img src="https://s2.loli.net/2023/06/14/IyCaHxuVe9DgzlO.png"></p><p>​称之为等式约束优化问题的<strong>KKT条件</strong></p><p>​</p><ol start="3"><li><strong>等式约束的Newton方法</strong></li></ol><p>​<img src="https://s2.loli.net/2023/06/14/jaecJsrBzb4qm2I.png"></p><p>​<strong>思路：</strong>二阶taylor展开转换为</p><p>​<img src="https://s2.loli.net/2023/06/14/JtYwfujRWzypMXd.png"></p><p>​即KKT条件为</p><p>​<img src="https://s2.loli.net/2023/06/14/VjD9yaUTbcBxd2E.png"></p><p>​最后求解出来的那个$\Delta x_{nt}$就是newton方向，$x+\Delta x_{nt}$是对原问题真正的最优解 x* 的一个很好的估计</p><p>​</p><p>​另外，我们定义newton减量为：</p><p><img src="https://s2.loli.net/2023/06/14/phw6qliF8BzTAuO.png"></p><p>​整个算法流程为：</p><p>​<img src="https://s2.loli.net/2023/06/14/odX7Gv6bLif8Vm9.png"></p>]]></content>
    
    
    <categories>
      
      <category>科研只为把业毕</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>凸优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《CS106L笔记》</title>
    <link href="/2023/04/14/%E3%80%8ACS106L%E7%AC%94%E8%AE%B0%E3%80%8B/"/>
    <url>/2023/04/14/%E3%80%8ACS106L%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>课程来源：Stanford-CS106L(22 fall)</p><p>课程介绍：<a href="https://github.com/qlhhahaha/HashMap_for_CS106L">HashMap_for_CS106L</a></p>          </div><h1 id="Lecture2、Types-and-Structs"><a href="#Lecture2、Types-and-Structs" class="headerlink" title="Lecture2、Types and Structs"></a>Lecture2、Types and Structs</h1><h2 id="一、Types"><a href="#一、Types" class="headerlink" title="一、Types"></a>一、Types</h2><ul><li><strong>静态语言：</strong>有名字的东西（变量&#x2F;函数）要人为给类型</li><li><strong>动态语言：</strong>运行时解释器根据current value自动给类型</li></ul><p><img src="https://s2.loli.net/2023/04/14/YX8tVdgN5bH6hiu.png"></p><p><img src="https://s2.loli.net/2023/04/14/kQbXxquftZjcAMz.png"></p><h1 id="Lecture3、Stream"><a href="#Lecture3、Stream" class="headerlink" title="Lecture3、Stream"></a>Lecture3、Stream</h1><h2 id="一、cout"><a href="#一、cout" class="headerlink" title="一、cout"></a>一、cout</h2><p>cout是std内嵌的输出流，它的类型是std::ostream，所以其实<strong>你也完全可以自己定义一个std::ostream类型的输出流</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writeToStream</span><span class="hljs-params">(std::ostream&amp; anyOutputStream, <span class="hljs-type">int</span> favouriteNumber)</span> </span>&#123;<br>    anyOutputStream &lt;&lt; <span class="hljs-string">&quot;Writing to stream: &quot;</span><br>        &lt;&lt; favouriteNumber &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Write an int to the user&#x27;s console.</span><br>    <span class="hljs-type">int</span> favouriteNumber = <span class="hljs-number">1729</span>;<br><br>    <span class="hljs-comment">// Write method to take any ostream</span><br>    <span class="hljs-function">std::ofstream <span class="hljs-title">fileOut</span><span class="hljs-params">(<span class="hljs-string">&quot;out.txt&quot;</span>)</span></span>;<br><br>    <span class="hljs-built_in">writeToStream</span>(cout, favouriteNumber);<br>    <span class="hljs-built_in">writeToStream</span>(fileOut, favouriteNumber + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码会在控制台上输出1729，在out.txt中写入1730</p><h2 id="二、cin"><a href="#二、cin" class="headerlink" title="二、cin"></a>二、cin</h2><p>同理，可以自己创建一个std::istream类型的输入流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//read numbers from a file</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readNumbers</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Create our istream and make it open the file</span><br>    <span class="hljs-function">std::istream <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-string">&quot;res/numbers.txt&quot;</span>)</span></span>;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        input &gt;&gt; value;<br>        <span class="hljs-keyword">if</span>(input.<span class="hljs-built_in">fail</span>())<br>            <span class="hljs-keyword">break</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value read: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://s2.loli.net/2023/04/14/GxBvd9eRrohVJXI.png"></p><h1 id="Lecture4、Initialization-and-References"><a href="#Lecture4、Initialization-and-References" class="headerlink" title="Lecture4、Initialization and References"></a>Lecture4、Initialization and References</h1><h2 id="一、Initialization"><a href="#一、Initialization" class="headerlink" title="一、Initialization"></a>一、Initialization</h2><ol><li>注意vector两种初始化的区别</li></ol><p><img src="https://s2.loli.net/2023/04/14/kPzA2belKB5qnNr.png" alt="Untitled"></p><div class="note note-warning">            <p>💡 PS. 其中大括号初始化被称为“统一初始化”，是C11引进的，对所有数据类型都适用，可以在declaration时立即初始化</p>          </div><ol start="2"><li><strong>结构化绑定（structured binding）</strong></li></ol><p>​idea：经典语法中，为了接收一个struct\pair，可能得用点号去一个个读取结构体里的值，这很麻烦；c17中引入结构化绑定，可以直接用<strong>auto+中括号</strong>去接收（话说这东西matlab里不是早有了吗。。）</p><p><img src="https://s2.loli.net/2023/04/14/suEOq9jPceZ7LD8.png"></p><h2 id="二、References"><a href="#二、References" class="headerlink" title="二、References"></a>二、References</h2><p>一个经典的引用error：想给pair中的每个值加一</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shift</span><span class="hljs-params">(vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&amp; nums)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [num1, num2]: nums) <br>&#123;<span class="hljs-comment">//显然错了，因为num1、2是nums的副本，开辟了新空间</span><br>num1++;<br>num2++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>应该修改为 for (auto&amp; [num1, num2]: nums)</p><h1 id="Lecture5、Container"><a href="#Lecture5、Container" class="headerlink" title="Lecture5、Container"></a>Lecture5、Container</h1><ol><li>不要搞混vector的_size和_capacity属性</li></ol><p><img src="https://s2.loli.net/2023/04/14/Zv2KtfI5RH7MVgW.png"></p><h1 id="Lecture7、Classes"><a href="#Lecture7、Classes" class="headerlink" title="Lecture7、Classes"></a>Lecture7、Classes</h1><ol><li>STL中所有的container都是class</li><li><strong>模板类（template class）</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//模板类语法</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span> Second&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">my_pair</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">First <span class="hljs-title">get_first</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Second <span class="hljs-title">get_second</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_first</span><span class="hljs-params">(First f)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_second</span><span class="hljs-params">(Second f)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>First first;<br>Second second;<br>&#125;;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*****************vector.h********************/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector.cpp&quot;</span>           <span class="hljs-comment">//ps2</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vector</span>&lt;T&gt;<br>&#123;<br><span class="hljs-function">T <span class="hljs-title">my_at</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>&#125;<br><br><span class="hljs-comment">/*****************vector.cpp********************/</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;       <span class="hljs-comment">//ps1</span><br><span class="hljs-type">void</span> vector&lt;T&gt;::<span class="hljs-built_in">my_at</span>(<span class="hljs-type">int</span> i)<br>&#123;<br><span class="hljs-comment">//oops</span><br>&#125;<br><br><span class="hljs-comment">/*****************main.cpp********************/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector.h&quot;</span></span><br>vector&lt;<span class="hljs-type">int</span>&gt; a;<br>a.<span class="hljs-built_in">my_at</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><div class="note note-warning">            <aside> 💡 PS.<ol><li>首先，注意必须在每个成员函数那儿去声明一遍它是template，也就是去掉ps1那一行会报错</li><li>ps2那一行，注意，vector.h头文件里要include “vector.cpp”，否则找不到my_at()函数的具体定义 （想了老半天也没想清楚为啥。。嗯记着吧）</li><li>一般不在头文件里include源文件，因为可能造成重复定义；但也有一些场景或许会用，比如vscode里懒得写cmake脚本，就可以用include&lt;.cpp&gt;这种trick。。</li></ol>          </div><p><img src="https://s2.loli.net/2023/04/14/oDHRjb3kGdw2ON8.jpg"></p><h1 id="Lecture9、Template-Functions"><a href="#Lecture9、Template-Functions" class="headerlink" title="Lecture9、Template Functions"></a>Lecture9、Template Functions</h1><ol><li><p><strong>motivation：</strong>一个功能通用性很强的函数，要因为接收参数数据类型不同而复制粘贴多个版本吗？当然，function overloading可以简化这个问题，但仍然得复制粘贴，能不能把这个函数给一般化，从根源上解决问题捏？</p><p><img src="https://s2.loli.net/2023/04/14/xJfgFth1wOmLb5I.png"></p></li><li><p><strong>模板函数（Template Functions）</strong></p><p><img src="https://s2.loli.net/2023/04/14/9zcsDjKper6XuOI.png"></p><p>其中typename可以设定默认参数，即写成template<typename Type=int></p><p>在实例化使用的时候，可以显式定义Type</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">myMin</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>当然，它还可以更聪明——我们隐式声明变量，让编译器自己推断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">smarterMyMin</span><span class="hljs-params">(T a, U b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &lt; b ? a : b;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-built_in">smarterMyMin</span>(<span class="hljs-number">3.2</span>, <span class="hljs-number">4</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>💡 PS. 注意：模板类和模板函数都是在使用（即实例化）之后才会编译！不用就不编译。 而不同的实例化编译出的结果也不一样，所以其实是编译器帮你完成了“复制粘贴多个版本”这一步。</p>          </div></li></ol><h1 id="Lecture10、Lambda-Functions"><a href="#Lecture10、Lambda-Functions" class="headerlink" title="Lecture10、Lambda Functions"></a>Lecture10、Lambda Functions</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">abssort</span><span class="hljs-params">(<span class="hljs-type">float</span>* x, <span class="hljs-type">unsigned</span> n)</span> </span>&#123;<br>    std::<span class="hljs-built_in">sort</span>(x, x + n,<br>        <span class="hljs-comment">// Lambda expression begins</span><br>        [](<span class="hljs-type">float</span> a, <span class="hljs-type">float</span> b) &#123;<br>            <span class="hljs-built_in">return</span> (std::<span class="hljs-built_in">abs</span>(a) &lt; std::<span class="hljs-built_in">abs</span>(b));<br>        &#125; <span class="hljs-comment">// end of lambda expression</span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/N5Y3hbXFqJDOmaU.png"></p><p><strong>捕获列表的作用：</strong></p><ol><li>[ ]是lambda引出符，编译器根据该引出符判断接下来的代码是否是lambda函数</li><li>捕捉上下文中的变量供lambda使用</li></ol><p><strong>捕获列表使用：</strong></p><ul><li>[ ]表示不捕获任何变量</li><li>[var]、[&amp;var]分别表示以值传递和引用传递的方式捕捉变量var</li><li>[&#x3D;]、[&amp;]分别表示以值传递和引用传递方式捕获所有<strong>父作用域</strong>的变量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">auto</span> function = ([]()<br>&#123;num = <span class="hljs-number">1000</span>;<br>index = <span class="hljs-number">2</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;index: &quot;</span>&lt;&lt; index &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> <br>            &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span>&lt;&lt; num &lt;&lt; std::endl; &#125;);<br><br><span class="hljs-built_in">function</span>();<br><span class="hljs-comment">//报错，因为没去捕获num和index就在使用它们</span><br><br><span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">auto</span> function = ([=]()<br>&#123;num = <span class="hljs-number">1000</span>;<br>index = <span class="hljs-number">2</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;index: &quot;</span>&lt;&lt; index &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> <br>            &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span>&lt;&lt; num &lt;&lt; std::endl; &#125;);<br><br><span class="hljs-built_in">function</span>();<br><span class="hljs-comment">//报错，因为lambda的值引用默认不能修改，要修改的话得加mutable关键字</span><br><br><span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">auto</span> function = ([=]()<span class="hljs-keyword">mutable</span><br>&#123;num = <span class="hljs-number">1000</span>;<br>index = <span class="hljs-number">2</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;index: &quot;</span>&lt;&lt; index &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> <br>            &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span>&lt;&lt; num &lt;&lt; std::endl; &#125;);<br><br><span class="hljs-built_in">function</span>();<br><span class="hljs-comment">//正确，因为加了mutable关键字，值传递变量可修改（但改的也是副本，不影响原值）</span><br><br><span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">auto</span> function = ([&amp;]()<br>&#123;num = <span class="hljs-number">1000</span>;<br>index = <span class="hljs-number">2</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;index: &quot;</span>&lt;&lt; index &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> <br>            &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span>&lt;&lt; num &lt;&lt; std::endl; &#125;);<br><br><span class="hljs-built_in">function</span>();<br><span class="hljs-comment">//正确，引用传递的值可以修改</span><br></code></pre></td></tr></table></figure><p>以上述代码为例，思考Lambda的意义（和普通函数相比）：</p><ol><li><p>省去定义一个完整函数、给函数命名的过程，对于这种<strong>不需要复用</strong>，且<strong>短小</strong>的函数，直接传递函数体可以增加代码的可读性。所以lambda函数又叫“匿名函数”。</p><div class="note note-warning">            <p>💡 PS. 不要小看“省略命名”这件事，表面上看它只是少了个名字，但实质是把它看作一个普通的“操作过程”而非“对象”。就像你会给一个变量、类、函数命名，但不会单独给“把a乘上c的3次方再加123再除321”这种纯过程去命个名（除非这个操作复用率足够高），因为它抽象程度太低，即用即扔。 <strong>而所有值得去命名的东西，都应该是会复用且抽象程度足够的。我认为这是编程中的一种哲学思想。</strong> 如：一个普通操作复用程度足够高时（比较int a、int b大小），就把它抽象为一个函数（max函数）；而这个函数复用率够高时，就进一步抽象为template function</p>          </div></li><li><p>允许函数作为一个对象进行<strong>传递</strong>：lambda也可以命名，然后将其进行传递。这种方式和传统的函数指针比起来更加简明。</p></li><li><p>引入<strong>闭包</strong>：闭包是指将当前作用域中的变量通过值或者引用的方式封装到lambda表达式当中，成为表达式的一部分，它使你的lambda表达式从一个普通的函数变成了一个带隐藏参数的函数。</p></li></ol><p>常见应用场景：</p><ol><li><p><strong>用于stl算法库</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// for_each应用实例</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">2</span>, <span class="hljs-number">33</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-built_in">sort</span>(a, a+<span class="hljs-number">4</span>, [=](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> x%<span class="hljs-number">10</span> &lt; y%<span class="hljs-number">10</span>; &#125; );<br>for_each(a, a+<span class="hljs-number">4</span>, [=](<span class="hljs-type">int</span> x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125; );<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>💡 PS. foreach()这个东西在#include<algorithm>里，是个template function，其前两个参数是begin和end指针</p>          </div></li><li><p><em><strong>*用于多线程场景*</strong></em></p></li><li><p><strong>作为函数的入参</strong></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> FuncCallback = std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">void</span>)&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DataCallback</span><span class="hljs-params">(FuncCallback callback)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Start FuncCallback!&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-built_in">callback</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;End FuncCallback!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">auto</span> callback_handler = [&amp;]()&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;This is callback_handler&quot;</span>;<br>&#125;;<br><br><span class="hljs-built_in">DataCallback</span>(callback_handler);<br></code></pre></td></tr></table></figure><h1 id="Lecture12、Specical-Member-Functions-6个"><a href="#Lecture12、Specical-Member-Functions-6个" class="headerlink" title="Lecture12、Specical Member Functions(6个)"></a>Lecture12、Specical Member Functions(6个)</h1><ol><li><p><strong>介绍：</strong></p><p>C++中类的特殊成员函数有6个，对于一个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123; m_data = data; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>编译器会自动帮我们生成这些特殊成员函数，所以类A的定义等价于如下，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;; <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; other) &#123; m_data = other.m_data; &#125; <span class="hljs-comment">// 拷贝构造函数</span><br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; other) &#123; m_data = other.m_data; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125; <span class="hljs-comment">// 拷贝赋值构造函数</span><br>    ~<span class="hljs-built_in">A</span>() &#123;&#125; <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-built_in">A</span>(A&amp;&amp; other) &#123; m_data = other.m_data; &#125; <span class="hljs-comment">// 移动构造函数</span><br>    A&amp; <span class="hljs-keyword">operator</span>=(A&amp;&amp; other) &#123; m_data = other.m_data; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125; <span class="hljs-comment">// 移动赋值构造函数</span><br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123; m_data = data; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_data;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>拷贝构造函数（copy constructor）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream &gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">double</span> real, imag;<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) &#123;<br>        real= r; imag = i;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">cl</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Complex <span class="hljs-title">c2</span> <span class="hljs-params">(cl)</span></span>;  <span class="hljs-comment">//用拷贝构造函数初始化c2</span><br>    cout&lt;&lt;c2.real&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;c2.imag;  <span class="hljs-comment">//输出 1,2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果用户自己编写了复制构造函数，则默认复制构造函数就不存在了</p></li><li><p><strong>拷贝赋值构造函数（copy assignment constructor）</strong></p><p>对“＝”进行重载，作用是让两个已经初始化完毕的类进行拷贝</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CPP">myclass A,B；<br>A = B；<br></code></pre></td></tr></table></figure></li></ol><div class="note note-warning">            <p>​💡 PS. 上述两个构造函数的应用其实都非常非常广泛 —— 别忘了，stl的容器全都是类！ vector<int>nums1 &#x3D; nums2也用了拷贝赋值构造函数！</p>          </div><ol start="4"><li><strong>深拷贝与浅拷贝</strong></li></ol><ul><li><p>大部分正常情况下只需要浅拷贝（如基本数据类型、简单的类），int A &#x3D; B，就是B所在内存中的数据按二进制位（bit）复制到A所在的内存</p></li><li><p>深拷贝用于什么情况捏？假设有某个类有两个实例A、B，类持有<strong>动态分配的内存&#x2F;指向其他数据的指针，</strong>那此时就不能简单地A &#x3D; B，否则A中的指针也会指向B中指针对应的内存，这样一来，一修改A，B也会随之被修改，没达到拷贝的效果。</p><p>正确做法是，去显式地定义一个拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，<strong>原有对象和新对象所持有的动态内存是相互独立的</strong>，更改一个对象的数据不会影响另外一个对象。</p></li></ul><div class="note note-warning">            <p>​💡 PS. 如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足矣。</p>          </div><ul><li><strong>深拷贝的开销往往比浅拷贝大</strong>（除非没有指向动态分配内存的属性），所以我们倾向于尽可能使用浅拷贝</li></ul><ol start="5"><li><p><strong>左值、右值</strong></p><ul><li><p>左值（lvalue）：表达式结束后依然存在的持久对象</p></li><li><p>右值（rvalue）：表达式结束后就不再存在的临时对象。字面量（字符字面量除外）、临时的表达式值、临时的函数返还值这些短暂存在的值都是右值。</p></li></ul><p>更直观的理解是：有变量名的对象都是左值，没有变量名的都是右值。（因为有无变量名意味着这个对象是否在下一行代码时依然存在）</p></li></ol><p>​<div class="note note-warning">            <p>​💡 PS. 值得注意的是，字符字面量是唯一不可算入右值的字面量，因为它实际存储在静态内存区，是持久存在的</p><p>​</p>          </div></p><ol start="6"><li><p><strong>右值引用</strong></p><p>右值引用类型 &amp;&amp;用于匹配右值，左值引用&amp;用于匹配左值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//左值引用形参=&gt;匹配左值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::Copy</span><span class="hljs-params">(Vector&amp; v)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;num = v.num;<br>    <span class="hljs-keyword">this</span>-&gt;a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[num];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;++i)&#123;a[i]=v.a[i]&#125;<br>&#125;<br><br><span class="hljs-comment">//右值引用形参=&gt;匹配右值</span><br><span class="hljs-type">void</span> Vector::<span class="hljs-built_in">Copy</span>(Vector&amp;&amp; temp)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;num = temp.num;<br>    <span class="hljs-keyword">this</span>-&gt;a = temp.a;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个对应关系：</p><p>左值 —— 左值引用 —— 深拷贝</p><p>右值 —— 右值引用 —— 浅拷贝</p><p>这和深浅拷贝的定义是相符的，因为右值临时存在，用完就丢，所以就不存在拷贝之后动态分配内存冲突的问题，那就只需要浅拷贝；左值反之</p></li><li><p><strong>强转右值std::move()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    Vector result;<br>    <span class="hljs-comment">//...DoSomething with result</span><br><br>    <span class="hljs-keyword">if</span>(xxx)&#123;ans = result;&#125;  <br><span class="hljs-comment">//现在我希望把结果提取到外部的变量ans上</span><br><br><span class="hljs-comment">//...Do other things without result</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>result赋值给ans后就不再被使用，因此我们期望它调用的是<strong>移动赋值构造函数</strong>。 但是result是一个有变量名的左值类型，因此ans &#x3D; result 调用的是拷贝赋值构造函数而非移动赋值构造函数</p><p>解决办法：用c++11提供的move强转右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    Vector result;<br>    <span class="hljs-comment">//...DoSomething with result</span><br>   <br><span class="hljs-keyword">if</span>(xxx)&#123;ans = std::<span class="hljs-built_in">move</span>(result);&#125;   <br><span class="hljs-comment">//调用的是移动赋值构造函数</span><br><br><span class="hljs-comment">//...Do other things without result</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>右值引用类型和右值的关系</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; o)</span> </span>&#123;std::cout &lt;&lt; <span class="hljs-string">&quot;为左值。&quot;</span> &lt;&lt; std::endl;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; temp)</span> </span>&#123;std::cout &lt;&lt; <span class="hljs-string">&quot;为右值。&quot;</span> &lt;&lt; std::endl;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span>&amp;&amp; b = <span class="hljs-number">10</span>;<br>  <span class="hljs-comment">//请分别回答：a、std::move(a)、b 分别是左值还是右值？</span><br><span class="hljs-built_in">test</span>(a);<br><span class="hljs-built_in">test</span>(std::<span class="hljs-built_in">move</span>(a));<br><span class="hljs-built_in">test</span>(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>答：a是左值，std::move(a)是右值，但b却是左值。</p><p>在这里b虽然是 int&amp;&amp; 类型，但却因为有变量名（即可持久存在），被编译器认为是左值。</p><p><strong>结论：右值引用类型只是用于匹配右值，而并非表示一个右值。因此，尽量不要声明右值引用类型的变量，而只在函数形参使用它以匹配右值。</strong></p></li><li><p><strong>补充：构造函数之后的冒号</strong></p><p>c++的语法特性，冒号后面跟的是赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb):<span class="hljs-built_in">a</span>(aa), <span class="hljs-built_in">b</span>(bb) &#123;&#125;<br><br><span class="hljs-comment">//相当于</span><br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb)<br>&#123;<br>a=aa;<br>b=bb;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="Lecture13、RAII-and-Smartpointer"><a href="#Lecture13、RAII-and-Smartpointer" class="headerlink" title="Lecture13、RAII and Smartpointer"></a>Lecture13、RAII and Smartpointer</h1><ol><li><p><strong>motivation</strong></p><p>手动申请动态内存+手动释放会有什么问题呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Person* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(id_number);<br><br><span class="hljs-comment">//do something</span><br><br><span class="hljs-keyword">delete</span> p;<br></code></pre></td></tr></table></figure><p>若在申请完内存之后，do something的过程中用抛出了异常（throw an exception），那就无法执行delete p，从而造成内存泄漏（leak memory）。 此问题还不止是指针，文件的open和close、线程的try_lock和unlock、套接字的socket和close，都是这样的“配套操作”，</p><p>为了解决这个问题，我们可以使用RAII（Resource Acquisition is Initalization）原则，其核心思想是：</p><ul><li><strong>All resources used by a class should be acquired in the constructor</strong></li><li><strong>All resources used by a class should be released in the destructor</strong></li></ul><p>即key idea是利用<strong>“对象的析构是自动完成的”</strong> —— 由于对象在go out of its own scope后，析构函数总是会被自动调用，那么只要遵循上面两点原则，就可以避免内存泄漏了</p></li><li><p><strong>实例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br> <br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000000</span>; i++)<br>&#123;<br><span class="hljs-type">int32_t</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int32_t</span>[<span class="hljs-number">3</span>];<br>ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>ptr[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>ptr[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br><span class="hljs-comment">//delete ptr;     //假设忘记了释放内存</span><br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可想而知会占据极大的内存空间</p><p>我们将其改进为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">auto_release_ptr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">auto_release_ptr</span>(T *t) :<span class="hljs-type">_t</span>(t)&#123;&#125;;<br>~<span class="hljs-built_in">auto_release_ptr</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> <span class="hljs-type">_t</span>;<br>&#125;;<br> <br><span class="hljs-function">T * <span class="hljs-title">getPtr</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">_t</span>;<br>&#125;<br> <br><span class="hljs-keyword">private</span>:<br>T *<span class="hljs-type">_t</span>;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000000</span>; i++)<br>&#123;<br><span class="hljs-keyword">auto</span> arp = <span class="hljs-built_in">auto_release_ptr</span>&lt;<span class="hljs-type">int32_t</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">int32_t</span>[<span class="hljs-number">3</span>]);<br><span class="hljs-type">int32_t</span> *ptr = arp.<span class="hljs-built_in">getPtr</span>();<br>ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>ptr[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>ptr[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong>将申请的int指针托管给模板类auto_release_ptr，再去声明一个普通int指针指向申请的内存空间（通过接收类成员函数的返回值实现），从而让ptr 与 auto_release_ptr 拥有了相同的生命周期，每次for循环自动析构释放，非常妙。</p></li><li><p><strong>智能指针</strong></p><p><strong>（1）std : : unique_ptr</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//普通指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">raw_ptr_fun</span><span class="hljs-params">()</span></span>&#123;<br>Node* n = <span class="hljs-keyword">new</span> Node;<br><span class="hljs-comment">//do things with n </span><br><span class="hljs-keyword">delete</span> n;<br>&#125;<br><br><span class="hljs-comment">//智能指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">smart_ptr_fun</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-function">std::unique_ptr&lt;Node&gt; <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-keyword">new</span> node)</span></span>;<br><span class="hljs-comment">//do things with n </span><br><span class="hljs-comment">//automatically freed!</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li>无法进行左值的赋值或赋值构造，但允许临时右值赋值构造和赋值（用move语义）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m Li Ming!&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m age 22.&quot;</span>))</span></span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//p1 = p2;// error！禁止左值赋值</span><br><span class="hljs-comment">//unique_ptr&lt;string&gt; p3(p2);// error！禁止左值赋值构造</span><br><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(std::move(p1))</span></span>;<br>p1 = std::<span class="hljs-built_in">move</span>(p2);<span class="hljs-comment">// 使用move把左值转成右值就可以赋值了</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1 = p2 赋值后：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/SjMudQh6KBbCa21.png"></p><div class="note note-warning">            <p>💡 PS. 在这里也可以看到，把p2 move成临时值之后，一赋值给p1，它就被释放掉了，内存地址为nullptr</p>          </div><ul><li>排它式资源享用：两个指针不能指向同一个资源</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unique_ptr&lt;string&gt; p1;<br>string *str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;智能指针的内存管理陷阱&quot;</span>);<br>p1.<span class="hljs-built_in">reset</span>(str);<span class="hljs-comment">// p1托管str指针</span><br>&#123;<br>unique_ptr&lt;string&gt; p2;<br>p2.<span class="hljs-built_in">reset</span>(str);<span class="hljs-comment">// p2接管str指针时，会先取消p1的托管，然后再对str的托管</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p2:&quot;</span> &lt;&lt;  *p2 &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 此时p1已经没有托管内容指针了，为NULL，在使用它就会内存报错！</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p1:&quot;</span> &lt;&lt; *p1 &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/R8OfldcxjaFIHEV.png"></p><p><strong>（2）std : : shared_ptr</strong></p><p><strong>idea:</strong> 记录引用特定内存对象的智能指针数量，当复制或拷贝时，<strong>引用计数加1</strong>，当智能指针析构时，<strong>引用计数减1</strong>，如果计数为零，代表已经没有指针指向这块内存，那么我们就释放它</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;构造函数 \\t &quot;</span> &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数 \\t &quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>shared_ptr&lt;Person&gt; sp1;<br><br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Person())</span></span>;<br><br><span class="hljs-comment">// 获取智能指针管控的共享指针的数量use_count()：引用计数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;sp1use_count() = &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2use_count() = &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl &lt;&lt; endl;<br><br><span class="hljs-comment">// 共享,即sp1和sp2共同托管同一个指针</span><br>sp1 = sp2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;sp1use_count() = &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2use_count() = &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl &lt;&lt; endl;<br><br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(sp1)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp1use_count() = &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2use_count() = &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2use_count() = &quot;</span> &lt;&lt; sp3.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/cK9a5qX7MnjQHlv.png"></p><p><strong>（3）std : : weak_ptr</strong></p><p>​TO-DO</p></li><li><p><strong>智能指针初始化方式</strong></p><p>常规初始化方式有两种：显式调用new、使用make_unique()函数</p></li></ol><p><img src="https://s2.loli.net/2023/04/14/dIVEwpKhf47G5aH.png"></p><p><strong>Q:</strong> Which is better？</p><p><strong>A:</strong> std : : make_unique和std : : make_shared更好，因为<strong>显式调用new会分配两次内存</strong>（一次给up，一次是new T）</p><hr><h1 id="Assignment：HashMap"><a href="#Assignment：HashMap" class="headerlink" title="Assignment：HashMap"></a>Assignment：HashMap</h1><ol><li><p><strong>using关键字</strong></p><p>可用于设置别名，功能类似于typedef</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> value_type = std::pair&lt;<span class="hljs-type">const</span> K, M&gt;;<br></code></pre></td></tr></table></figure></li><li><p><strong>explicit关键字</strong></p><p>修饰class的constructor，令其只能显式声明，不能隐式转换or赋值初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bucket_count, <span class="hljs-type">const</span> H&amp; hash = H())</span></span>;<br> <br><span class="hljs-function">HashMap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">map</span><span class="hljs-params">(<span class="hljs-number">1.0</span>)</span></span>;  <span class="hljs-comment">// double -&gt; int conversion not allowed.</span><br>HashMap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map = <span class="hljs-number">1</span>;   <span class="hljs-comment">// copy-initialization, does not compile.</span><br></code></pre></td></tr></table></figure></li><li><p><strong>成员函数末尾加const —— 常成员函数</strong></p><p>const成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要目的还是保护数据。通常将 get类型的函数（get_value、get_size。。）设置为常成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><p>​</p><div class="note note-warning">            <p>💡 PS.</p><ol><li>需要强调的是，必须在成员函数的声明和定义处同时加上 const 关键字。<code>char *getname() const</code>和<code>char *getname()</code>是两个不同的函数原型，如果只在一个地方加 const 会导致声明和定义处的函数原型冲突。</li><li>区分一下 const 的位置：<ul><li>函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如<code>const char * getname()</code></li><li>函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如<code>char * getname() const</code></li></ul></li></ol>          </div></li><li><p><strong>noexcept关键字</strong></p><p>程序员在语义层面声明“我保证这个函数不会异常，编译器你不用检查了”，之后编译器就不会对该函数进行异常检查，也没办法实施try-catch操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_not_throw</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// noexcept函数中本不应有throw，没意义，但编译器不会检查是否有throw</span><br><span class="hljs-comment">// 所以编译通过，不会报错（可能会有警告）</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">func_not_throw</span>(); <span class="hljs-comment">// 直接 terminate，不会被 catch</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;catch int&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>注意：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTest</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;const&quot;</span> &lt;&lt; endl;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;normal&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CTest a;<br>a.<span class="hljs-built_in">show</span>();<br> <br><span class="hljs-type">const</span> CTest b;<br>b.<span class="hljs-built_in">show</span>();<br> <br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/48HvQ9oENy1ksPd.png"></p><p>这两个show函数可不是重载！<strong>重载函数的形参必须不同！！</strong>这俩就不是同一个函数原型（因为加了const，是常成员函数）</p><p>那么调用的时候如何区分这俩捏？</p><p>它们各自被调用的时机为：<strong>如果定义的对象是常对象，则调用的是const成员函数，如果定义的对象是非常对象，则调用重载的非const成员函数。</strong></p><div class="note note-warning">            <p> 💡 PS. 不过从另一个角度来理解，也可以把它俩看成重载 —— 首先理解下函数签名：它包含着一个函数的信息，包括<strong>函数名、参数类型、参数个数、顺序以及它所在的类和命名空间，</strong>两个函数只有在签名不同时才能被区分。<br>那上面两个show( )的签名到底哪里不同了捏？ 答案是参数类型，每个成员函数的参数中其实自带this指针，只不过藏起来了，谁调用成员函数，this 就指向谁。<strong>而成员函数尾巴上的const，实质修饰的是this指针！</strong> 当a调用show方法时，函数签名为show(a){}，即a传给this指针，一看，诶！a为非常对象，对应普通this指针，即非const版本的show()；b同理。</p>          </div></li><li><p><strong>typename关键字作用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Map, <span class="hljs-type">bool</span> IsConst&gt;<br><span class="hljs-keyword">typename</span> HashMapIterator&lt;Map, IsConst&gt;::reference HashMapIterator&lt;Map, IsConst&gt;::<span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> _node-&gt;value; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>作为类型声明，效果完全等同于class —— 代码中的typename Map等同于class Map，它俩都是告诉编译器，“我后面跟着的这个是个类型名称，而不是成员变量或成员函数”。（这好像也能映证“模板函数在实例化后才会被编译”）</p></li><li><p>作为<strong>修饰关键字：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; proto)</span></span>&#123;<br>    <span class="hljs-function">T::const_iterator <span class="hljs-title">it</span><span class="hljs-params">(proto.begin())</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>motivation：</strong>虽然人类编程者一眼就知道const_iterator是个类型名称，但编译器不知道呀，万一它是个变量呢？在模板实例化之前，完全没有办法来区分它们，所以这个写法是会error的！ 怎么办捏？ 这时候就需要使用typename关键字来修饰，编译器才会将该名称当成是类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typename</span> T::const_iterator <span class="hljs-title">it</span><span class="hljs-params">(proto.begin())</span></span>;<br></code></pre></td></tr></table></figure><p>这样编译器就可以确定T: :const_iterator是一个类型，而不再需要等到实例化时期才能确定，因此消除了前面提到的歧义。</p><div class="note note-warning">            <p>💡 PS. 总结：同时使用模板类T和域解析符: : 时，就得加typename</p>          </div></li></ul></li><li><p>模板类中的成员函数（往往也是模板函数）的具体实现通常也会放在.h中，除非函数太多太长</p></li><li><p>两个指针相减 &#x3D; 两指针的地址差值&#x2F;sizeof(数据类型)，即得到的结果就是两指针之间间隔的元素个数</p><p>注意： 不需要人为手动去除sizeof哈！减号自动会完成这个操作（c和cpp中都是）</p></li><li><p><strong>运算符重载</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//秒表类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">stopwatch</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">stopwatch</span>(): <span class="hljs-built_in">m_min</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">m_sec</span>(<span class="hljs-number">0</span>)&#123; &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setzero</span><span class="hljs-params">()</span></span>&#123; m_min = <span class="hljs-number">0</span>; m_sec = <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function">stopwatch <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 运行</span><br>    stopwatch <span class="hljs-keyword">operator</span>++();  <span class="hljs-comment">//++i，前置形式</span><br>    stopwatch <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> n);  <span class="hljs-comment">//i++，后置形式</span><br>    <span class="hljs-keyword">friend</span> ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream &amp;, <span class="hljs-type">const</span> stopwatch &amp;);<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_min;  <span class="hljs-comment">//分钟</span><br>    <span class="hljs-type">int</span> m_sec;  <span class="hljs-comment">//秒钟</span><br>&#125;;<br><br><span class="hljs-function">stopwatch <span class="hljs-title">stopwatch::run</span><span class="hljs-params">()</span></span>&#123;<br>    ++m_sec;<br>    <span class="hljs-keyword">if</span>(m_sec == <span class="hljs-number">60</span>)&#123;<br>        m_min++;<br>        m_sec = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>stopwatch stopwatch::<span class="hljs-keyword">operator</span>++()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">run</span>();<br>&#125;<br><br>stopwatch stopwatch::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> n)&#123;<br>    stopwatch s = *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-built_in">run</span>();<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;( ostream &amp; out, <span class="hljs-type">const</span> stopwatch &amp; s)&#123;<br>    out&lt;&lt;<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>)&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>)&lt;&lt;s.m_min&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>)&lt;&lt;s.m_sec;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stopwatch s1, s2;<br><br>    s1 = s2++;<br>    cout &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span>&lt;&lt; s1 &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;s2: &quot;</span>&lt;&lt; s2 &lt;&lt;endl;<br>    s1.<span class="hljs-built_in">setzero</span>();<br>    s2.<span class="hljs-built_in">setzero</span>();<br><br>    s1 = ++s2;<br>    cout &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span>&lt;&lt; s1 &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;s2: &quot;</span>&lt;&lt; s2 &lt;&lt;endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++运算符重载，本质上等于定义一个成员函数(实际上也可能是全局函数)。例如a+b，本质上等同于调用函数<strong>「a.operator+(b)」</strong>，该函数的名字叫「operator+」 ++的重载分为前置和后置情况，a &#x3D; ++b;(前置)， a &#x3D; b++;(后置)。因为符号一样，所以给后置版本加一个int形参作为区分，这个形参是0，但是在函数体中是用不到的，只是为了区分前置后置。 至于为啥加了个形参就能区分前后缀，没想懂，也没查到资料</p></li><li><p><strong>this指针</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br>HashMap&lt;K, M, H&gt;::~<span class="hljs-built_in">HashMap</span>() &#123;<br>    <span class="hljs-built_in">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用clear()用不用加this指针？ 答案是可加可不加，编译器都会隐式调用</p><p>Q: 什么时候this指针是必不可少的捏？ </p><p>A: 当你在对象方法里需要<strong>明确</strong>使用自己的时候，比如区分同名的形参和成员变量</p></li><li><p>当一个函数的返回值为引用类型时，<strong>不要return 某个在stack上的变量的引用！</strong>（否则该函数一退出，stack就释放，引用就掉了）</p></li><li><p><strong>遍历类的实例化对象（自定义类的迭代器）</strong></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> HashMap&lt;K, M, H&gt;&amp; lhs, <span class="hljs-type">const</span> HashMap&lt;K, M, H&gt;&amp; rhs) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [key, mapped] : lhs)&#123;<br>        。。。<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Q: lhs是自定义的HashMap类，其成员变量不只是装有&lt;key, mapped&gt;的链表，还有各种int size、int load_factor等属性啊，为啥可以直接用 : 进行range based for loop捏？或者说，为啥只会循环到想要的链表，而不会访问其它成员变量捏？</p><p>A: 之所以会有上述误区，<strong>是因为把range based循环当成了编译器内置运算符，事实上是自己要为该类定义一个iterator类！</strong></p><p>range based的 : 符号只是一种简略写法，它的源码实现大概为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> ( range_declaration : range_expression) loop_statement<br>&#123;  <br>    <span class="hljs-keyword">auto</span> &amp;&amp; __range = range_expression ;   <br>    <span class="hljs-keyword">auto</span> __begin = <span class="hljs-built_in">begin_expr</span>(__range);   <br>    <span class="hljs-keyword">auto</span> __end = <span class="hljs-built_in">end_expr</span>(__range);   <br>    <span class="hljs-keyword">for</span> (;__begin != __end; ++__begin) &#123;  <br>        range_declaration = *__begin;   <br>        loop_statement   <br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p>由此可见，自定义的iterator类至少要有5个功能：</p><ul><li>begin( )</li><li>end( )</li><li>重载++、*、! &#x3D;三个运算符</li></ul><p>其中begin( )、end( )返回类型就是iterator</p><p>现在就可以理解为啥可用range based循环获取自定义类中想要的数据了 —— iterator功能全是用户自己定义的，想获取啥就获取啥捏</p><ol start="13"><li><strong>Q: 右值引用的类对象的属性也是右值吗？</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//移动构造函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br>HashMap&lt;K, M, H&gt;::<span class="hljs-built_in">HashMap</span>(HashMap&amp;&amp; rhs):<br>    _size&#123;rhs._size&#125;,<br>    _hash_function&#123;rhs._hash_function&#125;,<br>    _buckets_array&#123;rhs.<span class="hljs-built_in">bucket_count</span>(), <span class="hljs-literal">nullptr</span>&#125; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">bucket_count</span>(); i++)&#123;<br>        _buckets_array[i] = rhs._buckets_array[i];<br>        rhs._buckets_array[i] = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    rhs._size = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>A: 将类对象用move()强转为右值，并不影响类中成员变量的左右值属性，该是啥还是啥</p><ol start="14"><li><p><strong>对上面这个问题的进一步深层理解：</strong></p><p>Q: 被move()过的变量会被编译器自动给销毁吗？如果会，那为啥还要手动让rhs._buckets_array[i] 指向nullptr？如果不会，那强转右值有啥意义啊？</p><p>A: 变量会被怎么处理，与它是否被move()过没半毛钱关系，<strong>move()并不改变变量本身，只是额外提供了一个return的右值</strong>，这一点看源码即可明白</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// FUNCTION TEMPLATE move</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function"><span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(_Ty&amp;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);<br>&#125;<br><span class="hljs-comment">//只是把返回值用static_cast强制转换成右值，但传入的原变量该是啥还是啥</span><br></code></pre></td></tr></table></figure><p>那move()的意义是啥捏 —— <strong>多提供一种数据类型，用于重载函数的形参匹配</strong>。 说白了，就是<strong>手动帮助编译器选择重载函数，同时向编译器发誓再也不碰这个对象</strong>！ 那这个作用的motivation又是啥捏 —— 若没有右值引用，那拷贝函数就要分成deep_copy()和shallow_copy()两个版本来写，且每次都要手动显式调用 —— 这既麻烦，又容易出错；但利用重载写成copy(const T&amp; val)和copy(T&amp;&amp; val)后，就可以让编译器自动调用。而若用户自己发现，诶！这个指针a虽然是左值，但我之后不用了，可以直接浅拷贝，ok，那用move()强转一次即可，即所谓的“手动帮编译器选择重载函数”。 回到一开始的问题，经move()的变量会被销毁咩？ 那得看移动构造函数&#x2F;移动赋值构造函数是咋实现的：在上面HashMap的那个移动构造函数中，手动释放了指针并让size清零（这也是符合实际写代码的思路的，既然认定了“这个对象不会再碰”，那就应该释放它，留着既占空间、又有修改内存的风险）；反之，如果移动构造函数中没释放右值，那它就原封不动地在那儿 —— 说到底，还是<strong>与变量是左值&#x2F;右值本身没半毛钱关系，而是取决于SMF中怎么去处理这个变量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; val)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;value: &quot;</span> &lt;&lt; val&lt;&lt; <span class="hljs-string">&quot;, type: 左值&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;&amp; val)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;value: &quot;</span> &lt;&lt; val&lt;&lt; <span class="hljs-string">&quot;, type: 右值&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-built_in">move</span>(a);<br>    <span class="hljs-built_in">test_fun</span>(a); <span class="hljs-comment">//a没有被销毁</span><br>    <span class="hljs-built_in">test_fun</span>(b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/H3Y1s7jSPFquXCK.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>核心科技看美帝</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>斯坦福</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《CS61C笔记》</title>
    <link href="/2023/04/14/%E3%80%8ACS61C%E7%AC%94%E8%AE%B0%E3%80%8B/"/>
    <url>/2023/04/14/%E3%80%8ACS61C%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>课程来源：UCB-CS61C(20 summer)</p><p>课程介绍：<a href="https://github.com/qlhhahaha/CS61C-SU20">https://github.com/qlhhahaha/CS61C-SU20</a></p>          </div><h1 id="《CS61C笔记》-qlhhahaha"><a href="#《CS61C笔记》-qlhhahaha" class="headerlink" title="《CS61C笔记》@qlhhahaha"></a>《CS61C笔记》@qlhhahaha</h1><hr><h3 id="Q-C-完全兼容C，为什么C还有单独存在的必要？"><a href="#Q-C-完全兼容C，为什么C还有单独存在的必要？" class="headerlink" title="Q: C++完全兼容C，为什么C还有单独存在的必要？"></a>Q: C++完全兼容C，为什么C还有单独存在的必要？</h3><h3 id="A"><a href="#A" class="headerlink" title="A:"></a>A:</h3><h3 id="一、大道至简，多并非好：用更少的资源做同样的事（单片机、底层芯片资源有限）"><a href="#一、大道至简，多并非好：用更少的资源做同样的事（单片机、底层芯片资源有限）" class="headerlink" title="一、大道至简，多并非好：用更少的资源做同样的事（单片机、底层芯片资源有限）"></a>一、大道至简，多并非好：用更少的资源做同样的事（单片机、底层芯片资源有限）</h3><h3 id="二、跨平台兼容性：仅有C能做到完美跨平台（这也是因为它简单，C-版本太多、标准协议都不统一，老一点的机器可能根本就不支持C17甚至C11等现代语法）"><a href="#二、跨平台兼容性：仅有C能做到完美跨平台（这也是因为它简单，C-版本太多、标准协议都不统一，老一点的机器可能根本就不支持C17甚至C11等现代语法）" class="headerlink" title="二、跨平台兼容性：仅有C能做到完美跨平台（这也是因为它简单，C++版本太多、标准协议都不统一，老一点的机器可能根本就不支持C17甚至C11等现代语法）"></a>二、跨平台兼容性：仅有C能做到完美跨平台（这也是因为它简单，C++版本太多、标准协议都不统一，老一点的机器可能根本就不支持C17甚至C11等现代语法）</h3><h3 id="三、C-太难，人力成本高，学习陡峭、维护困难"><a href="#三、C-太难，人力成本高，学习陡峭、维护困难" class="headerlink" title="三、C++太难，人力成本高，学习陡峭、维护困难"></a>三、C++太难，人力成本高，学习陡峭、维护困难</h3><h3 id="（新增：四、两种语言在实际应用中的使用思路其实差异非常大，C编程者写C-只能写出C-with-class，属于有了大炮还用棒棒戳；C-者写C会发现技能全被封印，不知如何用平A打boss——总之一句话，让剑宗和气宗各自去做自己的事吧）"><a href="#（新增：四、两种语言在实际应用中的使用思路其实差异非常大，C编程者写C-只能写出C-with-class，属于有了大炮还用棒棒戳；C-者写C会发现技能全被封印，不知如何用平A打boss——总之一句话，让剑宗和气宗各自去做自己的事吧）" class="headerlink" title="（新增：四、两种语言在实际应用中的使用思路其实差异非常大，C编程者写C++只能写出C with class，属于有了大炮还用棒棒戳；C++者写C会发现技能全被封印，不知如何用平A打boss——总之一句话，让剑宗和气宗各自去做自己的事吧）"></a>（新增：四、两种语言在实际应用中的使用思路其实差异非常大，C编程者写C++只能写出C with class，属于有了大炮还用棒棒戳；C++者写C会发现技能全被封印，不知如何用平A打boss——总之一句话，让剑宗和气宗各自去做自己的事吧）</h3><h1 id="Lecture4、C-Memory-Management"><a href="#Lecture4、C-Memory-Management" class="headerlink" title="Lecture4、C Memory Management"></a>Lecture4、C Memory Management</h1><ol><li>sizeof( )可以查看数组的大小，但不能查看指针所指区域的大小（但这仍然不应成为一种普遍用法，更好的做法是使用两个参数：数组指针和数组长度）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">61</span>] ;<br><span class="hljs-type">int</span>* ptr = a;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the size of a is: %d, ptr is %d&quot;</span>, <span class="hljs-keyword">sizeof</span>(a), <span class="hljs-keyword">sizeof</span>(ptr))<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/14/KyR5fEG2k4iWZjo.png"></p><ol start="2"><li>一种常见的内存泄漏bug —— 改变指针却未留副本</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">plk = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>...<br>plk++;<br></code></pre></td></tr></table></figure><h1 id="Lecture6、Assembly-Language-RISC-V-Intro"><a href="#Lecture6、Assembly-Language-RISC-V-Intro" class="headerlink" title="Lecture6、Assembly Language, RISC-V Intro"></a>Lecture6、Assembly Language, RISC-V Intro</h1><ol><li><strong>主流架构</strong></li></ol><p><img src="https://s2.loli.net/2023/04/14/t67yLVeOrbdn9z2.png"></p><ul><li><strong>x86：</strong>属于CISC(complex instruction set computer)，intel和AMD都使用x86架构，MacBook和pc(Core i3, i5, i7, M)皆使用x86指令集</li><li><strong>ARM：</strong>属于RISC(reduced instruction set computer)，用于智能手机、树莓派、嵌入式系统</li><li><strong>risc-V：</strong>属于RISC，新兴架构，最大优点是开源，常用于云计算、物联网等</li></ul><ol start="2"><li><strong>memory hierarchy</strong></li></ol><p><img src="https://s2.loli.net/2023/04/14/VH4ydbQIkExq7zZ.png"></p><ol start="3"><li><p><strong>riscv简介</strong></p><p> 共32个寄存器，有些用于存编程中的变量，有些用于存临时变量</p><p> <img src="https://s2.loli.net/2023/04/14/4O7d1hY6rEVZkRH.png"></p><p> <strong>基本语法：</strong></p><p> <img src="https://s2.loli.net/2023/04/14/TtZaqi3FPbB8Swk.png"></p><p> <strong>数据传输指令：</strong></p><ul><li>Load Word（lw）：读内存，即memory 到register</li><li>Store Word（sw）：反之</li></ul><p> <img src="https://s2.loli.net/2023/04/14/F6iyTX91EgADKzV.png"></p><p> <strong>内存读写指令：</strong></p><ul><li>lb：lb rd,imm(rs) —— 从内存 imm+rs 处读取8bit数据(符号拓展)到 rd 中</li><li>sb：sb rs2,imm(rs1) —— 将rs2中的8bit数据写入内存imm+rs1处</li></ul><p> <img src="https://s2.loli.net/2023/04/14/WaCwBDVMZFRTnUS.png"></p></li></ol><div class="note note-warning">            <p>💡 PS.</p><ol><li>riscv采用的是小字节序，即对于s0，第一个字节存80，第二个存01这样子</li><li>offset的单位是字节</li><li>因为lb只读写8个bit，而riscv是32位架构，所以要进行符号拓展。如给s2中读入0x80，即1000 0000，拓展后s2的前24位就都变成了F</li><li>也有其它的读写指令，如lw和sw是读写32bit数据</li></ol>          </div><p>​<strong>控制指令：</strong></p><p><img src="https://s2.loli.net/2023/04/14/iqQIOF7pmfMrJR9.png"></p><ul><li>beq：相等则跳</li><li>bne：not equal</li><li>blt：branch less than</li><li>bge：branch greater than</li><li>jal（jump and link）：jal rd,label指令的下一条指令地址存入rd,跳转到label</li></ul><p>​<strong>比较指令：</strong></p><p><img src="https://s2.loli.net/2023/04/14/LP9hcsIFHp67Cm5.png"></p><h1 id="Lecture7、RISC-V-Functions"><a href="#Lecture7、RISC-V-Functions" class="headerlink" title="Lecture7、RISC-V Functions"></a>Lecture7、RISC-V Functions</h1><ol><li><p><strong>位数拓展</strong></p><p>拓展符号位即可，即正数补充0，负数补充1</p><p><img src="https://s2.loli.net/2023/04/14/PRQYrc2WsikVbDe.png"></p></li><li><p><strong>函数</strong></p><p><img src="https://s2.loli.net/2023/04/14/ieJP4dKS5mn3faZ.png"></p><p>其中jal的参数ra是x1寄存器，存放函数返回地址（return address）</p><p>而伪指令j等效于jal x0 label，由于x0恒为0且无法更改，所以相当于只跳转而不记录返回地址；</p><p>jr等效于jalr x0,0(rs)，(rs+imm)位置的内存到x0（实际无效），并跳转到rs寄存器保存的地址</p><div class="note note-warning">            <p>💡 PS. jal和j都是用label跳转；jr是用寄存器跳转</p>          </div></li></ol><h1 id="Lecture8、RISC-V-Instruction-Formats"><a href="#Lecture8、RISC-V-Instruction-Formats" class="headerlink" title="Lecture8、RISC-V Instruction Formats"></a>Lecture8、RISC-V Instruction Formats</h1><ol><li><p><strong>汇编代码转换为二进制代码：</strong></p><p>思路：将一条汇编语句分为各个field，每个field占据一定的位长，表示特定含义（一条汇编语句占据32bit）</p><p>如R-Format语句：输入3个寄存器（add、mul等）</p><p><img src="https://s2.loli.net/2023/04/14/p3OV82MSdCsLbn6.png"></p><p>寄存器的field都是5bit，正好可以表示32个寄存器</p></li></ol><h1 id="Lecture10、digital-logic"><a href="#Lecture10、digital-logic" class="headerlink" title="Lecture10、digital logic"></a>Lecture10、digital logic</h1><ol><li><strong>布尔代数运算</strong></li></ol><p><img src="https://s2.loli.net/2023/04/14/bgfhmUysV6zwXRJ.png"></p><ol start="2"><li><strong>数电系统有两种基本类型：</strong></li></ol><ul><li><p><strong>combinational logic（CL）：</strong>输出仅仅是输入的函数，与历史状态无关（如cpu中的加法运算器）</p></li><li><p><strong>sequential logic（SL）：</strong>与历史状态有关（如memory and registers）</p></li></ul><h1 id="Lecture12、RISC-V-Datapath-Single-Cycle-Control-Intro"><a href="#Lecture12、RISC-V-Datapath-Single-Cycle-Control-Intro" class="headerlink" title="Lecture12、RISC-V Datapath, Single-Cycle Control Intro"></a>Lecture12、RISC-V Datapath, Single-Cycle Control Intro</h1><ol><li><p><strong>cpu执行汇编语句的硬件实现</strong></p><p><strong>版本1.0：</strong>实现R-type语句（以add t0 t2 t3为例）</p><p><img src="https://s2.loli.net/2023/04/14/xiFk6514aodpylg.png"></p><p>(1) 获取汇编指令：在PC寄存器中获取当前指令的地址，将指令内容传给IMEM（instruction memory），同时加4byte返回给PC（即下一条指令的地址）</p><p>(2) 将指令分段成各个field</p><p>(3) 将寄存器地址传给寄存器堆（register file），获取寄存器中的值</p><p>(4) 将获取的值传给运算器ALU，并由控制位ALUSel(ect)决定采用哪种运算（add、sub、xor。。）</p><p>(5) ALU输出运算结果并将值return给register files</p><p><strong>版本2.0：</strong>实现loads类型语句（lb、sb）</p><p><img src="https://s2.loli.net/2023/04/14/7XGujUOA5wZpdix.png"></p><p>说明：</p><p>（1）多了一个immediate generator，用于生成立即数，再在01选择器处进行选择，即add和addi的区别</p><p>（2）多了一个data memory，用于执行loads类型的指令（在内存中读写数据），其中MemRW（memory read and write）用于选择读&#x2F;写：为0时读数据，将Addr处的数据输出；为1时写数据，将输入的数据存到Addr处的内存中</p><p><img src="https://s2.loli.net/2023/04/14/jSRNUOicTJhrd4B.png"></p><p><strong>版本3.0：</strong>实现分支控制语句（beq、blt）</p><p><img src="https://s2.loli.net/2023/04/14/asl3DvzpPGjbSAc.png"></p><p>说明：多了分支控制模块，将DataA和DataB进行比较，根据结果将下面BrUn几个控制位设为0&#x2F;1，再用ASel控制01选择器，使ALU的输出为要跳转的地址，return给PC</p></li></ol><p>​<strong>最终版本：</strong>实现跳转语句</p><p><img src="https://s2.loli.net/2023/04/14/1rKli23jMkvx87Z.png"></p><h1 id="Lecture13、RISC-V-Single-Cycle-Control-and-Pipelining"><a href="#Lecture13、RISC-V-Single-Cycle-Control-and-Pipelining" class="headerlink" title="Lecture13、RISC-V Single-Cycle Control and Pipelining"></a>Lecture13、RISC-V Single-Cycle Control and Pipelining</h1><ol><li><p><strong>控制器设计</strong></p><p>以PCSel为例，默认输出0，仅当opcode为branch语句（63）或jump语句（67或6f）时才会输出1，则在mux中选择ALU输出</p><p><img src="https://s2.loli.net/2023/04/14/IURA27kP5EHxicZ.png"></p></li><li><p><strong>控制器结构</strong></p><p>观察上面的CPU结构可知，控制器一共有三个输入，其余的皆是输出</p><p>实际中由ROM实现控制器</p><p><img src="https://s2.loli.net/2023/04/14/m7x2VWFOSo1rshY.png"></p></li><li><p><strong>pipeline</strong></p><p><strong>motivation：</strong>单条指令运行时，大部分版块都处于空闲状态，</p><p><img src="https://s2.loli.net/2023/04/14/wWYksDqCdZnixHG.png"></p><p><strong>cpu性能表现：</strong></p><p><img src="https://s2.loli.net/2023/04/14/spvkcf2x5ITZz9Y.png"></p><p> （1）每个程序的指令数取决于：</p><ul><li>程序算法的时间复杂度</li><li>编程语言</li><li>编译器</li><li>ISA</li></ul><p> （2）每条指令要执行多少个cpu循环</p><ul><li>指令复杂程度</li></ul><p> （3）每个cpu循环所耗费的时间</p><ul><li>cpu设计</li><li>电子参数（晶体管尺寸、电压大小）</li></ul><p> <strong>流水线技术：</strong></p><p> <img src="https://s2.loli.net/2023/04/14/6DrgXQPSoFdTafs.png"></p> <div class="note note-warning">            <p>💡 PS. 流水线中，单个板块的耗时由短板决定   </p>          </div></li></ol><p><img src="https://s2.loli.net/2023/04/14/kOFKpimAJRhWtNu.png"></p><p>​<strong>riscv的5段流水线</strong><br><img src="https://s2.loli.net/2023/04/14/hRSsPQYO7Jpzu12.png" alt="Untitled"></p><h1 id="Lecture14、RISC-V-5-Stage-Pipeline"><a href="#Lecture14、RISC-V-5-Stage-Pipeline" class="headerlink" title="Lecture14、RISC-V 5-Stage Pipeline"></a>Lecture14、RISC-V 5-Stage Pipeline</h1><ol><li><p>流水线设计也会带来一些问题：</p><p><strong>结构性问题：</strong>抢占资源，如两条指令同时需要用到RegFile</p><p>解决思路：</p><ul><li>让读&#x2F;写端口相互独立</li><li>在一个时钟周期的前半部分写数据，后半部分读数据（这在理论上是可行的，因为RegFile的access time远低于时钟周期的一半）</li></ul><p><img src="https://s2.loli.net/2023/04/14/wNPK5C8cMFSGinW.png"></p><p><strong>数据更新问题：</strong>一个典型案例，多条语句都要对t0进行修改，但第一次还没生效，后面几次就开始用了</p><p><img src="https://s2.loli.net/2023/04/14/qfBl9nzE2GigCsW.png"></p><p>解决思路：</p><ul><li>贮存：加入一些空指令进行拖延，确保上一条指令的结果写入后，下一条指令才开始读取</li></ul><p><img src="https://s2.loli.net/2023/04/14/H6gGC5djiPaKeyW.png"></p><ul><li>转发：结果算出后立马传输给之后的ALU，而不是从RegFile中读取</li></ul><p><img src="https://s2.loli.net/2023/04/14/8ATpVMf9w7khNyb.png"></p><p><strong>分支控制问题：</strong>”等待branch语句产生结果“这一行为会带来巨大的延迟，如所谓的流水线打嗝（pipeline hiccup）产生气泡（bubble），为此我们可以使用<strong>分支预测（branch prediction）</strong>来解决这个问题。</p><p>先来看一段代码，在一个大小为32768的数组中随机、均匀地放入0~255的数字，再去统计数组中＞128的数的总和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 随机产生整数，用分区函数填充，以避免出现分桶不均</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> arraySize = <span class="hljs-number">32768</span>;<br>    <span class="hljs-type">int</span> data[arraySize];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> c = <span class="hljs-number">0</span>; c &lt; arraySize; ++c)<br>        data[c] = std::<span class="hljs-built_in">rand</span>() % <span class="hljs-number">256</span>;<br><br>    <span class="hljs-comment">// !!! 排序后下面的Loop运行将更快</span><br>    std::<span class="hljs-built_in">sort</span>(data, data + arraySize);<br><br>    <span class="hljs-comment">// 测试部分</span><br>    <span class="hljs-type">clock_t</span> start = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i)<br>    &#123;<br>        <span class="hljs-comment">// 主要计算部分，选一半元素参与计算</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> c = <span class="hljs-number">0</span>; c &lt; arraySize; ++c)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (data[c] &gt;= <span class="hljs-number">128</span>)<br>                sum += data[c];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">double</span> elapsedTime = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-built_in">clock</span>() - start) / CLOCKS_PER_SEC;<br><br>    std::cout &lt;&lt; elapsedTime &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于有序数组：</p><p><img src="https://s2.loli.net/2023/04/14/YbFymqfUp5kreCM.png"></p><p>而对于无序数组：</p><p><img src="https://s2.loli.net/2023/04/14/NfwLXZRz7yISuW5.png"></p><p>上述耗时差异由分支预测导致，而实际中的分支预测常由历史数据决定。对于有序数据，前一半皆＜128，处理器很容易找出其中的pattern；无序数组则相当于瞎蒙，只有50%的命中率</p><p><img src="https://s2.loli.net/2023/04/14/kSy1c4aegBpC8NE.png"></p><div class="note note-warning">            <p>💡 PS. 这个例子给我们启示: 在大规模循环逻辑中要尽量避免数据强依赖的分支(data-dependent branching).</p>          </div><p>分支预测的策略大致可以分为两种：静态预测和动态预测</p><p><strong>静态预测：</strong>固定的预测策略，如”≥指令一律跳，＜一律不跳“、”与上次taken保持一致“，这类策略简单易实现且能耗小，也可以保持不错的正确率（70%以上），对性能要求不是特别高但又要低功耗低成本的系统可以使用</p><p><strong>动态预测：</strong>如2-bit 状态机： 初始值为00，每当一个branch taken就+1，branch没有taken则-1。根据第一位的值来进行预测，例如11预测taken，01预测 not taken。 用一个2bit状态机的核心思路就是：<strong>这次预测错了不要紧，再给你一次机会，还是预测错了的话那再改变预测结果</strong>。总之就是提供了一定的容错率，可想而知这样的预测准确率自然也是提高了的。</p></li></ol><h1 id="Lecture15-17、-Cache"><a href="#Lecture15-17、-Cache" class="headerlink" title="Lecture15-17、 Cache"></a>Lecture15-17、 Cache</h1><ol><li><strong>典型内存分级</strong></li></ol><p><img src="https://s2.loli.net/2023/04/14/jL2HfckoJCMQ5NX.png"></p><p>​cache用static RAM：更快（1ns），但功耗更高也更贵，通电时内容一直在</p><p>​主存用dynamic RAM：更便宜也更慢（70ns），定时更新内容</p><ol start="2"><li><p><strong>两个基本原理：</strong>时间局部性（如果一个地址被访问了一次，那么它接下来还可能被访问很多次）与空间局部性（如果一个地址被访问了一次，那么它周围的内存也可能被访问，如数组）</p></li><li><p><strong>以直接映射（direct mapping）为例，完整叙述cache工作过程</strong></p><p> 假设cache大小64bytes，分为8个cache line（或称cache block），则每个line大小为8bytes</p> <div class="note note-warning">            <p>💡 PS. cache line是cache和主存之间传输数据的最小单位，line 大小一般设为word的整数倍（4byte、8byte这样子），很少会做成1byte，为什么捏？见下文分析</p>          </div><p> <img src="https://s2.loli.net/2023/04/14/DyBX4L6cQtol7s5.png"></p><p> 假设地址位宽为48bit，cpu现在要在地址为0x0654空间中读数据，那么如图，首先通过黄色部分的010（称之为<strong>index</strong>）<strong>找到对应位置的cache line</strong>（这个过程可以称之为一次hash），但光找到line还不够，因为如果两个不同地址的bit3-bit5一样的话，经过hash后都会找到同一个cache line。 下一步是比较绿色的tag——<strong>每一个cache line都对应唯一一个tag</strong>，tag中保存的是整个48bit地址除去index和offset后的剩余部分。若地址的tag和line对应的tag相等，则说明cache确实把内存中前45位地址为00….011001010xxx的那8byte空间全搞进来了，即cache hit。ok，那么接下来只需要通过<strong>蓝色的offset就可在line中找到具体的那个byte</strong>；若tag不相等，则cache miss。这也解答了我们之前的一个疑问“为啥cache line不做成一个byte”，因为原本8byte对应一个tag，现在需要8个tag，占用太多空间（tag也是cache的一部分，但我们谈到cache size的时候并不考虑tag占用的内存部分）。 图中还可以看到tag旁的valid bit，它用来表示cache line中的数据是否有效，如系统刚启动时，cache中的数据应该都是无效的，因为还没有缓存任何数据。所以实际中比较tag前还会检查valid bit是否有效，无效则直接判定cache miss。</p> <div class="note note-warning">            <p>💡 PS. 体会一下上述查找cache的过程，会发现虽然看起来有点复杂，但本质上就是个通过地址找对应数据的过程——先判断cache中是否有这前45位地址，有的话直接往后找我要的那个数据，没有的话cache miss</p>          </div><p> 直接映射优点：硬件设计简单、成本低 缺点：程序依次访问0x00、0x40、0x80（这3个地址的index一样的）时，首先访问第0个line，再访问0x40地址时依然会检索到第0个，然后发现数据缺失，于是从主存中加载0x0地址数据到第一个line，0x80亦是如此，所以此时cache的存在并没有对性能有啥提升，这种连续加载替换cache的现象叫做<strong>cache颠簸（cache thrashing）</strong>，针对这个问题我们引入多路组相连缓存</p></li><li><p><strong>两路相连缓存（two-way set associative cache）</strong></p><p>依然假设64 Bytes cache size，cache line size是8 Bytes。两路组相连缓存就是将cache平均分成2份，每份32 Bytes。</p><p><img src="https://s2.loli.net/2023/04/14/g4pRkofIhutGd7x.png"></p><p>cache被分成2路，每路包含4行cache line。我们将所有index一样的cache line组合在一起称之为一个set。例如，上图中一个组有两个cache line，总共4个组。我们依然假设从地址0x0654地址读取一个字节数据。由于cache line size是8 Bytes，因此offset需要3 bits，这和之前直接映射缓存一样；不一样的地方是index，在两路组相连缓存中，index只需要2 bits，因为一路只有4行cache line。上面的例子根据index找到第2行cache line（从0开始计算），第2行对应2个cache line，分别对应way 0和way 1。因此index也可以称作set index（组索引）。先根据index找到set，然后将组内的所有cache line对应的tag取出来和地址中的tag部分对比，如果其中一个相等就意味着命中。 因此，两路组相连缓存较直接映射缓存最大的差异就是：第一个地址对应的数据可以对应2个cache line，而直接映射缓存一个地址只对应一个cache line</p></li><li><p><strong>全相连缓存(Full associative cache)</strong></p><p>进一步把所有的cache line放在一个组里，称之为全相连缓存</p><p><img src="https://s2.loli.net/2023/04/14/Eefgy3G5dYlxDtH.png"></p><p>由于所有的cache line都在一个组内，因此地址中不需要set index部分。因为，只有一个组让你选择，也就是没得选。我们根据地址中的tag部分和所有的cache line对应的tag进行比较（硬件上可能并行比较也可能串行比较）。哪个tag比较相等，就意味着命中某个cache line。因此，在全相连缓存中，任意地址的数据可以缓存在任意的cache line中。所以，这可以最大程度的降低cache颠簸的频率，但是硬件成本上也是更高。</p></li><li><p><strong>缓存命中</strong></p><p>cache hit：cache中有block的有效副本，所以能返回期望数据</p><p>cache miss：cache中没有想要的block，所以只能从memory中取出</p><p>block replacement：若cache满了，就要撤销其中一个block，用期待读取的数据替换。但是替换哪个block捏？</p><p>常用的cache算法：</p><ul><li><p>随机替换</p></li><li><p>Least Recently Used（LRU）：最近一次访问时间最久远的那个block</p></li></ul></li><li><p><strong>多级cache之间的配合工作:</strong></p><p><img src="https://s2.loli.net/2023/04/14/X14bpdWwz5aSgCn.png"></p><p>当CPU试图从某地址load数据时，首先从L1 cache中查询是否命中，如果命中则把数据返回给CPU。如果L1 cache缺失，则继续从L2 cache中查找。当L2 cache命中时，数据会返回给L1 cache及CPU。如果L2 cache也缺失，很不幸，我们需要从主存中load数据，将数据返回给L2 cache、L1 cache及CPU。这种多级cache的工作方式称之为inclusive cache。某一地址的数据可能存在多级缓存中。与inclusive cache对应的是exclusive cache，这种cache保证某一地址的数据缓存只会存在于多级cache其中一级。也就是说，任意地址的数据不可能同时在L1和L2 cache中缓存</p></li><li><p><strong>写操作：</strong></p><p>写操作会造成cache和主存中的数据不一致，那么如何保证数据操作正确捏？</p><ul><li><p>通写（write through）：把数据写入cache的同时也写入主存，好处是保持一致性，坏处是极其影响写速度</p><p><img src="https://s2.loli.net/2023/04/14/EJbRZ36jGACeOsL.png"></p></li><li><p>回写（write back）：先把数据写回cache，当cache中的数据被替换时再写回主存。具体通过dirty bit实现，数据修改则置位。</p></li></ul><p><img src="https://s2.loli.net/2023/04/14/DHV7LmUpOwS63Ic.png"></p></li><li><p><strong>AMAT（Average Memory Access Time）</strong></p><p>同时考虑命中和丢失时的获取memory中数据的平均时间</p></li></ol><p><img src="https://s2.loli.net/2023/04/14/qd5wpKOuEiGHbyA.png"></p><p><img src="https://s2.loli.net/2023/04/14/5eh9B36T7NISdHL.png"></p><p>​AMAT&#x3D;1+0.02*50&#x3D;2 clock cycles&#x3D;400ps</p><p>​——190ps clock：2 cycles&#x3D;2*190&#x3D;380</p><p>​——MP of 40 clock cycles：1+0.02*40&#x3D;360</p><p>​<strong>——MR of 0.015*50&#x3D;350 （√）</strong></p><h1 id="Lecture18-19、Operating-Systems-amp-Virtual-Memory"><a href="#Lecture18-19、Operating-Systems-amp-Virtual-Memory" class="headerlink" title="Lecture18-19、Operating Systems &amp; Virtual Memory"></a>Lecture18-19、Operating Systems &amp; Virtual Memory</h1><ol><li><p>OS的最典型特征之一就是<strong>多任务</strong>，依赖于不同处理器的进程切换，但这个过程可能导致内存资源地址等发生变化</p><p><img src="https://s2.loli.net/2023/04/14/cwJQEKZl3WgzmU4.png"></p><p><img src="https://s2.loli.net/2023/04/14/yGSTfc3ELUFu4nQ.png"></p><p>造成这种现象的原因是应用未完全隔离，一个应用可以覆写另一个应用的内存，同时考虑到一些其他问题（如可能会处理比我们真正需求要多不少的内存，像稀疏矩阵），我们引入虚拟内存</p></li><li><p><strong>virtual memory</strong></p><ul><li>虚拟内存VM：给每个进程隔离的空间，进程认为其内存足够大，并且完全属于自己（仅自己有访问权）</li><li>物理内存PM：电脑中真实的限制性的RAM</li></ul><p><strong>key idea：</strong>由于程序大小的膨胀，且系统同时运行多个程序，经常会出现需要空间&gt;实际内存的问题，而虚拟内存可有效解决该问题：每个进程都持有各自的虚拟内存，<strong>分为很多个页</strong>，但并不是所有页都必须在内存中时才能运行程序。用到哪一页，就作映射去物理地址寻找数据；若映射这个物理地址不在内存中怎么办捏？那它在哪里捏？答案是：<strong>外存，即disk</strong>。接下来由系统自动完成将外存调入内存的的工作；而当内存空间不够时，系统按一定算法<strong>释放某部分内存空间</strong>。 通过上述操作，就能让程序在运行中感觉到拥有一个不受内存容量约束的、虚拟的、能够满足自己需求的存储器。</p><p>主要需要达成的几个目标：</p><ul><li><p>进程隔离</p></li><li><p>有限到无限空间的过渡</p></li><li><p>VM、PM地址的转换</p></li></ul></li><li><p><strong>解决思路：分段内存（segmented memory）</strong></p><p>每个段用基地址（base）和偏移地址（bound）表示，每个程序独享一个segment，在各自的内存视角中，都认为自己这个段的段首地址是0x0000</p><p>在裸的五段流水线中，PC输出的是真实的物理地址；但在base and bound机制中：</p><p><img src="https://s2.loli.net/2023/04/14/sEHDjNy6hVXOwtf.png"></p><p>但分段内存仍有一些问题：如果我们需要的地址比段空间大捏？RAM都分成了段导致连续空间不够捏？</p></li><li><p><strong>分页内存（paged memory）</strong></p><p><strong>key idea：</strong>把物理内存均分为多个page，每个进程可以独享多个page。page在RAM中不必真的连续，但在各个进程的视角看来，它们对自己来说就是连续的</p><p>那VM、PM地址如何转换呢——page table，每个进程维护一张，用于记录自己占用的page和其真实物理地址</p><p><img src="https://s2.loli.net/2023/04/14/uHglNXbaPYtRD8G.png"></p><p>注意：虚拟内存在RAM没有对应是一件很正常的事哈（图中黄色的那些页），C盘里那个巨大的PageFile.Sys就是放在外存里的虚拟内存</p></li><li><p><strong>地址转换</strong></p><p><img src="https://s2.loli.net/2023/04/14/X95WOrG2kMZ7HAp.png"></p><p><img src="https://s2.loli.net/2023/04/14/IUG75RzLhYKfJ6F.png"></p><p><strong>转换算法：</strong></p><p>1）通过virtual page number在表中找到对应位置</p><p>2）检查valid和access rights位是否有效</p><p>3）通过physical page number和offset算出物理地址</p></li><li><p><strong>页面表</strong></p><p>若是简单的线性结构表，需要表0和表n时得遍历整个表，很耗时间（一个操作系统中page table里的entry可多达数百万条），为此，我们可以使用一些改进结构</p><ul><li><p><strong>分级分页</strong></p><p><img src="https://s2.loli.net/2023/04/14/pfaS9cNI3jtsAvB.png"></p></li></ul></li><li><p><strong>页表缓冲TLB（Translation Lookaside Buffer）</strong></p><p>在分级分页中，获取一个数据可能需要多次访问physical address，造成速度缓慢，而既然page中也存在局部性，那我们可以考虑使用和cache的类似的缓存结构</p><p><img src="https://s2.loli.net/2023/04/14/J7bRiFxkNu6yQHD.png"></p><ul><li>TLB中存的不是内存数据，而是VPN→PPN的映射</li><li>TLB通常很小，一般存32-128条entry</li><li>速度比cache快很多</li></ul><p><strong>TLB和cache的组合工作原理：</strong>先在TLB中查虚拟地址，命中则直接在cache中读物理地址；否则在page table中找映射关系</p><p><img src="https://s2.loli.net/2023/04/14/kE78VqNFfGBLZlj.png"></p></li></ol><h1 id="Lecture20、IO"><a href="#Lecture20、IO" class="headerlink" title="Lecture20、IO"></a>Lecture20、IO</h1><ol><li><p><strong>disks are I&#x2F;O：</strong>因为cpu无法从磁盘（包括ssd和机械）中直接读写数据，page从disk移向RAM后才会变成memory；电脑没disk也能跑</p></li><li><p><strong>IO操作方式：</strong></p><p>处理器频率一般远大于IO设备，所以需要一定方式进行操作</p><ul><li><p><strong>轮询（polling）</strong></p><p>处理器在循环中不断等待control register信号，若ready bit置一，则处理器向data register中读写数据，c语言中的while(getchar()&#x3D;&#x3D;‘x’)其实就是一种最简单的轮询思想 轮询对于一些简单设备没问题，如鼠标，一秒只做30次polling，cpu耗时比例很低；但磁盘每秒读写数MB的数据，算下来cpu高达40%的时间都耗在轮询上，显然不可接受</p></li><li><p><strong>中断（interrupt）</strong></p><p><img src="https://s2.loli.net/2023/04/14/D5sxBgJl7cUIuOw.png"></p><p>经计算，中断可把cpu在磁盘读写上的耗时降到2%，但还可以优化</p></li><li><p><strong>DMA：</strong>memory和IO设备直接传数据，不经过cpu</p><p>一个比喻：polling像饿了去餐馆，过一会儿问下“菜好没”；interrupt像在线下单，你继续干活，做好了再叫你，去了直接拿直接走；dma则像下一单外卖，拿取都取消，只管等东西来</p><p><img src="https://s2.loli.net/2023/04/14/gMWR4TAvKzIw9Jk.png"></p><p>经计算，dma可把cpu在磁盘读写上的耗时降到0.2%</p></li></ul></li></ol><h1 id="Lecture21、Data-level-Parallelism"><a href="#Lecture21、Data-level-Parallelism" class="headerlink" title="Lecture21、Data-level Parallelism"></a>Lecture21、Data-level Parallelism</h1><ol><li><p><strong>motivation：</strong>晶体管的发展受限，无法通过提高时钟频率进一步提升cpu性能，而并行正是解决这一问题的好方法</p></li><li><p><strong>并行化分类</strong></p><p><img src="https://s2.loli.net/2023/04/14/zlKvwu2JBD8m4aL.png"></p></li><li><p><strong>SIMD(Single Instruction Multiple Data)架构</strong></p><p>许多基本数据类型为8bit，而现在处理器是32&#x2F;64bit，若一次只用64位中的低八位处理数据显然很浪费，但若将64位寄存器拆成8个8位寄存器就能同时完成8个操作，计算效率提升8倍，这就是SIMD的初衷，具体表现为向量运算</p><p><img src="https://s2.loli.net/2023/04/14/DeBKghxMAmLtojf.png"></p><p>intel的一些拓展指令集SSE（Streaming SIMD Extensions）、AVX（Advanced Vector Extensions）用于进行SIMD运算</p><p>具体实现上，常用内置函数（intrinsics）方式，如下图所示让两数组相加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add_no_SSE</span><span class="hljs-params">(<span class="hljs-type">int</span> size, <span class="hljs-type">int</span> *first_array, <span class="hljs-type">int</span> *second_array)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>first_array[i] += second_array[i];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add_SSE</span><span class="hljs-params">(<span class="hljs-type">int</span> size, <span class="hljs-type">int</span> *first_array, <span class="hljs-type">int</span> *second_array)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">4</span> &lt;= size; i+=<span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// only works if (size%4) == 0</span><br><span class="hljs-comment">// load 128-bit chunks of each array</span><br>__m128i first_values = _mm_loadu_si128((__m128i*) &amp;first_array[i]);<br>__m128i second_values = _mm_loadu_si128((__m128i*) &amp;second_array[i]);<br><span class="hljs-comment">// add each pair of 32-bit integers in the 128-bit chunks</span><br>first_values = _mm_add_epi32(first_values, second_values);<br><span class="hljs-comment">// store 128-bit chunk to first array</span><br>_mm_storeu_si128((__m128i*) &amp;first_array[i], first_values);<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>循环展开</strong></p><p><img src="https://s2.loli.net/2023/04/14/wW4sJ17DUOF3xtM.png"></p><p>为什么这种循环展开可以加速运算呢？</p><p>未展开时的汇编代码：每个元素操作完后都要跳一次loop</p><p><img src="https://s2.loli.net/2023/04/14/Z68HIYsCQLaOqRk.png"></p><p>展开后：汇编代码重排，可利用SIMD机制</p></li></ol><p><img src="https://s2.loli.net/2023/04/14/se4LKvalYpqyCRH.png"></p><h1 id="Lecture22、Thread-level-Parallelism"><a href="#Lecture22、Thread-level-Parallelism" class="headerlink" title="Lecture22、Thread-level Parallelism"></a>Lecture22、Thread-level Parallelism</h1><ol><li><p><strong>多处理器运行多进程(并行)</strong></p><p><img src="https://s2.loli.net/2023/04/14/5xt7rjyhSsvkwz1.png"></p><p>每个进程在各自的处理器上运行，但享用同样的系统内存</p></li><li><p><strong>单处理器运行多个线程（并发）</strong></p><p>各个线程有自己的PC、寄存器、栈空间，享用相同的静态空间。一个典型的例子是浏览器中开多个页面，每个页面的浏览器源码和全局设置是一样的，但有着各自不同的stack和寄存器（但事实上现在的浏览器出于安全和性能原因，给每个页面用的是独立的处理器）</p><p><img src="https://s2.loli.net/2023/04/14/vyPLMpWEcDRr6kB.png"></p><p>多线程有啥好处呢：处理器的资源宝贵，多线程可以尽可能<strong>避免其空闲，</strong>如cache miss后有个很长的memory latency，则直接切换到其它线程（所以切换上下文的开销得小于cache miss latency）</p></li><li><p><strong>并发中的一些问题</strong></p><ul><li><p><strong>加速性能</strong></p><p>阿姆达尔定律：</p><p><img src="https://s2.loli.net/2023/04/14/tj3WE45JF9sIxfg.png"></p><p>可知对于一个5%的时间使用并行，即使用5个处理器，其加速性能也不过是：</p><p><img src="https://s2.loli.net/2023/04/14/cHliG971Uqwv6Sn.png"></p><p>只有并行运算占比足够高时，处理器数量的增加才会带来明显性能提升</p><p><img src="https://s2.loli.net/2023/04/14/hgDJ5ktYdTmsX8K.png"></p><p>但这样的加速也有瓶颈，由阿姆达尔定律可知，S足够大时，speedup接近于常数</p><p><strong>解决思路：</strong>原始运算中尽可能少用标量运算，也就是尽量提升并行化占比</p></li><li><p><strong>数据竞争</strong></p><p>线程调度是<strong>不确定的</strong>，因此当多个线程对同一个变量操作时，其最终的值也是不确定的</p><p><strong>解决思路：</strong>不要往相同的内存写数据；让读写同步，从而获得确定行为</p></li></ul></li><li><p><strong>锁同步</strong></p><p>用lock来对重要区域（比如有共同操作的变量的内存区域）作访问限制，以便一次只有一个线程能访问</p><p><img src="https://s2.loli.net/2023/04/14/lkWcYZOyRASI84p.png"></p></li><li><p><strong>cache coherence</strong></p><p><img src="https://s2.loli.net/2023/04/14/wDslLqVnNKrOdg3.png"></p><p>假设两个core同时运行两个线程，都对变量i进行操作，这时A执行了i++，cache采用写回策略，即先放到自己的cache里并把dirty bit置一，并未同步到memory。这时B从内存读i的值，则读到的将会是错误值，即所谓的缓存一致性问题</p><p>解决方法：</p><ul><li><p><strong>写传播（write propagation）</strong></p><p>key idea：当某个core更新了cache中的数据时，要把该事件广播通知到其它core ，最常见的实现方法是<strong>总线嗅探（bus snooping）</strong></p><p>如core A改变了i的值后，会通过总线把这个事件广播给其它所有core；其它core随时保持监听总线上的广播事件，并检查是否有相同的数据在自己的cache里，若有则更新</p><p>但这个方法并不完美：一来每修改一个数据都要广播一次，会加重总线负载；二来总线嗅探只能保证某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串行化（即不知道谁先改谁后改）</p></li><li><p><strong>MESI 协议</strong></p><p>MESI 协议其实是 4 个状态单词的开头字母缩写，分别是：Modified（已修改）、Exclusive（独占）、Shared（共享）、Invalidated（已失效），这四个状态来标记 Cache Line 四个不同的状态</p><p>整个 MESI 状态的变更，则是根据来自本地 CPU 核心的请求，或者来自其他 CPU 核心通过总线传输过来的请求，从而构成一个流动的状态机。另外，对于在「已修改」或者「独占」状态的 Cache Line，修改更新其数据不需要发送广播给其他 CPU 核心</p><p><img src="https://s2.loli.net/2023/04/14/mTnkYR1GqaQlJEA.png"></p></li></ul></li></ol><h1 id="Lecture24、Warehouse-Scale-Computers-MapReduce"><a href="#Lecture24、Warehouse-Scale-Computers-MapReduce" class="headerlink" title="Lecture24、Warehouse Scale Computers, MapReduce"></a>Lecture24、Warehouse Scale Computers, MapReduce</h1><ol><li><p><strong>典型结构</strong></p><p><img src="https://s2.loli.net/2023/04/14/RLmXyJhxjcdo2OT.png"></p><p>一个WSC中包含多个array（aka cluster），一个array中有多个rack（机架），一个rack中又包含多个服务器</p></li><li><p><strong>阐述wsc架构工作过程（以google搜索hust为例）</strong></p><ol><li>发送请求给最近的Google warehouse scale computer</li><li>前端平衡负载，在众多cluster中找出最合适的那个</li><li>在cluster内部找出一个google web servers来处理请求，生成网页</li><li>google web servers和内部服务器交流，找到包含“hust”的那个文件</li><li>返回相关的文件列表以及对应的关联分数</li></ol><p>此外，随之发生的还可能有：</p><ul><li>推荐系统生成相关广告</li><li>根据关联分数对搜索结果进行排序，在网页中显示</li><li>对索引和文件生成副本，用于提高request-level parallelism</li></ul></li></ol><h1 id="Lecture-Bonus"><a href="#Lecture-Bonus" class="headerlink" title="Lecture_Bonus"></a>Lecture_Bonus</h1><ol><li><p><strong>进程与线程</strong></p><p>CPU执行一个函数的本质是那么<strong>把该函数对应的第一条机器指令的地址写入PC寄存器</strong>，而机器指令要加载到内存中执行，需要记录下内存的起始地址和长度，同时要找到函数的入口地址并写到PC寄存器中——这正是构建<strong>进程</strong>的思路</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">process</span>&#123;<br>   <span class="hljs-type">void</span>* start_addr;<br>   <span class="hljs-type">int</span> len;<br>   <br>   <span class="hljs-type">void</span>* start_point;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><p>​常规程序中，main()是第一个执行的；但是我们能先执行其它函数吗？能！因为main()和其它函数并无本质区别，既然可以把PC寄存器指向main()，就也可以把PC指向任何一个函数；而当我们指向非main()函数的时候，<strong>线程（thread）</strong>就诞生了</p><p><img src="https://s2.loli.net/2023/04/14/resuH62xw1tSl5D.png"></p><p>​那么进一步解放思想——一个进程内有多个入口函数，也就是说同一个进程中的机器指令可以被多个CPU同时执行，即多线程并发</p><div class="note note-warning">            <p>💡 PS.</p><ol><li>并不是一定得有多核才能多线程，单核同样可以，因为<strong>线程是OS层面的实现，与有多少个核心无关</strong>，CPU在执行机器指令时也意识不到执行的机器指令属于哪个线程</li><li>上述理论也说明了为啥OS要给每个线程分配一个栈，因为每个线程的执行流都需要保存自己正在执行的函数的数据（参数、局部变量、返回地址等）</li></ol>          </div><ol start="2"><li><p><strong>线程池</strong></p><p><strong>motivation：</strong>对于短任务（一次网络请求、数据库查询），若来一个请求就创建一个进程，用完再摧毁，则即耗时间又费内存；如果你是公司老板，和“来一个任务招一个人”相比，更好的办法当然是招一批人养着，有事做事，没事躺尸，这就是<strong>线程池（thread pool）</strong>的由来</p><p><strong>基本结构：</strong>队列结构，生产者提交任务，消费者消费任务</p><p><img src="https://s2.loli.net/2023/04/14/Ucm5pV8CeJkTzWo.png"></p><p>提交给线程池的任务包含两部分：需要被处理的数据和处理数据的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task</span> &#123;<br>   <span class="hljs-type">void</span>* data;     <span class="hljs-comment">// 任务所携带的数据</span><br>   handler handle; <span class="hljs-comment">// 处理数据的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>生产者向队列中写入数据后，线程池中的某个线程会被唤醒，该线程从队列中取出上述结构体，执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">task</span> = <span class="hljs-built_in">GetFromQueue</span>(); <span class="hljs-comment">// 从队列中取出数据</span><br> task-&gt;<span class="hljs-built_in">handle</span>(task-&gt;data);     <span class="hljs-comment">// 处理数据</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>核数与线程数的关系</strong></p><p>结论：没有直接关系，一个核可执行多个线程</p><p>Q：那么线程数为多少时性能最佳捏？</p><p>A：如果线程不涉及任何I&#x2F;O、没有任何同步互斥的纯计算类型，那么每个核心一个线程通常是最佳选择；但通常来说，线程都需要一定的I&#x2F;O，可能需要一定的同步互斥，那么此时<strong>适当增加线程</strong>可能会提高性能，但线程数量达到一个<strong>临界值后性能会开始下降</strong>，这时线程间切换的开销将显著增加。</p></li><li><p><strong>一段典型riscv代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs nasm">#打印第n个斐波那契数<br><br>.data<br>.word 2, 4, 6, 8<br>n: .word 9<br><br>.text<br>main:   <br>    add t0, x0, x0<br>    addi t1, x0, 1<br>    la t3, n <br>    lw t3, 0(t3)<br>fib:    <br>    beq t3, x0, finish<br>    add t2, t1, t0<br>    mv t0, t1<br>    mv t1, t2<br>    addi t3, t3, -1  <br>    j fib<br>finish: <br>    addi a0, x0, 1<br>    addi a1, t0, 0<br>    ecall # print integer ecall<br>    addi a0, x0, 10<br>    ecall # terminate ecall<br></code></pre></td></tr></table></figure><p>.data和.text是伪操作指令，表示将接下来的代码分配到data区和text区，.word表示按字（32bit）分配数据，即data区的第一个word放入0x02（多余的bit补零），第二个word放0x04这样子 la表示把n的地址给到t3，lw则是把n的地址中存的值放入t3中，即t3中的值变为9，la和lw通常配套使用 fib标签中的内容就是不断判断比较累加得斐波那契数了 最后的ecall是系统调用，由参数决定具体调用内容，a0和a1都是参数 (argument) 寄存器，用于在函数调用过程中保存第一个和第二个参数，以及在函数返回时传递返回值。ecall 1就是print，ecall 10就是exit</p></li><li><p><strong>流水线寄存器</strong></p><p><img src="https://s2.loli.net/2023/04/14/Iq4Qw7DaX9HbEoP.png"></p><p>流水线的基本原理如此，上面的笔记也探讨过，那具体应该怎么实现捏？或者说，普通的串联组合逻辑电路怎么就不能实现pipeline捏？</p><p>实现方法：加<strong>流水线寄存器</strong>。如我们能把指令存储器输出的指令编码事先保存下来，那就可以提前更新PC寄存器的值，并用这新的值去指令存储器当中取出一个新的指令，而在取新指令的同时，刚才取出的那条指令的编码就会被分解成不同位域，而寄存器堆也会根据输入送出对应寄存器的内容。由此就实现了各个阶段分别运行，互不干扰。</p><p> 打个比方，小志年轻力壮，搬快递时猛得一p，后面接手的老师傅说哎呀我要摸鱼，年轻人<strong>你只管搬你的别管我们</strong>（流水线思想），你速度快，多搬出来的那些<strong>放旁边小车上就好，待会我直接从小车上取就行</strong>（小车就是流水线寄存器）</p><p><img src="https://s2.loli.net/2023/04/14/fQLhHwrpKyxuIki.png" alt="Untitled"></p><p>性能分析，与之前的流水线相比，多了流水线寄存器的延迟，周期200到250ps</p><p><img src="https://s2.loli.net/2023/04/14/QAwatYbL73v1Exj.png"></p><p>而至于为什么不加寄存器就不能实现流水线，我想应解释为各部分时延不匹配造成的<strong>线路信号冲突</strong>，即如果后面部分还没执行完，IF就在一直吭哧吭哧取指，那么取出来的instruction word想必不会被ID接受，也就成了无效输入</p></li><li><p>cache<strong>命中时</strong>，策略为回写（write back）和直写（write through）； <strong>未命中时</strong>，策略为写分配（write-allocate）和无写分配（no write-allocate），写分配表示发生write miss时，把没命中的那个块放到cache中，而无写分配则意味着只改memory 通常，write back和write-allocate搭配使用，这样的memory永远不会被直接修改；write through和no write-allocate搭配</p></li><li><p><strong>用指针非空判断数组边界？</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> array[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span> , <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span>* ptr = array;<br><br>    <span class="hljs-keyword">while</span>(ptr != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\\n&quot;</span>, *ptr);<br>        ptr += <span class="hljs-number">1</span>;<br>    &#125; <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <img src="https://s2.loli.net/2023/04/14/oJjaIEqM2rtQDcX.png"></p><p> 输出结果相当炸裂，这是为什么捏？</p><p> 因为<strong>用指针非空判断数组边界本就是错的！数组大小为4不代表第五个内存空间就没有其它东西了啊！</strong>（下面这段代码也可以说明这一点，两个数组分别申请，但内存位置是连续的）</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span> , <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span> array2[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span> , <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br>    <span class="hljs-type">int</span>* ptr = <span class="hljs-built_in">array</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\\n&quot;</span>, *ptr);<br>        ptr += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <img src="https://s2.loli.net/2023/04/14/8xdBXH6YoyEjtD7.png"></p><p> 也就解释了为什么C语言中反复强调，传数组指针时，也必须显式地将数组长度传进去；光通过一个数组指针是没办法获取数组长度的！（char数组用strlen()除外） 而至于为啥在过去的代码中好像用过“指针非空”来判断边界呢。。是因为使用场景是链表，链表初始化就把next指针设为nullptr了；而像vector的边界判断，那也是用的vector.end()，是个迭代器，而不是普通的一个nullptr。。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>核心科技看美帝</category>
      
    </categories>
    
    
    <tags>
      
      <tag>体系结构</tag>
      
      <tag>riscv</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个典型的cache工作原理演示实验</title>
    <link href="/2023/04/14/%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84cache%E6%BC%94%E7%A4%BA%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/04/14/%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84cache%E6%BC%94%E7%A4%BA%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>前言：本文章将在可视化环境下对cache工作原理进行演示实验，通过下面三个实验，读者应能：</p><ol><li>理解cache三种访问模式（直连、两路相连、全连）的工作原理；</li><li>学会计算命中率（hit rate），并理解各个参数（循环次数、步长、cache size等）如何影响hit rate；</li><li>理解不同的cache策略（回写、直写、LRU）对hit rate的影响；</li><li>知道如何优化代码，以实现更高的hit rate</li></ol><p>实验来源：<a href="https://inst.eecs.berkeley.edu/~cs61c/su20/labs/lab07/">CS61C（20-SUMMER）- lab 7</a></p><p>可视化平台：<a href="https://venus.cs61c.org/">venus</a></p>          </div><div class="note note-warning">            <p>PS. 完整的题目和描述请参考<a href="https://inst.eecs.berkeley.edu/~cs61c/su20/labs/lab07/">CS61C（20-SUMMER）- lab 7</a>！下述所有分析仅相当于是实验答案，对题目本身不再赘述😪</p>          </div><p><strong>汇编对应的C代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> array[];  <span class="hljs-comment">//Assume sizeof(int) == 4</span><br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; repcount; k++) &#123;<span class="hljs-comment">// repeat repcount times</span><br>  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; arraysize; index += stepsize) &#123;<br>    <span class="hljs-keyword">if</span>(option==<span class="hljs-number">0</span>)<br>      array[index] = <span class="hljs-number">0</span>;<span class="hljs-comment">// Option 0: One cache access - write</span><br>    <span class="hljs-keyword">else</span><br>      array[index] = array[index] + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// Option 1: Two cache accesses - read AND write</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实验一：直接映射</strong></p><p>参数设置为：</p><ul><li>Array Size (a0): 128 (bytes)，即32个int</li><li>Step Size (a1): 8</li><li>Rep Count (a2): 1</li><li>Option (a3): 0</li><li>cache line设为8byte，共4个line</li><li>策略为direct map + LRU</li></ul><p>手动分析，一次for循环中，要访问array[0、8、16、24]这4个元素，访问array[0]时，cache miss（此时cache中还没东西），于是从memory中把array[0、1]都放进来；但下一次访问array[8]时仍然会miss，这么一路下来cache access为4，hit rate为0</p><p><img src="https://s2.loli.net/2023/04/14/WzSZARV1gETyI5C.png"></p><p>经验证确实如此，注意为啥只在cache0上操作捏？</p><p><img src="https://s2.loli.net/2023/04/14/lY2BUCygoJn4qvG.jpg"></p><p>看图就清楚了：index 2bit，offset 3bit。访问的是array[0、8、16、24]这几个元素，地址为0、32、64、96，其二进制的index一样的，都是对应line0</p><p>那么同理，我们把stepsize改成4、2，hit rate始终都是0;</p><p>改成1则hit rate&#x3D;50%</p><p><img src="https://s2.loli.net/2023/04/14/LqTQDVnlOGaXjrc.png" alt="Untitled"></p><p><strong>实验二：4路映射</strong></p><p>参数设置为：</p><ul><li>Array Size (a0): 256(bytes)，即64个int</li><li>Step Size (a1): 2</li><li>Rep Count (a2): 1</li><li>Option (a3): 1</li><li>cache line设为16byte，共16个line</li><li>策略为4 way set associative + LRU</li></ul><p><img src="https://s2.loli.net/2023/04/14/Daexf5wv9JUN3jp.jpg"></p><p>手动分析hit rate &#x3D; 0.75，经验证确实如此</p><p><img src="https://s2.loli.net/2023/04/14/s9TJvIlmoUVYHQX.png"></p><p>进一步思考：那把repcount设为2，hit rate还是0.75吗？</p><p>显然不是，因为第一遍for把所有cache line都填满了（整个array[]正好全装进去了！），所以后续每次cache access都会命中；hit rate &#x3D; （48+64）&#x2F;（2*64） &#x3D; 0.875</p><p><img src="https://s2.loli.net/2023/04/14/5vKhocQJH1t3V7u.png"></p><p>repcount设为100时，hit rate就很接近于100%了（这其实也是映证了cache的基本原理，时空局部性，即数据重复度越高，cache越管用）</p><p><img src="https://s2.loli.net/2023/04/14/S9wBezDrEpVi1vf.png"></p><p><strong>实验三：两级cache</strong></p><p>参数设置为：</p><ul><li>Array Size (a0): 128(bytes)，即32个int</li><li>Step Size (a1): 1</li><li>Rep Count (a2): 1</li><li>Option (a3): 0</li></ul><p>L1 cache：</p><ul><li>cache line设为8byte，共8个line</li><li>策略为direct map + LRU</li></ul><p>L2 cache：</p><ul><li>cache line设为8byte，共16个line</li><li>策略为direct map + LRU</li></ul><p><img src="https://s2.loli.net/2023/04/14/5DNjmzHWGcyhRis.png"></p><p><img src="https://s2.loli.net/2023/04/14/zygfL8HXFeiOMuk.png"></p><p><strong>解释：</strong></p><p>L1 hit rate 50%不解释，同实验一；</p><p>L2为啥是0%捏？ 其实想想那个过程就清楚了：找array[0]的时候，L1、L2都miss，然后从memory中把array[0、1]拿出来，接下来访问array[1]的时候在L1里就直接找到了，根本不会去访问L2，所以L2一共也就会访问16次，次次miss</p><p><strong>Q：</strong>改变哪个参数会让L1命中率不变且L2命中率增加？</p><p><strong>A：</strong>rep count。因为增加for重复次数时，L1中始终只装了一半的array，永远都是第一个元素miss、第二个hit；而L2 cache size为128bytes，刚好能把整个数组装下，所以rep count越大，L2的hit rate越接近于100%<br>$$</p><p>$$</p>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>体系结构</tag>
      
      <tag>cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最优化计算方法（文再文）笔记</title>
    <link href="/2023/04/13/%E3%80%8A%E6%9C%80%E4%BC%98%E5%8C%96%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E6%96%87%E5%86%8D%E6%96%87%EF%BC%89%E7%AC%94%E8%AE%B0%E3%80%8B/"/>
    <url>/2023/04/13/%E3%80%8A%E6%9C%80%E4%BC%98%E5%8C%96%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E6%96%87%E5%86%8D%E6%96%87%EF%BC%89%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="《最优化计算方法（文再文）笔记》"><a href="#《最优化计算方法（文再文）笔记》" class="headerlink" title="《最优化计算方法（文再文）笔记》"></a>《最优化计算方法（文再文）笔记》</h1><h1 id="第一章、最优化简介"><a href="#第一章、最优化简介" class="headerlink" title="第一章、最优化简介"></a>第一章、最优化简介</h1><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><ol><li><p><strong>最优化问题一般形式：</strong></p><p><img src="https://s2.loli.net/2023/04/14/wazjU2bHxYqCuVs.png"></p><p>其中$x&#x3D;(x_1,x_2,…,x_n)^T\in R^n$是<strong>决策变量</strong></p><p>$f:R^n\rightarrow R$是<strong>目标函数</strong></p><p>$\chi\in R^n$是约束集合，即<strong>可行域</strong></p><p>s.t.是subject to，专指<strong>约束条件</strong></p><p>但f(x)的min&#x2F;max不总是存在的，此时我们关心其上下确界，即将上式改为inf(sup) f(x)</p></li><li><p><strong>最优化问题分类</strong></p><ul><li>目标函数和约束函数皆为线性时，称为线性规划</li><li>至少有一个非线性时称为非线性规划</li><li>目标函数为二次函数时称为二次规划</li><li>还有整数规划、非光滑规划、无导数规划等。。</li></ul></li><li><p><strong>凸优化</strong></p><p>定义：最小化问题中，目标函数和可行域分别是凸函数和凸集；相反，只要有一个不为凸，则为非凸优化问题。因为凸优化问题的任何局部最优解都是全局最优解，所以其相应的算法设计以及理论分析相对非凸优化问题简单很多。</p><div class="note note-warning">            <p>💡 PS. 所以用凸模型对非凸问题进行转换&#x2F;逼近是一个很重要的手段</p>          </div></li></ol><h1 id="第二章、基础知识"><a href="#第二章、基础知识" class="headerlink" title="第二章、基础知识"></a>第二章、基础知识</h1><h3 id="一、概述-1"><a href="#一、概述-1" class="headerlink" title="一、概述"></a>一、概述</h3><ol><li><p><strong>矩阵范数</strong></p><p>当p&#x3D;1时，矩阵$A\in R^{m×n}$的$l_1$范数定义为：<br>$$<br>\lVert A \rVert_1&#x3D;\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^n\vert a_{ij} \vert<br>$$<br>p&#x3D;2时：<br>$$<br>\lVert A \rVert_2&#x3D;\sqrt{Tr(AA^T)}&#x3D;\sqrt{\sum_{i,j}a_{ij}^2}<br>$$<br>Tr(X)表示方阵的迹，即方阵的主对角线的元素之和</p><div class="note note-warning">            <p>💡 PS. 一个结论： 矩阵的2范数是该矩阵的最大奇异值（why？）</p>          </div></li><li><p><strong>海瑟矩阵</strong></p><p><img src="https://s2.loli.net/2023/04/14/BECN3juMKan6xLo.png"></p></li><li><p><strong>矩阵变量函数的导数</strong></p><p><img src="https://s2.loli.net/2023/04/14/hzEMxDuX9WcHiyt.png"></p><p><img src="https://s2.loli.net/2023/04/14/219YjdlZ5aShr3x.png"></p></li><li><p><strong>凸集</strong></p><p>如果连接集合C中任意两点的线段都在C内，则称C为凸集</p><p><img src="https://s2.loli.net/2023/04/14/bRu7fcMCqldoD6W.png"></p></li><li><p><strong>凸包</strong></p><p>对于形如</p><p><img src="https://s2.loli.net/2023/04/14/HZlsb1pIMCx6Gwc.png"></p><p>的点称为x1、x2。。。xk构成的<strong>凸组合</strong>，集合S中点所有可能的凸组合构成的集合称作S的<strong>凸包</strong>，记作<strong>convS</strong>．实际上，<strong>convS</strong>是包含S的最小的凸集。如下图所示，分别为离散点集的凸包和扇形的凸包。</p><p><img src="https://s2.loli.net/2023/04/14/luNXMaWSRO12Ko4.png"></p></li><li><p><strong>一些重要的凸集</strong></p><ul><li>超平面和半空间</li></ul><p><img src="https://s2.loli.net/2023/04/14/xw7VaQyXfHuZlbA.png"></p><ul><li>球、椭球、椎</li></ul><p>常规的球、椭球、椎的定义用的是欧几里得范数，但可用其它范数进行概念推广</p><p>多面体</p><ul><li>（半）正定椎</li></ul><p><img src="https://s2.loli.net/2023/04/14/DEHSgQ6AaeNpC5w.png"></p></li><li><p><strong>强凸函数</strong></p><p><img src="https://s2.loli.net/2023/04/14/Aoa2UdNbKrw7chf.png" alt="Untitled"></p><p>强凸函数减去一个正定二次函数仍然是凸的。和普通凸函数相比，强凸函数有更好的性质。</p><div class="note note-warning">            <p>💡 PS. 结论：设 <em>f</em> 为强凸函数且存在最小值，则 <em>f</em> 的最小值点唯一   </p>          </div></li></ol><h1 id="第三章、典型优化问题"><a href="#第三章、典型优化问题" class="headerlink" title="第三章、典型优化问题"></a>第三章、典型优化问题</h1><h3 id="一、线性规划"><a href="#一、线性规划" class="headerlink" title="一、线性规划"></a>一、线性规划</h3><ol><li><p>一般形式</p><p><img src="https://s2.loli.net/2023/04/14/RwBQujfqc4stJIK.png"></p><p>常见的两种形式：标准型（等式约束+决策变量非负）</p><p><img src="https://s2.loli.net/2023/04/14/WXe3PD5Oc1faYjN.png"></p><p>不等式形（没有等式约束）</p><p><img src="https://s2.loli.net/2023/04/14/f1jFugUqNXJ3PYc.png"></p></li></ol><h1 id="第四章、无约束优化算法"><a href="#第四章、无约束优化算法" class="headerlink" title="第四章、无约束优化算法"></a>第四章、无约束优化算法</h1><h3 id="一、线搜索方法"><a href="#一、线搜索方法" class="headerlink" title="一、线搜索方法"></a>一、线搜索方法</h3><p>给定当前迭代点xk，首先通过某种算法选取向量dk，之后确定正数αk，则下一步的迭代点可写作<br>$$<br>x^{k+1}&#x3D;x^k+\alpha_kd^k<br>$$<br>其中dk是搜索方向，αk是步长，线搜索算法的关键就是选取好的dk和αk，为了选出合适的步长αk，我们要引入一定的要求，称之为<strong>线搜索准则</strong>，常见的有Armijo准则、Goldstein准则、Wolfe准则等</p><p>其中，用于满足Armijo准则的常用方法是<strong>回退法</strong>，其基本思想为由大到小不断试验α，直至输出一个满足Armijo准则且尽可能大的步长</p><p><img src="https://s2.loli.net/2023/04/14/87Lrs5XoR4M9ObN.png"></p><h3 id="二、梯度类算法"><a href="#二、梯度类算法" class="headerlink" title="二、梯度类算法"></a>二、梯度类算法</h3><ol><li><p><strong>梯度下降法</strong></p><p>$$ x^{k+1}&#x3D;x^k-\alpha_k\nabla f(x^k) $$</p></li><li><p><strong>BB算法（Barzilai-Borwein）</strong></p><p>$$ x^{k+1}&#x3D;x^k-\alpha_{BB1}^K\nabla f(x^k) $$</p><p>$$ x^{k+1}&#x3D;x^k-\alpha_{BB2}^K\nabla f(x^k) $$</p><p>其中</p><p><img src="https://s2.loli.net/2023/04/14/PmaeTIGiWnXb1YH.png"></p><p><img src="https://s2.loli.net/2023/04/14/6chSM21efDy8BY7.png"></p><p>由上式可见，BB算法仅需要知道函数相邻两步的梯度信息和迭代点信息，所以BB算法的应用范围很广泛</p><p><img src="https://s2.loli.net/2023/04/14/q1dE8OU5Pr9zgGJ.png"></p></li></ol><h3 id="三、次梯度算法"><a href="#三、次梯度算法" class="headerlink" title="三、次梯度算法"></a>三、次梯度算法</h3><ol><li><p><strong>motivation：</strong>使用GDA的前提为目标函数 f(x) 是一阶可微的，但实际应用中经常会遇到<strong>不可微</strong>的函数，对于这类函数我们无法在每个点处求出梯度，但往往它们的最优值都是在不可微点处取到的。为了能处理这种情形，我们引入次梯度算法</p></li><li><p><strong>次梯度算法的结构</strong></p><p><img src="https://s2.loli.net/2023/04/14/MlaJcfgUHEtXpbo.png"></p><p>即对于凸函数来说，其切线总是在函数的下方。</p><p>类比上式可定义，给定函数f，对于任意y，如果满足：</p><p>$$ f(y)\ge f(x)+g^T(y-x) $$</p><p>则称 g 是函数 f 在点 x 处的次梯度，可见次梯度不一定唯一，也可能不存在。</p><p>将 f 在 x 处所有次梯度构成的集合称为 f 在 x 处的次微分，记作$\partial f(x)$</p><div class="note note-warning">            <p>💡 PS. 注意：次微分是一个集合，而凸函数的次微分总是非空，即必有次梯度   </p>          </div><p>假设凸函数 f 在不可微点x0处的左右导数分别为a、b，那么闭区间[a，b]中的任何一个取值都是次梯度，如$f(x)&#x3D;\vert x \vert$，则$g&#x3D;\begin{cases}sgn(x)&amp;x\neq0\ any\in[-1,1]&amp;x&#x3D;0\end{cases}$</p></li><li><p><strong>收敛性</strong></p><p>一个常用的取法是$\alpha_k&#x3D;\frac{1}{k}$，这样可保证算法的收敛性</p></li></ol><h3 id="四、牛顿类算法"><a href="#四、牛顿类算法" class="headerlink" title="四、牛顿类算法"></a>四、牛顿类算法</h3><ol><li><p><strong>motivation：</strong></p><p>梯度法仅仅依赖函数值和梯度的信息（即一阶信息），如果函数 <em>f</em>(<em>x</em>) 充分光滑，则可以利用二阶导数信息构造下降方向 <em>dk</em>。牛顿类算法就是利用二阶导数信息来构造迭代格式的算法。由于利用的信息变多，牛顿法的实际表现可以远好于梯度法，但是它对函数 <em>f</em>(<em>x</em>) 的要求也相应变高</p></li><li><p><strong>经典牛顿法</strong><br>$$<br>x^{k+1}&#x3D;x^k-\nabla^2f(x^k)^{-1}\nabla f(x^k)<br>$$<br>经典牛顿法的特点：</p><ul><li>步长恒为1</li><li>收敛速度很快，但只有局部收敛性，即初始点x0必须离真实解较近，较远时容易失效</li></ul><p>因此在在实际应用中，人们通常会使用梯度类算法先求得较低精度的解，而后调用牛顿法来获得高精度的解</p></li><li><p><strong>修正牛顿法</strong></p><p><img src="https://s2.loli.net/2023/04/14/kO4vuQbPhI3tcs6.png"></p><p>基本思想是对牛顿方程中的海瑟矩阵$\nabla^2f(x^k)$进行修正</p></li></ol><h3 id="五、拟牛顿类算法"><a href="#五、拟牛顿类算法" class="headerlink" title="五、拟牛顿类算法"></a>五、拟牛顿类算法</h3><ol><li><p><strong>motivation：</strong>拟牛顿方法不计算海瑟矩阵$\nabla^2f(x^k)$ ，而是构造其近似矩阵$B^k$或其逆的近似矩阵 $H^k$，我们希望 $B^k$ **或$H^k$仍然保留海瑟矩阵的部分性质，例如使dk仍然为下降方向</p></li><li><p><strong>算法框架</strong></p><p><img src="https://s2.loli.net/2023/04/14/P34FKpX1rmdulV5.png"></p></li><li><p><strong>拟牛顿矩阵更新方式</strong></p></li></ol><ul><li><p>秩一更新（SR1）</p><p>$$ B^{k+1}&#x3D;B^k+\dfrac{(y^k-B^ks^k)(y^k-B^k s^k)^{\text{T}}}{(y^k-B^kj)^{\text{T}}s^k} $$</p><p>$$ H^{k+1}&#x3D;H^k+\dfrac{(s^k-H^k y^k)(s^k-H^ky^k)^{\mathrm{T}}}{(s^k-H^ky^{k})^{\mathrm{T}}y^k} $$</p></li><li><p>BFGS公式</p><p>$$ B^{k+1}&#x3D;B^k+\dfrac{y^k(y^k)^{T}}{(s^k)^{T}y^k}-\dfrac{B^k s^k(B^k s^k)^}{(s^k)^{T}B^k s^k} $$</p><p>BFGS 公式是目前最有效的拟牛顿更新格式之一，它有比较好的理论性质，实现起来也并不复杂</p></li></ul><ol><li><p><strong>有限内存BFGS方法</strong></p><p>拟牛顿法虽然克服了计算海瑟矩阵的困难，但是它仍然无法应用在大规模优化问题上。一般来说，拟牛顿矩阵$B^k$ 或$H^k$ 是稠密矩阵，而存储稠密矩阵要消耗 <em>O</em>(n²) 的内存，这对于大规模问题显然是不可能实现的，故引入有限内存BFGS方法（L-BFGS）</p><p><img src="https://s2.loli.net/2023/04/14/PwRMakbExuog97v.png"></p><p><img src="https://s2.loli.net/2023/04/14/hB2pODdcqLivJRy.png"></p></li></ol><h3 id="六、信赖域算法"><a href="#六、信赖域算法" class="headerlink" title="六、信赖域算法"></a>六、信赖域算法</h3><ol><li><p><strong>motivation：</strong>在信赖域类算法中，我们直接在一个有界区域内求解这个近似模型，而后迭代到下一个点．因此信赖域算法实际上是同时选择了方向和步长</p></li><li><p><strong>形式：</strong></p><p>我们在如下球内考虑 f(x) 的近似<br>$$<br>\Omega_k&#x3D;{x^k+d\mid|d|\leqslant\Delta_k}<br>$$<br><img src="https://s2.loli.net/2023/04/14/uDc6BfUdOZrG5v2.png"></p><p>其中，mk(d)是在点x&#x3D;xk处对f(x)的近似</p><p>$$ m_k(d)&#x3D;f(x^k)+\nabla f(x^k)^{\mathrm T}d+\dfrac12d^{\mathrm T}B^kd $$</p><p>选取信赖域半径非常关键，它决定了算法的收敛性。考虑到信赖域半径是“对模型 <em>mk</em>(<em>d</em>) 相</p><p>信的程度”，如果 <em>mk</em>(<em>d</em>) 对函数 <em>f</em>(<em>x</em>) 近似较好，就应该扩大信赖域半径；反之减小。我们引入如下定义来衡量 <em>mk</em>(<em>d</em>) 近似程度的好坏</p><p>$$ \rho_k&#x3D;\dfrac{f(x^k)-f(x^k+d^k)}{m_k(0)-m_k(d^k)} $$</p><p>如果<em>ρk</em> 接近于1，说明用 <em>mk</em>(<em>d</em>) 来近似 <em>f</em>(<em>x</em>) 是比较成功的，我们应该扩大 <em>∆k</em>；如果 <em>ρk</em> 非常小甚至为负，就说明我们过分地相信了二阶模型 <em>mk</em>(<em>d</em>)，此时应该缩小 <em>∆k</em></p><p><img src="https://s2.loli.net/2023/04/14/pRejfTP5g3yAiLV.png" alt="Untitled"></p></li></ol><h1 id="第五章、约束优化算法"><a href="#第五章、约束优化算法" class="headerlink" title="第五章、约束优化算法"></a>第五章、约束优化算法</h1><h3 id="一、罚函数法"><a href="#一、罚函数法" class="headerlink" title="一、罚函数法"></a>一、罚函数法</h3><ol><li><p><strong>motivation：</strong></p><p>可行域的约束导致很多无约束算法不能直接使用（如梯度下降沿负梯度下降的点未必是可行点），而罚函数的思想是将约束条件作为惩罚项加到目标函数中，从而转换为无约束优化问题。</p><p>而这样做的原理是什么捏 —— 对于<strong>可行域外的点，惩罚项为正</strong>，即对该点进行惩罚；对于<strong>可行域内的点，惩罚项为 0</strong>，即不做任何惩罚。因此，惩罚项会促使无约束优化问题的解落在可行域内（好聪明的做法）。</p></li><li><p><strong>等式约束条件罚函数</strong></p><p><img src="https://s2.loli.net/2023/04/14/pDF1ZyodE9vP5jI.png"></p></li><li><p><strong>不等式约束</strong></p><p><img src="https://s2.loli.net/2023/04/14/xX73rBP5fuwVtlS.png"></p><p>我们设计加入罚函数的目标函数为：</p><p><img src="https://s2.loli.net/2023/04/14/WXZBYGvCbUFSNo2.png"></p><p><img src="https://s2.loli.net/2023/04/14/KEHV2ipQcxqT7N9.png"></p><p>这样的罚函数只会惩罚ci(x)＞0的部分，且由于函数 <em>h</em>(<em>t</em>) &#x3D; (max*{t*, 0*}*)²关于 <em>t</em> 是可导的，因此 <em>PI</em>(<em>x</em>,<em>σ</em>) 的梯度也存在，则可以使用梯度类算法来求解子问题</p></li><li><p><strong>内点罚函数</strong></p><p>基本思想：普通的外点罚函数允许取可行域之外的点，只是要进行惩罚；而内点法直接不允许取可行域之外的点，即从可行域内部逼近最优解</p><p><img src="https://s2.loli.net/2023/04/14/2LPyCemrqFWRujQ.png"></p><p>上式既做到了限制可行域，又做到了“x趋近于边界时进行惩罚”（In无穷大）</p></li></ol><h3 id="二、增广拉格朗日函数法"><a href="#二、增广拉格朗日函数法" class="headerlink" title="二、增广拉格朗日函数法"></a>二、增广拉格朗日函数法</h3><ol><li><strong>结构</strong></li></ol><p><img src="https://s2.loli.net/2023/04/14/67anqbXZ3CoHMRx.png"></p><ol><li><p><strong>一般约束优化问题的增广拉格朗日函数法</strong></p><p><img src="https://s2.loli.net/2023/04/14/2DK1ludNp9EkQit.png"></p><p>思路：引入松弛变量将不等式约束转化为等式约束和简单的非负约束，再构造增广拉格朗日函数</p><p><img src="https://s2.loli.net/2023/04/14/9CePmiN4RJXKWHg.png"></p><p>对上述问题我们可以构造出一个经典的拉格朗日函数</p><p><img src="https://s2.loli.net/2023/04/14/A2b8cl9PHEz4NJf.png"></p></li></ol><h1 id="第六章、复合优化算法"><a href="#第六章、复合优化算法" class="headerlink" title="第六章、复合优化算法"></a>第六章、复合优化算法</h1><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>复合优化问题定义为：</p><p><img src="https://s2.loli.net/2023/04/14/7fLqF8cXxjO3ZVS.png"></p><p>其中 <em>f</em>(<em>x</em>) 为可微函数（可能非凸），<em>h</em>(<em>x</em>) 可能为不可微函数</p><h3 id="二、近似点梯度法"><a href="#二、近似点梯度法" class="headerlink" title="二、近似点梯度法"></a>二、近似点梯度法</h3><ol><li><p><strong>邻近算子</strong></p><p>对于一个凸函数 <em>h</em>，定义它的邻近算子为</p><p><img src="https://s2.loli.net/2023/04/14/MXkIeUJt6zPBFlC.png"></p><p>可见，邻近算子的目的是求解一个距 <em>x</em> 不算太远的点，并使函数值 <em>h</em>(<em>x</em>) 也相对较小</p></li><li><p><strong>公式</strong></p><p>对于一个复合优化问题</p><p><img src="https://s2.loli.net/2023/04/14/P4NxGtKcvzmS8XF.png"></p><p>近似点梯度法的思想非常简单：注意到 <em>ψ</em>(<em>x</em>) 有两部分，对于光滑部分<em>f</em> 做梯度下降，对于非光滑部分 <em>h</em> 使用邻近算子，则近似点梯度法的迭代公式为：</p><p><img src="https://s2.loli.net/2023/04/14/aOG3ESCUkqFM5Np.png"></p><p>其中 <em>tk &gt;</em> 0 为每次迭代的步长，它可以是一个常数或者由线搜索得出。</p><p><img src="https://s2.loli.net/2023/04/14/jTPA6um7OtqriVL.png"></p></li></ol><h3 id="三、Nesterov加速算法"><a href="#三、Nesterov加速算法" class="headerlink" title="三、Nesterov加速算法"></a>三、Nesterov加速算法</h3><ol><li><p><strong>FISTA算法</strong>（可对近似点梯度算法进行加速）</p><p>FISTA 算法由两步组成：第一步沿着前两步的计算方向计算一个新点，第二步在该新点处做一步近似点梯度迭代，即</p><p><img src="https://s2.loli.net/2023/04/14/Oyvg5k97UMNCELB.png"></p><p><img src="https://s2.loli.net/2023/04/14/LFejMiZGSY1V2Nn.png"></p></li></ol><h3 id="四、分块坐标下降法（block-coordinate-descent，BCD）"><a href="#四、分块坐标下降法（block-coordinate-descent，BCD）" class="headerlink" title="四、分块坐标下降法（block coordinate descent，BCD）"></a>四、分块坐标下降法（block coordinate descent，BCD）</h3><ol><li><p><strong>motivation：</strong> 实际问题中的目标函数虽可能有成百上千个自变量，求解十分困难，但当固定其中若干变量时，函数的结构会得到极大的简化，是原问题被拆分为数个只有少数自变量的子问题，这也正是BCD方法的基本思想</p></li><li><p><strong>形式：</strong></p><p><img src="https://s2.loli.net/2023/04/14/Z8oWvxUuVjlCy9H.png"></p><p>将自变量 <em>x</em> 拆分成 <em>s</em> 个变量块 <em>x</em>1, <em>x</em>2,<em>···</em> , <em>xs</em>，函数 <em>f</em> 是关于 <em>x</em> 的可微函数，每个 <em>ri</em>(<em>xi</em>) 关于 <em>xi</em> 是适当的闭凸函数。 单独考虑每一块自变量时，f 有简单结构，ri 只与第 i 个自变量块有关</p></li><li><p><strong>举例</strong></p><p>考虑二元二次函数的优化问题</p><p><img src="https://s2.loli.net/2023/04/14/Z8oWvxUuVjlCy9H.png"></p><p>现在对变量 <em>x</em>,<em>y</em> 使用分块坐标下降法求解。当固定 <em>y</em> 时，可知当 <em>x</em> &#x3D; 2 + <em>y</em>时函数取极小值；当固定 <em>x</em> 时，可知当 <em>y</em> &#x3D; 1 +*x&#x2F;*10时函数取极小值。故采用的分块坐标下降法为：</p><p><img src="https://s2.loli.net/2023/04/14/O5J1ovfhcqgCaZt.png"></p><p>经验证，初始点为(0.5, 0.2)时，经过七次迭代就与最优解相当接近</p><p><img src="https://s2.loli.net/2023/04/14/JDINTVim7MEvOKZ.png"></p></li></ol><h3 id="五、对偶算法"><a href="#五、对偶算法" class="headerlink" title="五、对偶算法"></a>五、对偶算法</h3><ol><li>对偶思想常用思路有两种：把前面的算法应用到对偶问题上，如对偶近似点梯度法；另一种是同时把原始问题和对偶问题结合起来考虑，如原始-对偶混合梯度类算法 对偶算法主要考虑如下形式的问题：</li></ol><p><img src="https://s2.loli.net/2023/04/14/CVquzigKfx4jYQJ.png"></p><ol start="2"><li><strong>对偶近似点梯度法</strong></li></ol><p>​如果我们写出上述约束优化问题的拉格朗日函数和增广拉格朗日函数</p><p><img src="https://s2.loli.net/2023/04/14/pfmt3ELqnaowGNk.png"></p><p>​则迭代格式可以写为</p><p><img src="https://s2.loli.net/2023/04/14/81PytDkENRAsQVY.png"></p><p>​上述迭代格式又称为<strong>交替极小化方法，</strong>第一步迭代为在拉格朗日函数中关于 <em>x</em> 求极小，第二步迭代为在增广拉格朗日函数中关于 <em>y</em> 求极小，第三步迭代为更新拉格朗日乘子。</p><ol start="3"><li><strong>原始-对偶混合梯度算法（primaldual hybrid gradient, PDHG）</strong></li></ol><p>​PDGH在每次迭代时同时考虑原始变量和对偶变量的更新，这使得它在一定程度上可以有效避免单独针对原始问题或对偶问题求解算法中可能出现的问题 仍然考虑如下形式：</p><p><img src="https://s2.loli.net/2023/04/14/5ERFWfJcpC9xrlb.png"></p><p>​其中 <em>f</em> , <em>h</em> 是适当的闭凸函数．由于 <em>h</em> 有自共轭性，我们将上述问题变形为：</p><p><img src="https://s2.loli.net/2023/04/14/qclZvI8Y1K5EsGF.png"></p><p>​此时问题变形为一个极小-极大问题，即一个典型的<strong>鞍点问题</strong>。PDHG 算法交替更新原始变量以及对偶变量，其迭代格式如下：</p><p><img src="https://s2.loli.net/2023/04/14/89ROHGwP5YDfgoc.png"></p><h3 id="六、交替方向乘子法（alternating-direction-method-of-multipliers-ADMM）"><a href="#六、交替方向乘子法（alternating-direction-method-of-multipliers-ADMM）" class="headerlink" title="六、交替方向乘子法（alternating direction method of multipliers, ADMM）"></a>六、交替方向乘子法（alternating direction method of multipliers, ADMM）</h3><ol><li><p><strong>定义：</strong></p><p>本节考虑如下凸问题：</p><p><img src="https://s2.loli.net/2023/04/14/OjyM8sLdxBIUTho.png"></p><p>注意：很多常见的问题都可转化为上述形式</p><p>如把</p><p><img src="https://s2.loli.net/2023/04/14/ePVhFaBwXq4dG5g.png"></p><p>转化为：</p><p><img src="https://s2.loli.net/2023/04/14/5NPCMdZmROeQ23B.png"></p><p>再比如对于<strong>一致性问题</strong>：</p><p><img src="https://s2.loli.net/2023/04/14/4ZTa6v2eUuIQSPx.png"></p><p>令 <em>x</em> &#x3D; <em>z</em>，并将 <em>x</em> 复制 <em>N</em> 份，分别为 <em>xi</em>，那么问题转化为：</p><p><img src="https://s2.loli.net/2023/04/14/KVco15f4PrFmuUx.png"></p><p>如果令$x&#x3D;(x_1^\mathrm T,x_2^\mathrm T,\cdots,x_N^\mathrm T)^\mathrm T$以及$f_1(x)&#x3D;\sum\limits_{i&#x3D;1}^N\phi_i(x_i),\quad f_2(z)&#x3D;0$ 则此问题可以化为：</p><p><img src="https://s2.loli.net/2023/04/14/lUen9HYD73EhXdW.png"></p><p>其中矩阵 <em>A</em>1, <em>A</em>2 定义为：</p><p><img src="https://s2.loli.net/2023/04/14/hFfUAVeaGOc731n.png"></p></li><li><p><strong>迭代格式</strong></p><p>首先写出问题的增广拉格朗日函数</p><p><img src="https://s2.loli.net/2023/04/14/ckdolxbypJTeZ42.png"></p><p>则迭代格式为：</p></li></ol><p><img src="https://s2.loli.net/2023/04/14/62H5jK1lVUkQrzO.png"></p>]]></content>
    
    
    <categories>
      
      <category>科研只为把业毕</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>凸优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>借top K题目思考总结堆（heap）与优先队列（priority_queque）用法</title>
    <link href="/2023/04/13/%E5%80%9FtopK%E9%A2%98%E7%9B%AE%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%94%A8%E6%B3%95/"/>
    <url>/2023/04/13/%E5%80%9FtopK%E9%A2%98%E7%9B%AE%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>今天做了传说中的top K ，即“<strong>用大顶堆&#x2F;小顶堆对数据进行排序</strong>”的经典题目</p><p><img src="https://s2.loli.net/2023/04/13/ayuA9B7DGbOni2p.png"><br>本题思路：</p><ol><li>用map记录每个元素出现的频率</li><li>用heap对map进行排序并节选出前K个元素</li></ol><p>若第一次见此类题，难点当为heap的原理和对应stl容器（priority_queue）的用法。查阅了一些资料，发现不管是leetcode题解抑或博客文章都写得略语焉不详，对新手不甚友好，故笔者试图用自己的话对其原理进行粗糙解释。</p><hr><h1 id="二、堆（heap）的原理和用法（下述所有例子默认用小顶堆）"><a href="#二、堆（heap）的原理和用法（下述所有例子默认用小顶堆）" class="headerlink" title="二、堆（heap）的原理和用法（下述所有例子默认用小顶堆）"></a>二、堆（heap）的原理和用法（下述所有例子默认用小顶堆）</h1><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>（1） 堆是一种具有特殊排序关系的完全二叉树，也就是说，堆首先得具有完全二叉树的所有特性<br>（2） 特殊排序关系指——以小顶堆为例——<strong>每个节点的value都小于其两个子节点</strong> ；大顶堆反之</p><p>下图就是一个典型的小顶堆</p><p><img src="https://s2.loli.net/2023/04/13/LYr9ecyzTOpSwCM.png"></p><h3 id="3-堆的建立（push）"><a href="#3-堆的建立（push）" class="headerlink" title="3.堆的建立（push）"></a>3.堆的建立（push）</h3><p>对于一个已经建好的堆，push新元素的方法是：</p><ol><li><strong>插入</strong>：将该元素插入到heap的尾部</li><li><strong>比较</strong>：然后不断“上浮”，直至满足堆的条件。所谓“上浮”，就是将该元素与其父节点进行比较，比父节点小则上浮一层，否则不动，一直操作直至上浮不动。</li></ol><p>而若是要从零开始建立一个堆捏？很简单，从第一个元素开始，对每个元素都执行一次push操作就行了。<br>下图展示了从零开始建立一个heap过程</p><p><img src="https://s2.loli.net/2023/04/13/gkV1vRcHpiLSujf.jpg"></p><h3 id="2-堆的删除（pop）"><a href="#2-堆的删除（pop）" class="headerlink" title="2.堆的删除（pop）"></a>2.堆的删除（pop）</h3><p>三步走：</p><ol><li><strong>弹出</strong>：将堆顶元素（即最小的那个元素）直接pop</li><li><strong>提上</strong>：将heap的最后一个元素提到堆顶</li><li><strong>下沉</strong>：将提上的这个堆顶元素不断与其子节点比较，大于子节点就下沉一层，直至全满足定义</li></ol><p>如下图所示<br><img src="https://s2.loli.net/2023/04/13/RXMb5QG1VdutzF6.jpg"></p><hr><h1 id="三、优先队列（priority-queue）的使用"><a href="#三、优先队列（priority-queue）的使用" class="headerlink" title="三、优先队列（priority_queue）的使用"></a>三、优先队列（priority_queue）的使用</h1><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>我们可以用c++ stl中的priority_queue容器来实现heap的操作，其定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = std::vector&lt;T&gt;,<br>    <span class="hljs-keyword">class</span> Compare = std::less&lt;<span class="hljs-keyword">typename</span> Container::value_type&gt;<br>&gt; <span class="hljs-keyword">class</span> priority_queue;<br></code></pre></td></tr></table></figure><p>T是指堆中元素的<strong>数据类型</strong>；<br>container指用于存储这些元素的<strong>底层容器类型</strong>（<strong>默认用vector</strong>，一般也不用改）；<br>compare是元素之间的<strong>比较方式</strong>，用于决定建立的是大顶堆or小顶堆，默认用less函数建立大顶堆（当然，你也可以自定义compare方法来建立一些奇奇怪怪的堆。。）</p><h3 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h3><p>和普通队列一样，常用的就pop()、push()、top()、empty()</p><h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3.代码示例"></a>3.代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">print_queue</span><span class="hljs-params">(T&amp; q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; q.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : &#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;)<br>        q.<span class="hljs-built_in">push</span>(n);<br> <br>    <span class="hljs-built_in">print_queue</span>(q);<br> <br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt; &gt; q2;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : &#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;)<br>        q2.<span class="hljs-built_in">push</span>(n);<br> <br>    <span class="hljs-built_in">print_queue</span>(q2);<br> <br>    <span class="hljs-comment">// 用 lambda 比较元素。</span><br>    <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123; <span class="hljs-built_in">return</span> (left ^ <span class="hljs-number">1</span>) &lt; (right ^ <span class="hljs-number">1</span>); &#125;;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">q3</span>(cmp);<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : &#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;)<br>        q3.<span class="hljs-built_in">push</span>(n);<br> <br>    <span class="hljs-built_in">print_queue</span>(q3);<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="https://s2.loli.net/2023/04/13/n4RIGtX7NACKceQ.png"><br>上述代码及运行结果，与前面我手画的那两张图都是吻合的</p><hr><h1 id="四、题解"><a href="#四、题解" class="headerlink" title="四、题解"></a>四、题解</h1><p>回到开头那道topK力扣题，答案如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 小顶堆</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> <br>    &#123;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span><br><span class="hljs-function">            </span>&#123;<br>                <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>            &#125;<br>    &#125;;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter : nums) &#123;<br>            map[iter]++;<br>        &#125;<br><br>        <span class="hljs-comment">// 对频率排序</span><br>        <span class="hljs-comment">// 定义一个小顶堆，大小为k</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br><br>        <span class="hljs-comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">begin</span>(); it != map.<span class="hljs-built_in">end</span>(); it++) <br>        &#123;<br>            pri_que.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span> (pri_que.<span class="hljs-built_in">size</span>() &gt; k) &#123; <span class="hljs-comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span><br>                pri_que.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result[i] = pri_que.<span class="hljs-built_in">top</span>().first;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>做一些解释说明：</p><ol><li><p>首先注意，我们要<strong>找出前K大的元素，那要用的是小顶堆</strong>，因为小顶堆才能把小元素排出去，剩下的就是前K大元素嘛</p></li><li><p>map中的单个元素的数据类型是pair&lt;Type, Type&gt;</p></li><li><p>关于compare方法的理解：默认的<strong>less方法建立的是大顶堆</strong>，要<strong>建立小顶堆则改用greater&lt;T&gt;</strong></p><p>然后所谓的less方法，是将第一个实参（称之为左实参）与第二个实参（称之为右实参）进行比较，return left&lt;right——那么左实参更小时则为true，为true则交换；greater方法反之，return left&gt;right；</p><p>在上述代码的自定义方法mycomparison中也可以说明这一点，它使用的是return left&gt;right,即greater方法，即建立小顶堆</p></li></ol><blockquote><p>总结：<br>建立大顶堆 &#x3D; less方法 &#x3D; return left &lt; right<br>建立小顶堆 &#x3D; greater方法 &#x3D; return left &gt; right</p></blockquote><div class="note note-warning">            <p>TO-DO：<br>上述第三条纯属自己理解，这么死记用来做题应用没啥问题，但还是得挑个良辰吉日去翻翻源码才行捏😣</p>          </div>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>借一道leetcode思考总结map/set的应用及区别</title>
    <link href="/2023/04/13/%E5%80%9F%E4%B8%80%E9%81%93leetcode%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93mapset%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/04/13/%E5%80%9F%E4%B8%80%E9%81%93leetcode%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93mapset%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原题是leetcode349，要求两个数组的交集</p><p><img src="https://s2.loli.net/2023/04/13/WmNqiBn9R6Lh7f4.png" alt=" "><br>这题本身不难，主要是要考虑到：</p><ol><li>原题只需求“频率”，无需考虑“顺序”，则应使用哈希表结构，而不是顺序结构+两个for暴力遍历</li><li>用于作键值key的是数字而非字母，所以应该用正儿八经的set&#x2F;map，而不是用vector搞伪hash（否则当数字键值很大且稀疏时，vector会浪费大量空间） </li><li>不需要设置明确的key，所以用set，而不是map</li><li>不考虑顺序，所以用unordered_set</li></ol><p>上述思路理清之后，代码自然就出来了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果，之所以用set是为了给结果集去重</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter : nums2) <br>        &#123;<br>            <span class="hljs-comment">// 发现nums2的元素 在nums_set里又出现过</span><br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(iter) != nums_set.<span class="hljs-built_in">end</span>()) <br>            &#123;<br>                result_set.<span class="hljs-built_in">insert</span>(iter); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由此题我们可以一窥set&#x2F;map的具体使用场景，下面对其差别和应用进行简单总结</p><hr><h1 id="一、定义和类型"><a href="#一、定义和类型" class="headerlink" title="一、定义和类型"></a>一、定义和类型</h1><p>STL中的部分容器（vector、list、deque等）底层为线性序列的数据结构，故将这些容器统称为<strong>序列式容器</strong>，里面存储的是元素本身；对应的，有另外一种用&lt;key，value&gt;键值对方式储存数据的数据结构，我们称其为<strong>关联式容器</strong>，典型的有set类和map类容器。</p><p>这种关联式容器的motivition应该是用某种特殊的底层数据结构来代替线性序列，以避免线性结构容易导致的空间浪费问题，同时提高curd效率 – – 线性序列为O(n)，那再提高就是O(log n)和O(1)，对应的是啥捏？</p><p><em><strong>树和hash table嘛！这也正是set\map的底层实现方式</strong></em></p><p>具体如下：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值可重复</th><th>数值可更改</th><th>curd效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td></tr></tbody></table><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值可重复</th><th>数值可更改</th><th>curd效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>有序</td><td>key不可重复</td><td>否</td><td>O(log n)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>有序</td><td>key可重复</td><td>否</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>key不可重复</td><td>否</td><td>O(1)</td></tr></tbody></table><p>其需要注意的是，set\multiset\map\multimap的实现都为红黑树，红黑树是一种平衡二叉搜索树，所以key有序且不能修改，修改key会导致整棵树的错乱；<br>而我们要用集合来解决hash问题时，优先使用unordered，因为其底层使用hash table，curd效率最高（只需执行一次hash function，复杂度为O(1)）</p><hr><h1 id="二、set类说明"><a href="#二、set类说明" class="headerlink" title="二、set类说明"></a>二、set类说明</h1><ol><li>与map&#x2F;multimap不同，map中存储的是真正的键值对&lt;key, value&gt;，set中只放value，但在底层实际存放的是由&lt;value, value&gt;构成的键值对（即一个元素的value同时也会标识它，value就是key）。故set中插入元素时，<strong>只需要插入value即可，不需要构造键值对</strong></li><li>set中的元素不可以重复，因此可以使用set进行<strong>去重</strong></li><li>set中的元素有序（默认升序），故可用iteration<strong>遍历set得有序序列</strong></li><li>set中的元素<strong>不允许修改</strong>（元素总是const）</li><li>set中的count()方法只能返回0或1，所以其实就是个find()。。而find()返回的是查找元素的位置指针，没有则返回set.end()</li><li>multiset与set的区别是<strong>前者中的元素可重复</strong>，其它都一样</li><li>unordered_set与set的区别是<strong>前者中的元素不会排序</strong></li></ol><p>代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestSet</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 用数组array中的元素构造set</span><br><span class="hljs-type">int</span> array[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span> &#125;;<br>set&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : array)<br>s.<span class="hljs-built_in">insert</span>(e);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;set中的元素个数为: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">// 正向打印set中的元素，从打印结果中可以看出：set可去重</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;正向打印set中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : s)<br>cout&lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 使用迭代器逆向打印set中的元素</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;逆向打印set中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">rbegin</span>(); it != s.<span class="hljs-built_in">rend</span>(); ++it)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// set中值为3的元素出现了几次</span><br>cout &lt;&lt; <span class="hljs-string">&quot;set中值为x的元素出现了几次：&quot;</span> &lt;&lt; s.<span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br><br>    <span class="hljs-function">multiset&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">muls</span><span class="hljs-params">(array, array + <span class="hljs-keyword">sizeof</span>(array) / <span class="hljs-keyword">sizeof</span>(array[<span class="hljs-number">0</span>]))</span></span>;<br>    cout &lt;&lt;  <span class="hljs-string">&quot;正向打印multiset中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : muls)<br>cout &lt;&lt;e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><br>    <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">unorders</span><span class="hljs-params">(array, array + <span class="hljs-keyword">sizeof</span>(array) / <span class="hljs-keyword">sizeof</span>(array[<span class="hljs-number">0</span>]))</span></span>;<br>    cout &lt;&lt;  <span class="hljs-string">&quot;打印unordered_set中的元素: &quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : unorders)<br>cout &lt;&lt;e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">TestSet</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<br> <img src="https://s2.loli.net/2023/04/13/w8kQyJztoIBaq1E.png"></p><hr><h1 id="三、map类说明"><a href="#三、map类说明" class="headerlink" title="三、map类说明"></a>三、map类说明</h1><ol><li>需要<strong>构造键值对</strong></li><li>map支持下标访问符，即在[]中放入key，就可以找到与key对应的value；也支持.at()方法，但二者有所不同（见下面代码）</li><li>multimap和map的唯一不同就是：map中的<strong>key是唯一</strong>的，而multimap中key是<strong>可以重复的</strong></li><li>unordered_map和map : : unordered_map存储元素时是<strong>没有顺序的</strong>，只是根据key的哈希值，将元素存在指定位置，所以根据key查找单个value时非常高效</li></ol><p>代码示例（来源: <a href="https://blog.csdn.net/qq_61635026/article/details/126070134?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166593410616782412589556%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166593410616782412589556&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-126070134-null-null.142%5Ev56%5Econtrol_1,201%5Ev3%5Econtrol_2&utm_term=stl%20set%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB&spm=1018.2226.3001.4187">C++ STL中 set和map介绍以及使用方法</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestMap</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;string, string&gt; m;<br><span class="hljs-comment">// 向map中插入元素的方式：</span><br><span class="hljs-comment">// 将键值对&lt;&quot;peach&quot;,&quot;桃子&quot;&gt;插入map中，用pair直接来构造键值对</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, string&gt;(<span class="hljs-string">&quot;peach&quot;</span>, <span class="hljs-string">&quot;桃子&quot;</span>));<br><span class="hljs-comment">// 将键值对&lt;&quot;peach&quot;,&quot;桃子&quot;&gt;插入map中，用make_pair函数来构造键值对</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;banan&quot;</span>, <span class="hljs-string">&quot;香蕉&quot;</span>));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">operator[]的原理是：</span><br><span class="hljs-comment"> 用&lt;key, T()&gt;构造一个键值对，然后调用insert()函数将该键值对插入到map中</span><br><span class="hljs-comment"> 如果key已经存在，插入失败，insert函数返回该key所在位置的迭代器</span><br><span class="hljs-comment"> 如果key不存在，插入成功，insert函数返回新插入元素所在位置的迭代器</span><br><span class="hljs-comment"> operator[]函数最后将insert返回值键值对中的value返回</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 将&lt;&quot;apple&quot;, &quot;&quot;&gt;插入map中，插入成功，返回value的引用，将“苹果”赋值给该引用结果</span><br>m[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-string">&quot;苹果&quot;</span>;<br><br><span class="hljs-comment">// key不存在时抛异常</span><br><span class="hljs-comment">//m.at(&quot;waterme&quot;) = &quot;水蜜桃&quot;;</span><br><br>cout &lt;&lt; m.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 用迭代器去遍历map中的元素，可以得到一个按照key排序的序列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : m)<br>cout &lt;&lt; e.first &lt;&lt; <span class="hljs-string">&quot;---&gt;&quot;</span> &lt;&lt; e.second &lt;&lt; endl;<br>cout &lt;&lt; endl;<br><span class="hljs-comment">// map中的键值对key一定是唯一的，如果key存在将插入失败</span><br><span class="hljs-keyword">auto</span> ret = m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;peach&quot;</span>, <span class="hljs-string">&quot;another桃子&quot;</span>));<br><span class="hljs-keyword">if</span> (ret.second)<br>cout &lt;&lt; <span class="hljs-string">&quot;&lt;peach, another桃子&gt;不在map中, 已经插入&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot;键值为peach的元素已经存在：&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="hljs-string">&quot;---&gt;&quot;</span><br>&lt;&lt; ret.first-&gt;second &lt;&lt; <span class="hljs-string">&quot; 插入失败&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 删除key为&quot;apple&quot;的元素</span><br>m.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;apple&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == m.<span class="hljs-built_in">count</span>(<span class="hljs-string">&quot;apple&quot;</span>))<br>cout &lt;&lt; <span class="hljs-string">&quot;apple还在&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot;apple被吃了&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">TestMap</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p> <img src="https://s2.loli.net/2023/04/13/A3rM12B8DJKzVS7.png"><br>如果用at()查值，则key不在时抛出异常</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;waterme&quot;</span>) = <span class="hljs-string">&quot;水蜜桃&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/13/bMPIHgarpTBKlu1.png"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>1. 用set类还是map类？</strong><br>如果需要建立明确的<strong>键值对应关系</strong>（如示例中的水果），那只能用map；如果只需知道“<strong>存在与否</strong>”，那用set就够了（如leetcode例题，其实没有体现一个明确的key，coding时关心的也是value而不是key）</p><p><strong>2. 用set类还是array伪hash？</strong><br>如果key分布在一个<strong>不大的连续区间</strong>内（ 如26个字母），则可以直接用array，这样更快，因为set不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的；<br>但如果key随机则用set，如key为<strong>分布稀疏</strong>的大数字时，用数组就非常浪费空间，只能用set。</p><p><strong>3. 用set还是unordered_set？（map同理）</strong><br>有序set（红黑树），无序unordered_set（hash table）</p><p><strong>PS.</strong> py中的in关键字在不同结构中（tuple, list, dict, set）查找元素时效率是相差很大的，因为dict, set底层是一个hash table；而tuple, list只是一个单纯类于数组的线性结构。。</p>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
      <tag>哈希算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分类占坑2</title>
    <link href="/2023/04/13/%E5%8D%A0%E4%B8%AA%E5%9D%912/"/>
    <url>/2023/04/13/%E5%8D%A0%E4%B8%AA%E5%9D%912/</url>
    
    <content type="html"><![CDATA[<p>NEW_PC TEST</p><p>这篇文章只是为了在分类板块中占个坑😆😆</p><p>顺便作为测试</p><p>这是一句话<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="参考资料1">[1]</span></a></sup></p><p>$$<br>E&#x3D;mc^2<br>$$</p><div class="note note-warning">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><p class="note note-primary">标签</p><span class="label label-primary">text</span><p><span class="label label-primary">Label</span></p>            <input type="checkbox" disabled checked="checked">text          <a class="btn" href="url"  title="title" target="_blank">text</a><p><a class="btn" href="url" title="title">text</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>$$</p><p>$$<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这是对应的脚注<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span>参考资料1<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>参考资料2<br><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    <categories>
      
      <category>偶尔也得摸摸鱼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记位运算符(＞＞)使用不当引起的一次bug</title>
    <link href="/2023/04/13/%E8%AE%B0%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6(%EF%BC%9E%EF%BC%9E)%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%80%E6%AC%A1bug/"/>
    <url>/2023/04/13/%E8%AE%B0%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6(%EF%BC%9E%EF%BC%9E)%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%80%E6%AC%A1bug/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>今天刷leetcode时遇到个死活也想不通的bug</p><p>原题很简单，线性数组插值问题，暴力遍历和二分法都可以做</p><p> <img src="https://s2.loli.net/2023/04/13/ifSOReA2dapUFsh.png"><br>不假思索用区间左闭右开的二分法，三下五除二就整了出来，胸有成竹😋</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.size();<br>        <span class="hljs-keyword">while</span>(left &lt; right)<br>        &#123;<br>            <span class="hljs-type">int</span> middle = left + (right - left) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target )<br>                right = middle;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target )<br>                left = middle + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>谁知提交时一直在示例3（即输入数组为[1 3 5 6]，查询值target &#x3D; 7）卡bug，提示超时。。</p><hr><h1 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h1><p>原以为是区间边界条件设置不当，反复检查，手动演算，脑袋想破了也觉得没问题。。</p><p>无奈debug，发现执行这一句后，middle一值变化很奇怪。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> middle = left + (right - left) &gt;&gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>突然虎躯一震，意识到可能是运算符优先级一问题，速google之，果然！</p><p><img src="https://s2.loli.net/2023/04/13/ildhp5643oy9vXw.png"></p><p><em><strong>原来加减符的优先级是要高于位运算符的！</strong></em><br>一验证发现也的确如此<br><img src="https://s2.loli.net/2023/04/13/r8KHytNjmulQXIv.png"></p><p><img src="https://s2.loli.net/2023/04/13/pCmWrFxzQE8AY1T.png"></p><hr><h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><p>加个括号即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> middle = left +( (right - left) &gt;&gt; <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>问题解决，顺利通关！</p><p><img src="https://s2.loli.net/2023/04/13/vtzFBo3YmZqg4XV.png"></p><hr><h1 id="总结反思："><a href="#总结反思：" class="headerlink" title="总结反思："></a>总结反思：</h1><ol><li>善于使用括号，尤其是主观上希望某个式子部分先运算时。</li><li>老老实实用乘除得了，别整些什么花里胡哨trick。。代码省下几毫秒，debug多花几十分钟。。</li></ol>]]></content>
    
    
    <categories>
      
      <category>自己事情靠自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
